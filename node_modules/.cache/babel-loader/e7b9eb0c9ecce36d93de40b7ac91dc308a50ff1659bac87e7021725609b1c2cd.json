{"ast":null,"code":"import { ascending } from \"d3-array\";\nimport { scaleLinear } from \"d3-scale\";\nimport { levelDefinition } from \"./levels\";\nconst MAX_LEVEL = levelDefinition.length - 1;\nexport default function financeDiscontinuousScale(index, backingLinearScale = scaleLinear()) {\n  if (index === undefined) {\n    throw new Error(\"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\");\n  }\n  function scale(newScale) {\n    return backingLinearScale(newScale);\n  }\n  scale.invert = value => {\n    const inverted = backingLinearScale.invert(value);\n    return Math.round(inverted * 10000) / 10000;\n  };\n  scale.domain = newDomain => {\n    if (newDomain === undefined) {\n      return backingLinearScale.domain();\n    }\n    backingLinearScale.domain(newDomain);\n    return scale;\n  };\n  scale.range = range => {\n    if (range === undefined) {\n      return backingLinearScale.range();\n    }\n    backingLinearScale.range(range);\n    return scale;\n  };\n  scale.rangeRound = range => {\n    return backingLinearScale.rangeRound(range);\n  };\n  scale.clamp = clamp => {\n    if (clamp === undefined) {\n      return backingLinearScale.clamp();\n    }\n    backingLinearScale.clamp(clamp);\n    return scale;\n  };\n  scale.interpolate = interpolate => {\n    if (interpolate === undefined) {\n      return backingLinearScale.interpolate();\n    }\n    backingLinearScale.interpolate(interpolate);\n    return scale;\n  };\n  scale.ticks = m => {\n    var _a, _b, _c;\n    const backingTicks = backingLinearScale.ticks(m);\n    const ticksMap = new Map();\n    const [domainStart, domainEnd] = backingLinearScale.domain();\n    const dStart = Math.ceil(domainStart);\n    const dHead = (_a = index[0]) === null || _a === void 0 ? void 0 : _a.index;\n    const start = Math.max(dStart, dHead) + Math.abs(dHead);\n    const end = Math.min(Math.floor(domainEnd), (_b = index[index.length - 1]) === null || _b === void 0 ? void 0 : _b.index) + Math.abs(dHead);\n    const desiredTickCount = Math.ceil((end - start) / (domainEnd - domainStart) * backingTicks.length);\n    for (let i = MAX_LEVEL; i >= 0; i--) {\n      const ticksAtLevel = ticksMap.get(i);\n      const temp = ticksAtLevel === undefined ? [] : ticksAtLevel.slice();\n      for (let j = start; j <= end; j++) {\n        if (index[j].level === i) {\n          temp.push(index[j]);\n        }\n      }\n      ticksMap.set(i, temp);\n    }\n    let unsortedTicks = [];\n    for (let k = MAX_LEVEL; k >= 0; k--) {\n      const selectedTicks = (_c = ticksMap.get(k)) !== null && _c !== void 0 ? _c : [];\n      if (selectedTicks.length + unsortedTicks.length > desiredTickCount * 1.5) {\n        break;\n      }\n      unsortedTicks = unsortedTicks.concat(selectedTicks.map(d => d.index));\n    }\n    const ticks = unsortedTicks.sort(ascending);\n    if (end - start > ticks.length) {\n      const ticksSet = new Set(ticks);\n      const d = Math.abs(index[0].index);\n      // ignore ticks within this distance\n      const distance = Math.ceil((backingTicks.length > 0 ? (backingTicks[backingTicks.length - 1] - backingTicks[0]) / backingTicks.length / 4 : 1) * 1.5);\n      for (let i = 0; i < ticks.length - 1; i++) {\n        for (let j = i + 1; j < ticks.length; j++) {\n          if (ticks[j] - ticks[i] <= distance) {\n            ticksSet.delete(index[ticks[i] + d].level >= index[ticks[j] + d].level ? ticks[j] : ticks[i]);\n          }\n        }\n      }\n      // @ts-ignore\n      const tickValues = [...ticksSet.values()].map(i => parseInt(i, 10));\n      return tickValues;\n    }\n    return ticks;\n  };\n  scale.tickFormat = () => {\n    return function (x) {\n      const d = Math.abs(index[0].index);\n      const {\n        format,\n        date\n      } = index[Math.floor(x + d)];\n      return format(date);\n    };\n  };\n  scale.value = x => {\n    const d = Math.abs(index[0].index);\n    const row = index[Math.floor(x + d)];\n    if (row !== undefined) {\n      const {\n        date\n      } = row;\n      return date;\n    }\n  };\n  scale.nice = count => {\n    backingLinearScale.nice(count);\n    return scale;\n  };\n  scale.index = x => {\n    if (x === undefined) {\n      return index;\n    }\n    index = x;\n    return scale;\n  };\n  scale.copy = () => {\n    return financeDiscontinuousScale(index, backingLinearScale.copy());\n  };\n  return scale;\n}","map":{"version":3,"names":["ascending","scaleLinear","levelDefinition","MAX_LEVEL","length","financeDiscontinuousScale","index","backingLinearScale","undefined","Error","scale","newScale","invert","value","inverted","Math","round","domain","newDomain","range","rangeRound","clamp","interpolate","ticks","m","backingTicks","ticksMap","Map","domainStart","domainEnd","dStart","ceil","dHead","_a","start","max","abs","end","min","floor","_b","desiredTickCount","i","ticksAtLevel","get","temp","slice","j","level","push","set","unsortedTicks","k","selectedTicks","_c","concat","map","d","sort","ticksSet","Set","distance","delete","tickValues","values","parseInt","tickFormat","x","format","date","row","nice","count","copy"],"sources":["C:\\Users\\gabby\\trax-x\\node_modules\\@react-financial-charts\\scales\\src\\financeDiscontinuousScale.ts"],"sourcesContent":["import { ascending } from \"d3-array\";\nimport { scaleLinear, InterpolatorFactory } from \"d3-scale\";\nimport { levelDefinition } from \"./levels\";\n\nconst MAX_LEVEL = levelDefinition.length - 1;\n\nexport default function financeDiscontinuousScale(index: any[], backingLinearScale = scaleLinear()) {\n    if (index === undefined) {\n        throw new Error(\"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\");\n    }\n\n    function scale(newScale: number) {\n        return backingLinearScale(newScale);\n    }\n    scale.invert = (value: number) => {\n        const inverted = backingLinearScale.invert(value);\n        return Math.round(inverted * 10000) / 10000;\n    };\n    scale.domain = (newDomain?: number[]) => {\n        if (newDomain === undefined) {\n            return backingLinearScale.domain();\n        }\n\n        backingLinearScale.domain(newDomain);\n        return scale;\n    };\n    scale.range = (range?: number[]) => {\n        if (range === undefined) {\n            return backingLinearScale.range();\n        }\n\n        backingLinearScale.range(range);\n        return scale;\n    };\n    scale.rangeRound = (range: number[]) => {\n        return backingLinearScale.rangeRound(range);\n    };\n    scale.clamp = (clamp?: boolean) => {\n        if (clamp === undefined) {\n            return backingLinearScale.clamp();\n        }\n\n        backingLinearScale.clamp(clamp);\n        return scale;\n    };\n    scale.interpolate = (interpolate?: InterpolatorFactory<number, number>) => {\n        if (interpolate === undefined) {\n            return backingLinearScale.interpolate();\n        }\n\n        backingLinearScale.interpolate(interpolate);\n        return scale;\n    };\n    scale.ticks = (m?: number) => {\n        const backingTicks = backingLinearScale.ticks(m);\n        const ticksMap = new Map<number, any[]>();\n\n        const [domainStart, domainEnd] = backingLinearScale.domain();\n\n        const dStart = Math.ceil(domainStart);\n        const dHead = index[0]?.index;\n        const start = Math.max(dStart, dHead) + Math.abs(dHead);\n        const end = Math.min(Math.floor(domainEnd), index[index.length - 1]?.index) + Math.abs(dHead);\n\n        const desiredTickCount = Math.ceil(((end - start) / (domainEnd - domainStart)) * backingTicks.length);\n\n        for (let i = MAX_LEVEL; i >= 0; i--) {\n            const ticksAtLevel = ticksMap.get(i);\n            const temp = ticksAtLevel === undefined ? [] : ticksAtLevel.slice();\n\n            for (let j = start; j <= end; j++) {\n                if (index[j].level === i) {\n                    temp.push(index[j]);\n                }\n            }\n\n            ticksMap.set(i, temp);\n        }\n\n        let unsortedTicks: number[] = [];\n        for (let k = MAX_LEVEL; k >= 0; k--) {\n            const selectedTicks = ticksMap.get(k) ?? [];\n            if (selectedTicks.length + unsortedTicks.length > desiredTickCount * 1.5) {\n                break;\n            }\n            unsortedTicks = unsortedTicks.concat(selectedTicks.map((d) => d.index));\n        }\n\n        const ticks = unsortedTicks.sort(ascending);\n\n        if (end - start > ticks.length) {\n            const ticksSet = new Set(ticks);\n\n            const d = Math.abs(index[0].index);\n\n            // ignore ticks within this distance\n            const distance = Math.ceil(\n                (backingTicks.length > 0\n                    ? (backingTicks[backingTicks.length - 1] - backingTicks[0]) / backingTicks.length / 4\n                    : 1) * 1.5,\n            );\n\n            for (let i = 0; i < ticks.length - 1; i++) {\n                for (let j = i + 1; j < ticks.length; j++) {\n                    if (ticks[j] - ticks[i] <= distance) {\n                        ticksSet.delete(index[ticks[i] + d].level >= index[ticks[j] + d].level ? ticks[j] : ticks[i]);\n                    }\n                }\n            }\n\n            // @ts-ignore\n            const tickValues = [...ticksSet.values()].map((i) => parseInt(i, 10));\n\n            return tickValues;\n        }\n\n        return ticks;\n    };\n    scale.tickFormat = () => {\n        return function (x: any) {\n            const d = Math.abs(index[0].index);\n            const { format, date } = index[Math.floor(x + d)];\n            return format(date);\n        };\n    };\n    scale.value = (x: any) => {\n        const d = Math.abs(index[0].index);\n        const row = index[Math.floor(x + d)];\n        if (row !== undefined) {\n            const { date } = row;\n            return date;\n        }\n    };\n    scale.nice = (count?: number) => {\n        backingLinearScale.nice(count);\n        return scale;\n    };\n    scale.index = (x?: any[]) => {\n        if (x === undefined) {\n            return index;\n        }\n        index = x;\n        return scale;\n    };\n    scale.copy = () => {\n        return financeDiscontinuousScale(index, backingLinearScale.copy());\n    };\n    return scale;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}