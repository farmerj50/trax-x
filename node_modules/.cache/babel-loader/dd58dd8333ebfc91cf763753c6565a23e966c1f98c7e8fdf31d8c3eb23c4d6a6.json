{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nimport { head, last, getClosestItemIndexes, isDefined, isNotDefined, getLogger } from \"../utils\";\nvar log = getLogger(\"evaluator\");\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n  var lastItem = fallbackEnd.lastItem,\n    lastItemX = fallbackEnd.lastItemX;\n  var lastItemXValue = xAccessor(lastItem);\n  var _initialXScale$range = initialXScale.range(),\n    _initialXScale$range2 = _slicedToArray(_initialXScale$range, 2),\n    rangeStart = _initialXScale$range2[0],\n    rangeEnd = _initialXScale$range2[1];\n  var newEnd = (rangeEnd - rangeStart) / (lastItemX - rangeStart) * (lastItemXValue - start) + start;\n  return newEnd;\n}\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n  function filterData(data, inputDomain, xAccessor, initialXScale) {\n    var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n      currentPlotData = _ref.currentPlotData,\n      currentDomain = _ref.currentDomain,\n      fallbackStart = _ref.fallbackStart,\n      fallbackEnd = _ref.fallbackEnd;\n    if (useWholeData) {\n      return {\n        plotData: data,\n        domain: inputDomain\n      };\n    }\n    var left = head(inputDomain);\n    var right = last(inputDomain);\n    var clampedDomain = inputDomain;\n    var filteredData = getFilteredResponse(data, left, right, xAccessor);\n    if (filteredData.length === 1 && isDefined(fallbackStart)) {\n      left = fallbackStart;\n      right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n      clampedDomain = [left, right];\n      filteredData = getFilteredResponse(data, left, right, xAccessor);\n    }\n    if (typeof clamp === \"function\") {\n      clampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n    } else {\n      if (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [Math.max(left, xAccessor(head(data))), clampedDomain[1]];\n      }\n      if (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [clampedDomain[0], Math.min(right, xAccessor(last(data)))];\n      }\n    }\n    if (clampedDomain !== inputDomain) {\n      filteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n    }\n    var realInputDomain = clampedDomain;\n    // [xAccessor(head(filteredData)), xAccessor(last(filteredData))];\n\n    var xScale = initialXScale.copy().domain(realInputDomain);\n    var width = Math.floor(xScale(xAccessor(last(filteredData))) - xScale(xAccessor(head(filteredData))));\n\n    // prevent negative width when flipXScale\n    if (flipXScale && width < 0) {\n      width = width * -1;\n    }\n    var plotData = void 0,\n      domain = void 0;\n    var chartWidth = last(xScale.range()) - head(xScale.range());\n    log(\"Trying to show \" + filteredData.length + \" points in \" + width + \"px,\" + (\" I can show up to \" + (showMaxThreshold(width, pointsPerPxThreshold) - 1) + \" points in that width. \") + (\"Also FYI the entire chart width is \" + chartWidth + \"px and pointsPerPxThreshold is \" + pointsPerPxThreshold));\n    if (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n      plotData = filteredData;\n      domain = realInputDomain;\n      log(\"AND IT WORKED\");\n    } else {\n      if (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n        plotData = filteredData;\n        var newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n        domain = [head(realInputDomain), newEnd];\n        // plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        // domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n        var newXScale = xScale.copy().domain(domain);\n        var newWidth = Math.floor(newXScale(xAccessor(last(plotData))) - newXScale(xAccessor(head(plotData))));\n        log(\"and ouch, that is too much, so instead showing \" + plotData.length + \" in \" + newWidth + \"px\");\n      } else {\n        plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n        var _newXScale = xScale.copy().domain(domain);\n        var _newWidth = Math.floor(_newXScale(xAccessor(last(plotData))) - _newXScale(xAccessor(head(plotData))));\n        log(\"and ouch, that is too much, so instead showing \" + plotData.length + \" in \" + _newWidth + \"px\");\n      }\n    }\n    return {\n      plotData: plotData,\n      domain: domain\n    };\n  }\n  return {\n    filterData: filterData\n  };\n}\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n  return arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);\n}\nfunction showMinThreshold(width, threshold) {\n  return Math.max(1, Math.ceil(width * threshold));\n}\nfunction showMaxThreshold(width, threshold) {\n  return Math.floor(width * threshold);\n}\nfunction showMax(width, threshold) {\n  return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\nfunction getFilteredResponse(data, left, right, xAccessor) {\n  var newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n  var newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n  var filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n  // console.log(right, newRightIndex, dataForInterval.length);\n\n  return filteredData;\n}\nexport default function (_ref2) {\n  var xScale = _ref2.xScale,\n    useWholeData = _ref2.useWholeData,\n    clamp = _ref2.clamp,\n    pointsPerPxThreshold = _ref2.pointsPerPxThreshold,\n    minPointsPerPxThreshold = _ref2.minPointsPerPxThreshold,\n    flipXScale = _ref2.flipXScale;\n  return extentsWrapper(useWholeData || isNotDefined(xScale.invert), clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale);\n}","map":{"version":3,"names":["head","last","getClosestItemIndexes","isDefined","isNotDefined","getLogger","log","getNewEnd","fallbackEnd","xAccessor","initialXScale","start","lastItem","lastItemX","lastItemXValue","_initialXScale$range","range","_initialXScale$range2","_slicedToArray","rangeStart","rangeEnd","newEnd","extentsWrapper","useWholeData","clamp","pointsPerPxThreshold","minPointsPerPxThreshold","flipXScale","filterData","data","inputDomain","_ref","arguments","length","undefined","currentPlotData","currentDomain","fallbackStart","plotData","domain","left","right","clampedDomain","filteredData","getFilteredResponse","Math","max","min","realInputDomain","xScale","copy","width","floor","chartWidth","showMaxThreshold","canShowTheseManyPeriods","newXScale","newWidth","slice","showMax","_newXScale","_newWidth","arrayLength","maxThreshold","minThreshold","showMinThreshold","threshold","ceil","newLeftIndex","newRightIndex","_ref2","invert"],"sources":["C:\\Users\\gabby\\trax-x\\node_modules\\src\\lib\\scale\\evaluator.js"],"sourcesContent":["\n\nimport {\n\thead,\n\tlast,\n\tgetClosestItemIndexes,\n\tisDefined,\n\tisNotDefined,\n\tgetLogger,\n} from \"../utils\";\n\nconst log = getLogger(\"evaluator\");\n\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n\tconst {\n\t\tlastItem, lastItemX\n\t} = fallbackEnd;\n\tconst lastItemXValue = xAccessor(lastItem);\n\tconst [rangeStart, rangeEnd] = initialXScale.range();\n\n\tconst newEnd = (rangeEnd - rangeStart) / (lastItemX - rangeStart) * (lastItemXValue - start) + start;\n\treturn newEnd;\n}\n\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n\tfunction filterData(\n\t\tdata, inputDomain, xAccessor, initialXScale,\n\t\t{ currentPlotData, currentDomain, fallbackStart, fallbackEnd } = {}\n\t) {\n\t\tif (useWholeData) {\n\t\t\treturn { plotData: data, domain: inputDomain };\n\t\t}\n\n\t\tlet left = head(inputDomain);\n\t\tlet right = last(inputDomain);\n\t\tlet clampedDomain = inputDomain;\n\n\t\tlet filteredData = getFilteredResponse(data, left, right, xAccessor);\n\n\t\tif (filteredData.length === 1 && isDefined(fallbackStart)) {\n\t\t\tleft = fallbackStart;\n\t\t\tright = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n\n\t\t\tclampedDomain = [\n\t\t\t\tleft,\n\t\t\t\tright,\n\t\t\t];\n\t\t\tfilteredData = getFilteredResponse(data, left, right, xAccessor);\n\t\t}\n\n\t\tif (typeof clamp === \"function\") {\n\t\t\tclampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n\t\t} else {\n\t\t\tif (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n\t\t\t\tclampedDomain = [\n\t\t\t\t\tMath.max(left, xAccessor(head(data))),\n\t\t\t\t\tclampedDomain[1]\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tif (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n\t\t\t\tclampedDomain = [\n\t\t\t\t\tclampedDomain[0],\n\t\t\t\t\tMath.min(right, xAccessor(last(data)))\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tif (clampedDomain !== inputDomain) {\n\t\t\tfilteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n\t\t}\n\n\t\tconst realInputDomain = clampedDomain;\n\t\t// [xAccessor(head(filteredData)), xAccessor(last(filteredData))];\n\n\t\tconst xScale = initialXScale.copy().domain(realInputDomain);\n\n\t\tlet width = Math.floor(xScale(xAccessor(last(filteredData)))\n\t\t\t- xScale(xAccessor(head(filteredData))));\n\n\t\t// prevent negative width when flipXScale\n\t\tif (flipXScale && width < 0) {\n\t\t\twidth = width * -1;\n\t\t}\n\n\t\tlet plotData, domain;\n\n\t\tconst chartWidth = last(xScale.range()) - head(xScale.range());\n\n\t\tlog(`Trying to show ${filteredData.length} points in ${width}px,`\n\t\t\t+ ` I can show up to ${showMaxThreshold(width, pointsPerPxThreshold) - 1} points in that width. `\n\t\t\t+ `Also FYI the entire chart width is ${chartWidth}px and pointsPerPxThreshold is ${pointsPerPxThreshold}`);\n\n\t\tif (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n\t\t\tplotData = filteredData;\n\t\t\tdomain = realInputDomain;\n\t\t\tlog(\"AND IT WORKED\");\n\t\t} else {\n\t\t\tif (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n\t\t\t\tplotData = filteredData;\n\t\t\t\tconst newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n\t\t\t\tdomain = [\n\t\t\t\t\thead(realInputDomain),\n\t\t\t\t\tnewEnd\n\t\t\t\t];\n\t\t\t\t// plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n\t\t\t\t// domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n\t\t\t\tconst newXScale = xScale.copy().domain(domain);\n\t\t\t\tconst newWidth = Math.floor(newXScale(xAccessor(last(plotData)))\n\t\t\t\t\t- newXScale(xAccessor(head(plotData))));\n\n\t\t\t\tlog(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n\t\t\t} else {\n\t\t\t\tplotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n\t\t\t\tdomain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n\t\t\t\tconst newXScale = xScale.copy().domain(domain);\n\t\t\t\tconst newWidth = Math.floor(newXScale(xAccessor(last(plotData)))\n\t\t\t\t\t- newXScale(xAccessor(head(plotData))));\n\n\t\t\t\tlog(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n\t\t\t}\n\t\t}\n\t\treturn { plotData, domain };\n\t}\n\treturn { filterData };\n}\n\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n\treturn arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);\n}\n\nfunction showMinThreshold(width, threshold) {\n\treturn Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width, threshold) {\n\treturn Math.floor(width * threshold);\n}\n\nfunction showMax(width, threshold) {\n\treturn Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse(data, left, right, xAccessor) {\n\tconst newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n\tconst newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n\n\tconst filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n\t// console.log(right, newRightIndex, dataForInterval.length);\n\n\treturn filteredData;\n}\n\nexport default function({\n\txScale, useWholeData, clamp,\n\tpointsPerPxThreshold, minPointsPerPxThreshold,\n\tflipXScale\n}) {\n\treturn extentsWrapper(\n\t\tuseWholeData || isNotDefined(xScale.invert),\n\t\tclamp,\n\t\tpointsPerPxThreshold,\n\t\tminPointsPerPxThreshold,\n\t\tflipXScale\n\t);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}