{"ast":null,"code":"import * as React from \"react\";\nimport { getStrokeDasharray, getStrokeDasharrayCanvas, isDefined } from \"@react-financial-charts/core\";\nexport const renderSVG = props => {\n  const {\n    className\n  } = props;\n  const edge = helper(props);\n  if (edge === null) {\n    return null;\n  }\n  let line;\n  let coordinateBase;\n  let coordinate;\n  if (edge.line !== undefined) {\n    line = React.createElement(\"line\", {\n      className: \"react-financial-charts-cross-hair\",\n      stroke: edge.line.stroke,\n      strokeDasharray: getStrokeDasharray(edge.line.strokeDasharray),\n      x1: edge.line.x1,\n      y1: edge.line.y1,\n      x2: edge.line.x2,\n      y2: edge.line.y2\n    });\n  }\n  if (edge.coordinate !== undefined && edge.coordinateBase !== undefined) {\n    const {\n      rectWidth,\n      rectHeight,\n      arrowWidth\n    } = edge.coordinateBase;\n    const path = edge.orient === \"left\" ? `M0,0L0,${rectHeight}L${rectWidth},${rectHeight}L${rectWidth + arrowWidth},10L${rectWidth},0L0,0L0,0` : `M0,${arrowWidth}L${arrowWidth},${rectHeight}L${rectWidth + arrowWidth},${rectHeight}L${rectWidth + arrowWidth},0L${arrowWidth},0L0,${arrowWidth}`;\n    coordinateBase = edge.orient === \"left\" || edge.orient === \"right\" ? React.createElement(\"g\", {\n      key: 1,\n      transform: `translate(${edge.coordinateBase.edgeXRect},${edge.coordinateBase.edgeYRect})`\n    }, React.createElement(\"path\", {\n      d: path,\n      className: \"react-financial-charts-text-background\",\n      height: rectHeight,\n      width: rectWidth,\n      stroke: edge.coordinateBase.stroke,\n      strokeLinejoin: \"miter\",\n      strokeWidth: edge.coordinateBase.strokeWidth,\n      fill: edge.coordinateBase.fill\n    })) : React.createElement(\"rect\", {\n      key: 1,\n      className: \"react-financial-charts-text-background\",\n      x: edge.coordinateBase.edgeXRect,\n      y: edge.coordinateBase.edgeYRect,\n      height: rectHeight,\n      width: rectWidth,\n      fill: edge.coordinateBase.fill\n    });\n    coordinate = React.createElement(\"text\", {\n      key: 2,\n      x: edge.coordinate.edgeXText,\n      y: edge.coordinate.edgeYText,\n      textAnchor: edge.coordinate.textAnchor,\n      fontFamily: edge.coordinate.fontFamily,\n      fontSize: edge.coordinate.fontSize,\n      dy: \".32em\",\n      fill: edge.coordinate.textFill\n    }, edge.coordinate.displayCoordinate);\n  }\n  return React.createElement(\"g\", {\n    className: className\n  }, line, coordinateBase, coordinate);\n};\nconst helper = props => {\n  const {\n    coordinate: displayCoordinate,\n    show,\n    type,\n    orient,\n    edgeAt,\n    hideLine,\n    lineStrokeDasharray,\n    fill,\n    fontFamily,\n    fontSize,\n    textFill,\n    lineStroke,\n    stroke,\n    strokeWidth,\n    arrowWidth,\n    rectWidth,\n    rectHeight,\n    rectRadius,\n    x1,\n    y1,\n    x2,\n    y2,\n    dx\n  } = props;\n  if (!show) {\n    return null;\n  }\n  let coordinateBase;\n  let coordinate;\n  if (displayCoordinate !== undefined) {\n    const textAnchor = \"middle\";\n    let edgeXRect;\n    let edgeYRect;\n    let edgeXText;\n    let edgeYText;\n    if (type === \"horizontal\") {\n      edgeXRect = dx + (orient === \"right\" ? edgeAt + 1 : edgeAt - rectWidth - 1);\n      edgeYRect = y1 - rectHeight / 2 - strokeWidth;\n      edgeXText = dx + (orient === \"right\" ? edgeAt + rectWidth / 2 : edgeAt - rectWidth / 2);\n      edgeYText = y1;\n    } else {\n      const dy = orient === \"bottom\" ? strokeWidth - 1 : -strokeWidth + 1;\n      edgeXRect = x1 - rectWidth / 2;\n      edgeYRect = (orient === \"bottom\" ? edgeAt : edgeAt - rectHeight) + dy;\n      edgeXText = x1;\n      edgeYText = (orient === \"bottom\" ? edgeAt + rectHeight / 2 : edgeAt - rectHeight / 2) + dy;\n    }\n    coordinateBase = {\n      edgeXRect,\n      edgeYRect,\n      rectHeight: rectHeight + strokeWidth,\n      rectWidth,\n      rectRadius,\n      fill,\n      arrowWidth,\n      stroke,\n      strokeWidth\n    };\n    coordinate = {\n      edgeXText,\n      edgeYText,\n      textAnchor,\n      fontFamily,\n      fontSize,\n      textFill,\n      displayCoordinate\n    };\n  }\n  const line = hideLine ? undefined : {\n    stroke: lineStroke,\n    strokeDasharray: lineStrokeDasharray,\n    x1,\n    y1,\n    x2,\n    y2\n  };\n  return {\n    coordinateBase,\n    coordinate,\n    line,\n    orient\n  };\n};\nexport const drawOnCanvas = (ctx, props) => {\n  const {\n    coordinate,\n    fitToText,\n    fontSize,\n    fontFamily,\n    rectWidth\n  } = props;\n  ctx.font = `${fontSize}px ${fontFamily}`;\n  ctx.textBaseline = \"middle\";\n  let width = rectWidth;\n  if (fitToText) {\n    width = Math.round(ctx.measureText(coordinate).width + 10);\n  }\n  const edge = helper(Object.assign(Object.assign({}, props), {\n    rectWidth: width\n  }));\n  if (edge === null) {\n    return;\n  }\n  if (edge.line !== undefined && isDefined(edge.line)) {\n    const dashArray = getStrokeDasharrayCanvas(edge.line.strokeDasharray);\n    ctx.setLineDash(dashArray);\n    ctx.strokeStyle = edge.line.stroke;\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(edge.line.x1, edge.line.y1);\n    ctx.lineTo(edge.line.x2, edge.line.y2);\n    ctx.stroke();\n  }\n  ctx.setLineDash([]);\n  if (edge.coordinateBase !== undefined) {\n    const {\n      arrowWidth,\n      rectWidth,\n      rectHeight,\n      rectRadius\n    } = edge.coordinateBase;\n    ctx.fillStyle = edge.coordinateBase.fill;\n    if (edge.coordinateBase.stroke !== undefined) {\n      ctx.strokeStyle = edge.coordinateBase.stroke;\n      ctx.lineWidth = edge.coordinateBase.strokeWidth;\n    }\n    let x = edge.coordinateBase.edgeXRect;\n    const y = edge.coordinateBase.edgeYRect;\n    const halfHeight = rectHeight / 2;\n    ctx.beginPath();\n    if (arrowWidth > 0 && edge.orient === \"right\") {\n      x -= arrowWidth;\n      ctx.moveTo(x, y + halfHeight);\n      ctx.lineTo(x + arrowWidth, y);\n      ctx.lineTo(x + rectWidth + arrowWidth, y);\n      ctx.lineTo(x + rectWidth + arrowWidth, y + rectHeight);\n      ctx.lineTo(x + arrowWidth, y + rectHeight);\n      ctx.closePath();\n    } else if (arrowWidth > 0 && edge.orient === \"left\") {\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + rectWidth, y);\n      ctx.lineTo(x + rectWidth + arrowWidth, y + halfHeight);\n      ctx.lineTo(x + rectWidth, y + rectHeight);\n      ctx.lineTo(x, y + rectHeight);\n      ctx.closePath();\n    } else if (rectRadius) {\n      roundRect(ctx, x - 0.5, y - 0.5, rectWidth, rectHeight, 3);\n    } else {\n      ctx.rect(x - 0.5, y, rectWidth, rectHeight);\n    }\n    ctx.fill();\n    if (edge.coordinateBase.stroke !== undefined) {\n      ctx.stroke();\n    }\n    if (edge.coordinate !== undefined) {\n      ctx.fillStyle = edge.coordinate.textFill;\n      ctx.textAlign = edge.coordinate.textAnchor === \"middle\" ? \"center\" : edge.coordinate.textAnchor;\n      ctx.fillText(edge.coordinate.displayCoordinate, edge.coordinate.edgeXText, edge.coordinate.edgeYText);\n    }\n  }\n};\nconst roundRect = (ctx, x, y, width, height, radius) => {\n  ctx.beginPath();\n  ctx.moveTo(x + radius, y);\n  ctx.lineTo(x + width - radius, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n  ctx.lineTo(x + width, y + height - radius);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n  ctx.lineTo(x + radius, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n  ctx.lineTo(x, y + radius);\n  ctx.quadraticCurveTo(x, y, x + radius, y);\n  ctx.closePath();\n};","map":{"version":3,"names":["React","getStrokeDasharray","getStrokeDasharrayCanvas","isDefined","renderSVG","props","className","edge","helper","line","coordinateBase","coordinate","undefined","createElement","stroke","strokeDasharray","x1","y1","x2","y2","rectWidth","rectHeight","arrowWidth","path","orient","key","transform","edgeXRect","edgeYRect","d","height","width","strokeLinejoin","strokeWidth","fill","x","y","edgeXText","edgeYText","textAnchor","fontFamily","fontSize","dy","textFill","displayCoordinate","show","type","edgeAt","hideLine","lineStrokeDasharray","lineStroke","rectRadius","dx","drawOnCanvas","ctx","fitToText","font","textBaseline","Math","round","measureText","Object","assign","dashArray","setLineDash","strokeStyle","lineWidth","beginPath","moveTo","lineTo","fillStyle","halfHeight","closePath","roundRect","rect","textAlign","fillText","radius","quadraticCurveTo"],"sources":["C:\\Users\\gabby\\trax-x\\node_modules\\@react-financial-charts\\coordinates\\src\\EdgeCoordinateV3.tsx"],"sourcesContent":["import * as React from \"react\";\n\nimport { getStrokeDasharray, getStrokeDasharrayCanvas, isDefined } from \"@react-financial-charts/core\";\n\nexport const renderSVG = (props: any) => {\n    const { className } = props;\n\n    const edge = helper(props);\n    if (edge === null) {\n        return null;\n    }\n\n    let line;\n    let coordinateBase;\n    let coordinate;\n\n    if (edge.line !== undefined) {\n        line = (\n            <line\n                className=\"react-financial-charts-cross-hair\"\n                stroke={edge.line.stroke}\n                strokeDasharray={getStrokeDasharray(edge.line.strokeDasharray)}\n                x1={edge.line.x1}\n                y1={edge.line.y1}\n                x2={edge.line.x2}\n                y2={edge.line.y2}\n            />\n        );\n    }\n    if (edge.coordinate !== undefined && edge.coordinateBase !== undefined) {\n        const { rectWidth, rectHeight, arrowWidth } = edge.coordinateBase;\n\n        const path =\n            edge.orient === \"left\"\n                ? `M0,0L0,${rectHeight}L${rectWidth},${rectHeight}L${rectWidth + arrowWidth},10L${rectWidth},0L0,0L0,0`\n                : `M0,${arrowWidth}L${arrowWidth},${rectHeight}L${rectWidth + arrowWidth},${rectHeight}L${\n                      rectWidth + arrowWidth\n                  },0L${arrowWidth},0L0,${arrowWidth}`;\n\n        coordinateBase =\n            edge.orient === \"left\" || edge.orient === \"right\" ? (\n                <g key={1} transform={`translate(${edge.coordinateBase.edgeXRect},${edge.coordinateBase.edgeYRect})`}>\n                    <path\n                        d={path}\n                        className=\"react-financial-charts-text-background\"\n                        height={rectHeight}\n                        width={rectWidth}\n                        stroke={edge.coordinateBase.stroke}\n                        strokeLinejoin=\"miter\"\n                        strokeWidth={edge.coordinateBase.strokeWidth}\n                        fill={edge.coordinateBase.fill}\n                    />\n                </g>\n            ) : (\n                <rect\n                    key={1}\n                    className=\"react-financial-charts-text-background\"\n                    x={edge.coordinateBase.edgeXRect}\n                    y={edge.coordinateBase.edgeYRect}\n                    height={rectHeight}\n                    width={rectWidth}\n                    fill={edge.coordinateBase.fill}\n                />\n            );\n\n        coordinate = (\n            <text\n                key={2}\n                x={edge.coordinate.edgeXText}\n                y={edge.coordinate.edgeYText}\n                textAnchor={edge.coordinate.textAnchor}\n                fontFamily={edge.coordinate.fontFamily}\n                fontSize={edge.coordinate.fontSize}\n                dy=\".32em\"\n                fill={edge.coordinate.textFill}\n            >\n                {edge.coordinate.displayCoordinate}\n            </text>\n        );\n    }\n    return (\n        <g className={className}>\n            {line}\n            {coordinateBase}\n            {coordinate}\n        </g>\n    );\n};\n\nconst helper = (props: any) => {\n    const {\n        coordinate: displayCoordinate,\n        show,\n        type,\n        orient,\n        edgeAt,\n        hideLine,\n        lineStrokeDasharray,\n        fill,\n        fontFamily,\n        fontSize,\n        textFill,\n        lineStroke,\n        stroke,\n        strokeWidth,\n        arrowWidth,\n        rectWidth,\n        rectHeight,\n        rectRadius,\n        x1,\n        y1,\n        x2,\n        y2,\n        dx,\n    } = props;\n\n    if (!show) {\n        return null;\n    }\n\n    let coordinateBase;\n    let coordinate;\n    if (displayCoordinate !== undefined) {\n        const textAnchor = \"middle\";\n\n        let edgeXRect;\n        let edgeYRect;\n        let edgeXText;\n        let edgeYText;\n\n        if (type === \"horizontal\") {\n            edgeXRect = dx + (orient === \"right\" ? edgeAt + 1 : edgeAt - rectWidth - 1);\n            edgeYRect = y1 - rectHeight / 2 - strokeWidth;\n            edgeXText = dx + (orient === \"right\" ? edgeAt + rectWidth / 2 : edgeAt - rectWidth / 2);\n            edgeYText = y1;\n        } else {\n            const dy = orient === \"bottom\" ? strokeWidth - 1 : -strokeWidth + 1;\n            edgeXRect = x1 - rectWidth / 2;\n            edgeYRect = (orient === \"bottom\" ? edgeAt : edgeAt - rectHeight) + dy;\n            edgeXText = x1;\n            edgeYText = (orient === \"bottom\" ? edgeAt + rectHeight / 2 : edgeAt - rectHeight / 2) + dy;\n        }\n\n        coordinateBase = {\n            edgeXRect,\n            edgeYRect,\n            rectHeight: rectHeight + strokeWidth,\n            rectWidth,\n            rectRadius,\n            fill,\n            arrowWidth,\n            stroke,\n            strokeWidth,\n        };\n        coordinate = {\n            edgeXText,\n            edgeYText,\n            textAnchor,\n            fontFamily,\n            fontSize,\n            textFill,\n            displayCoordinate,\n        };\n    }\n\n    const line = hideLine\n        ? undefined\n        : {\n              stroke: lineStroke,\n              strokeDasharray: lineStrokeDasharray,\n              x1,\n              y1,\n              x2,\n              y2,\n          };\n\n    return {\n        coordinateBase,\n        coordinate,\n        line,\n        orient,\n    };\n};\n\nexport const drawOnCanvas = (ctx: CanvasRenderingContext2D, props: any) => {\n    const { coordinate, fitToText, fontSize, fontFamily, rectWidth } = props;\n\n    ctx.font = `${fontSize}px ${fontFamily}`;\n    ctx.textBaseline = \"middle\";\n\n    let width = rectWidth;\n    if (fitToText) {\n        width = Math.round(ctx.measureText(coordinate).width + 10);\n    }\n\n    const edge = helper({ ...props, rectWidth: width });\n    if (edge === null) {\n        return;\n    }\n\n    if (edge.line !== undefined && isDefined(edge.line)) {\n        const dashArray = getStrokeDasharrayCanvas(edge.line.strokeDasharray);\n        ctx.setLineDash(dashArray);\n        ctx.strokeStyle = edge.line.stroke;\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n        ctx.moveTo(edge.line.x1, edge.line.y1);\n        ctx.lineTo(edge.line.x2, edge.line.y2);\n        ctx.stroke();\n    }\n\n    ctx.setLineDash([]);\n\n    if (edge.coordinateBase !== undefined) {\n        const { arrowWidth, rectWidth, rectHeight, rectRadius } = edge.coordinateBase;\n\n        ctx.fillStyle = edge.coordinateBase.fill;\n        if (edge.coordinateBase.stroke !== undefined) {\n            ctx.strokeStyle = edge.coordinateBase.stroke;\n            ctx.lineWidth = edge.coordinateBase.strokeWidth;\n        }\n\n        let x = edge.coordinateBase.edgeXRect;\n        const y = edge.coordinateBase.edgeYRect;\n        const halfHeight = rectHeight / 2;\n\n        ctx.beginPath();\n\n        if (arrowWidth > 0 && edge.orient === \"right\") {\n            x -= arrowWidth;\n            ctx.moveTo(x, y + halfHeight);\n            ctx.lineTo(x + arrowWidth, y);\n            ctx.lineTo(x + rectWidth + arrowWidth, y);\n            ctx.lineTo(x + rectWidth + arrowWidth, y + rectHeight);\n            ctx.lineTo(x + arrowWidth, y + rectHeight);\n            ctx.closePath();\n        } else if (arrowWidth > 0 && edge.orient === \"left\") {\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + rectWidth, y);\n            ctx.lineTo(x + rectWidth + arrowWidth, y + halfHeight);\n            ctx.lineTo(x + rectWidth, y + rectHeight);\n            ctx.lineTo(x, y + rectHeight);\n            ctx.closePath();\n        } else if (rectRadius) {\n            roundRect(ctx, x - 0.5, y - 0.5, rectWidth, rectHeight, 3);\n        } else {\n            ctx.rect(x - 0.5, y, rectWidth, rectHeight);\n        }\n\n        ctx.fill();\n\n        if (edge.coordinateBase.stroke !== undefined) {\n            ctx.stroke();\n        }\n\n        if (edge.coordinate !== undefined) {\n            ctx.fillStyle = edge.coordinate.textFill;\n            ctx.textAlign =\n                edge.coordinate.textAnchor === \"middle\" ? \"center\" : (edge.coordinate.textAnchor as CanvasTextAlign);\n            ctx.fillText(edge.coordinate.displayCoordinate, edge.coordinate.edgeXText, edge.coordinate.edgeYText);\n        }\n    }\n};\n\nconst roundRect = (\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    radius: number,\n) => {\n    ctx.beginPath();\n    ctx.moveTo(x + radius, y);\n    ctx.lineTo(x + width - radius, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n    ctx.lineTo(x + width, y + height - radius);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    ctx.lineTo(x + radius, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n    ctx.lineTo(x, y + radius);\n    ctx.quadraticCurveTo(x, y, x + radius, y);\n    ctx.closePath();\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}