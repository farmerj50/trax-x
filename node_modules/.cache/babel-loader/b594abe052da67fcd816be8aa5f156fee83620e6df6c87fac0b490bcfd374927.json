{"ast":null,"code":"import { extend, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { PathOption, drawPath, drawRectangle, RectOption, Rect, CircleOption, drawCircle, getSeriesColor } from '../utils/helper';\nimport { measureText, renderTextElement, TextOption } from '../utils/helper';\nimport { DataManager, Query } from '@syncfusion/ej2-data';\n/**\n * Sparkline rendering calculation file\n */\nvar SparklineRenderer = /** @class */function () {\n  /**\n   * Sparkline data calculations.\n   *\n   * @param {Sparkline} sparkline - The Sparkline control.\n   */\n  function SparklineRenderer(sparkline) {\n    this.sparkline = sparkline;\n  }\n  /**\n   * To process the sparkline data.\n   *\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.processData = function () {\n    var data = this.sparkline.dataSource;\n    if (isNullOrUndefined(data) || !data.length) {\n      return;\n    } else if (!isNaN(this.sparkline.dataSource[0]) || this.sparkline.valueType === 'Numeric') {\n      data = this.sparkline.enableRtl ? data.reverse() : data;\n      this.sparkline.sparklineData = data; // extend([], data) as Object[];\n    } else {\n      this['process' + this.sparkline.valueType]();\n    }\n    this.axisCalculation();\n  };\n  SparklineRenderer.prototype.processDataManager = function () {\n    var _this = this;\n    var dataModule;\n    var queryModule;\n    if (this.sparkline.dataSource instanceof DataManager) {\n      dataModule = this.sparkline.dataSource;\n      queryModule = this.sparkline.query instanceof Query ? this.sparkline.query : new Query();\n      var dataManager = dataModule.executeQuery(queryModule);\n      dataManager.then(function (e) {\n        _this.sparkline.setProperties({\n          dataSource: e['result']\n        }, true);\n        _this.sparkline.sparklineData = _this.sparkline.dataSource;\n        _this.sparkline.processSparklineData();\n      });\n    } else {\n      this.sparkline.processSparklineData();\n    }\n  };\n  /**\n   * To process sparkline category data.\n   *\n   * @param {Object[]} data - The data array to process.\n   * @param {string} x - The name of the x-field.\n   * @param {string} y - The name of the y-field.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.processCategory = function (data, x, y) {\n    var _this = this;\n    if (data === void 0) {\n      data = this.sparkline.dataSource;\n    }\n    if (x === void 0) {\n      x = this.sparkline.xName;\n    }\n    if (y === void 0) {\n      y = this.sparkline.yName;\n    }\n    var temp = [];\n    var xValues = [];\n    data.forEach(function (value) {\n      if (xValues.indexOf(value[x]) === -1) {\n        xValues.push(value[x]);\n      }\n      var currentData = {};\n      currentData[_this.sparkline.xName] = xValues.indexOf(value[x]);\n      currentData[_this.sparkline.yName] = value[y];\n      temp.push(currentData);\n    });\n    this.sparkline.sparklineData = temp;\n  };\n  /**\n   * To process sparkline DateTime data.\n   *\n   * @param {Object[]} data - The data array to process.\n   * @param {string} x - The name of the x-field.\n   * @param {string} y - The name of the y-field.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.processDateTime = function (data, x, y) {\n    if (data === void 0) {\n      data = this.sparkline.dataSource;\n    }\n    if (x === void 0) {\n      x = this.sparkline.xName;\n    }\n    if (y === void 0) {\n      y = this.sparkline.yName;\n    }\n    var temp = [];\n    data.forEach(function (value) {\n      var currentData = {};\n      currentData[x] = value[x].getTime();\n      currentData[y] = value[y];\n      temp.push(currentData);\n    });\n    this.sparkline.sparklineData = temp;\n  };\n  /**\n   * To render sparkline series.\n   *\n   * @private\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.renderSeries = function () {\n    var _this = this;\n    var spark = this.sparkline;\n    this.clipId = spark.element.id + '_sparkline_clip_path';\n    this.drawAxis();\n    var argsData = {\n      name: 'seriesRendering',\n      cancel: false,\n      lineWidth: spark.lineWidth,\n      border: spark.border,\n      fill: spark.fill,\n      sparkline: spark\n    };\n    var seriesRenderingSuccess = function (args) {\n      if (!_this.visiblePoints || args.cancel) {\n        return;\n      }\n      if (spark.type !== 'Pie' && spark.type !== 'WinLoss' && spark.rangeBandSettings.length) {\n        var group = _this.sparkline.renderer.createGroup({\n          id: _this.sparkline.element.id + '_sparkline_rangeband_g'\n        });\n        for (var i = 0; i < spark.rangeBandSettings.length; i++) {\n          if (spark.axisSettings.minY <= spark.rangeBandSettings[i].startRange || spark.axisSettings.maxY >= spark.rangeBandSettings[i].endRange) {\n            _this.rangeBand(spark.rangeBandSettings[i], group, i);\n          }\n        }\n        _this.sparkline.svgObject.appendChild(group);\n      }\n      _this['render' + spark.type](_this.visiblePoints, args);\n      _this.renderMarker(_this.visiblePoints);\n      _this.renderLabel(_this.visiblePoints);\n    };\n    seriesRenderingSuccess.bind(this);\n    spark.trigger('seriesRendering', argsData, seriesRenderingSuccess);\n  };\n  /**\n   * To render a range band.\n   *\n   * @param {RangeBandSettingsModel} rangeBandSettings - The settings for the range band.\n   * @param {Element} group - The group element to render the range band.\n   * @param {number} index - The index of the range band.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.rangeBand = function (rangeBandSettings, group, index) {\n    var model = this.sparkline;\n    var height = model.availableSize.height - model.padding.top * 2;\n    var width = model.availableSize.width - model.padding.left * 2;\n    var stValue = rangeBandSettings.startRange;\n    var edValue = rangeBandSettings.endRange;\n    var stHeight = height - height / this.unitY * (stValue - this.min) + model.padding.top;\n    var edHeight = height - height / this.unitY * (edValue - this.min) + model.padding.top;\n    var color = rangeBandSettings.color || this.sparkline.sparkTheme.rangeBandColor;\n    if (edHeight > height + model.padding.top) {\n      edHeight = height + model.padding.top;\n    } else if (edHeight < 0 + model.padding.top) {\n      edHeight = 0 + model.padding.top;\n    }\n    if (stHeight > height + model.padding.top) {\n      stHeight = height + model.padding.top;\n    } else if (stHeight < 0 + model.padding.top) {\n      stHeight = 0 + model.padding.top;\n    }\n    var path = 'M ' + model.padding.left + ' ' + stHeight + ' L ' + (width + model.padding.left) + ' ' + stHeight + ' L ' + (width + model.padding.left) + ' ' + edHeight + ' L ' + model.padding.left + ' ' + edHeight + ' Z ';\n    var pathOption = {\n      'id': model.element.id + '_rangeBand_' + index,\n      'fill': color,\n      'opacity': rangeBandSettings.opacity,\n      'stroke': 'transparent',\n      'stroke-width': model.lineWidth,\n      'd': path,\n      'stroke-dasharray': ''\n    };\n    drawPath(this.sparkline, pathOption, group);\n  };\n  /**\n   * To render line series.\n   *\n   * @param {SparkValues[]} points - The data points for the line series.\n   * @param {ISeriesRenderingEventArgs} args - The rendering event arguments.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.renderLine = function (points, args) {\n    var spark = this.sparkline;\n    var g = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_g',\n      'clip-path': 'url(#' + this.clipId + ')'\n    });\n    var color = this.sparkline.fill;\n    color = this.sparkline.fill === '#00bdae' && this.sparkline.theme === 'Bootstrap4' ? this.sparkline.sparkTheme.axisLineColor : color;\n    var pathOption = new PathOption(spark.element.id + '_sparkline_line', 'transparent', args.lineWidth, color, spark.opacity);\n    var d = '';\n    for (var i = 0, len = points.length; i < len; i++) {\n      if (i === 0) {\n        d = 'M ' + points[0].x + ' ' + points[i].y + ' ';\n      }\n      d += 'L ' + points[i].x + ' ' + points[i].y + ' ';\n    }\n    pathOption.d = d;\n    pathOption['aria-label'] = 'Line series with' + points.length + 'data points';\n    drawPath(this.sparkline, pathOption, g);\n    this.sparkline.svgObject.appendChild(g);\n  };\n  /**\n   * To render pie series.\n   *\n   * @param {SparkValues[]} points - The data points for the pie series.\n   * @param {ISeriesRenderingEventArgs} args - The rendering event arguments.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.renderPie = function (points, args) {\n    var spark = this.sparkline;\n    var height = spark.availableSize.height - (spark.padding.top + spark.padding.bottom);\n    var width = spark.availableSize.width - (spark.padding.left + spark.padding.right);\n    var area = height <= width ? height / 2 : width / 2;\n    var X = spark.availableSize.width / 2; // center position of x\n    var Y = spark.availableSize.height / 2; // center position of y\n    var deg = 0;\n    var stRad;\n    var edRad;\n    var stroke = args.border.color;\n    var opacity = spark.opacity;\n    var strokeWidth = args.border.width;\n    var colors = spark.palette.length ? spark.palette : getSeriesColor(this.sparkline.theme);\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_g'\n    });\n    var low;\n    var high;\n    var locations = extend([], [], points);\n    if (spark.highPointColor || spark.lowPointColor) {\n      var pointsYvalues = locations.map(function (a) {\n        return a.yVal;\n      });\n      low = Math.min.apply(null, pointsYvalues);\n      high = Math.max.apply(null, pointsYvalues);\n    }\n    this.negativePointIndexes = [];\n    for (var i = 0, stDeg = 90, edDeg = void 0, flag = void 0; i < points.length; i++) {\n      stDeg += deg;\n      deg = points[i]['degree'];\n      deg = deg === 360 ? deg - 0.001 : deg;\n      edDeg = stDeg + deg;\n      stRad = (stDeg - 90) * Math.PI / 180.0;\n      edRad = (edDeg - 90) * Math.PI / 180.0;\n      points[i]['stAng'] = stRad;\n      points[i]['endAng'] = edRad;\n      flag = deg < 180 ? '0' : '1';\n      var temp = points[i]['coordinates'] = {\n        sX: X + area * Math.cos(stRad),\n        sY: Y + area * Math.sin(stRad),\n        eX: X + area * Math.cos(edRad),\n        eY: Y + area * Math.sin(edRad)\n      };\n      var pathArc = 'M ' + X + ' ' + Y + ' L ' + temp['eX'] + ' ' + temp['eY'] + ' A ' + area + ' ' + area + ' 0 ' + flag + ',0 ' + temp['sX'] + ' ' + temp['sY'] + ' Z';\n      var pathOption = {\n        'id': spark.element.id + '_sparkline_pie_' + i,\n        'opacity': opacity,\n        'fill': colors[i % colors.length],\n        'stroke': stroke,\n        'stroke-width': strokeWidth,\n        'd': pathArc,\n        'stroke-dasharray': ''\n      };\n      this.getPieSpecialPoint(points[i], spark, pathOption, i, high, low, points.length);\n      var pointArgs = this.triggerPointRender('pointRendering', i, pathOption.fill, {\n        color: stroke,\n        width: strokeWidth\n      });\n      pathOption.fill = pointArgs.fill;\n      pathOption.stroke = pointArgs.border.color;\n      pathOption['stroke-width'] = pointArgs.border.width;\n      if (!pointArgs.cancel) {\n        var element = drawPath(this.sparkline, pathOption, group);\n        element.setAttribute('role', 'img');\n        element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n        element.setAttribute('tabindex', i === 0 ? '0' : '-1');\n      }\n      var diffRadian = edRad - stRad;\n      var mid = {\n        x: X + area / 2 * Math.cos(stRad + diffRadian / 2),\n        y: Y + area / 2 * Math.sin(stRad + diffRadian / 2)\n      };\n      points[i].location.x = mid.x;\n      points[i].location.y = mid.y;\n    }\n    this.sparkline.svgObject.appendChild(group);\n  };\n  /**\n   * To get special point color and option for Pie series.\n   *\n   * @param {SparkValues} temp - The data point for the special point.\n   * @param {Sparkline} spark - The sparkline instance.\n   * @param {PathOption} option - The option for the special point.\n   * @param {number} i - The index of the special point.\n   * @param {number} high - The high value.\n   * @param {number} low - The low value.\n   * @param {number} length - The total number of data points.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.getPieSpecialPoint = function (temp, spark, option, i, high, low, length) {\n    if (temp.yVal < 0 && spark.negativePointColor) {\n      option.fill = spark.negativePointColor;\n      this.negativePointIndexes.push(i);\n    }\n    if (i === 0 && spark.startPointColor) {\n      option.fill = spark.startPointColor;\n      this.startPointIndex = i;\n    } else if (i === length - 1 && spark.endPointColor) {\n      option.fill = spark.endPointColor;\n      this.endPointIndex = i;\n    }\n    if (temp.yVal === high && spark.highPointColor) {\n      option.fill = spark.highPointColor;\n      this.highPointIndex = i;\n    } else if (temp.yVal === low && spark.lowPointColor) {\n      option.fill = spark.lowPointColor;\n      this.lowPointIndex = i;\n    }\n  };\n  /**\n   * To render area series.\n   *\n   * @param {SparkValues[]} points - The data points for the area series.\n   * @param {ISeriesRenderingEventArgs} args - The rendering event arguments.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.renderArea = function (points, args) {\n    var spark = this.sparkline;\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_g',\n      'clip-path': 'url(#' + this.clipId + ')'\n    });\n    var pathOption = new PathOption(spark.element.id + '_sparkline_area', args.fill, 0, 'transparent', spark.opacity);\n    var d = '';\n    var str = '';\n    for (var i = 0, len = points.length; i < len; i++) {\n      if (i !== 0) {\n        str += 'L ' + points[i].x + ' ' + points[i].y + ' ';\n      } else {\n        d = 'M ' + points[i].x + ' ' + this.axisHeight + ' ';\n        str = 'M ' + points[i].x + ' ' + points[i].y + ' ';\n      }\n      d += 'L ' + points[i].x + ' ' + points[i].y + ' ';\n      if (i === len - 1) {\n        d += 'L ' + points[i].x + ' ' + this.axisHeight + ' Z';\n      }\n    }\n    pathOption.d = d;\n    pathOption['aria-label'] = 'Area series with' + points.length + 'data points';\n    drawPath(this.sparkline, pathOption, group);\n    pathOption = new PathOption(spark.element.id + '_sparkline_area_str', 'transparent', args.border.width, args.border.color, spark.opacity, '', str);\n    drawPath(this.sparkline, pathOption, group);\n    this.sparkline.svgObject.appendChild(group);\n  };\n  /**\n   * To render column series.\n   *\n   * @param {SparkValues[]} points - The data points for the column series.\n   * @param {ISeriesRenderingEventArgs} args - The rendering event arguments.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.renderColumn = function (points, args) {\n    var _this = this;\n    var spark = this.sparkline;\n    var locations = extend([], [], points);\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_g',\n      'clip-path': 'url(#' + this.clipId + ')'\n    });\n    var lowPos;\n    var highPos;\n    if (this.sparkline.highPointColor || this.sparkline.lowPointColor) {\n      var pointsYPos = locations.map(function (a) {\n        return a.markerPosition;\n      });\n      highPos = Math.min.apply(null, pointsYPos);\n      lowPos = Math.max.apply(null, pointsYPos);\n    }\n    var id = spark.element.id + '_sparkline_column_';\n    var rectOptions = new RectOption(id, '', args.border, spark.opacity, null);\n    var temp;\n    var len = points.length;\n    this.negativePointIndexes = [];\n    var colors = spark.palette.length ? spark.palette : getSeriesColor(this.sparkline.theme);\n    var _loop_1 = function (i) {\n      temp = points[i];\n      rectOptions.id = id + i;\n      rectOptions.fill = spark.fill !== '#00bdae' ? spark.fill : colors[0];\n      rectOptions.rect = new Rect(temp.x, temp.y, temp.width, temp.height);\n      this_1.getSpecialPoint(true, temp, spark, rectOptions, i, highPos, lowPos, len);\n      temp.location.y = temp.markerPosition <= this_1.axisHeight ? temp.y : temp.y + temp.height;\n      temp.location.x = temp.x + temp.width / 2;\n      rectOptions.stroke = args.border.color ? args.border.color : rectOptions.fill;\n      var pointArgs = {\n        name: 'pointRendering',\n        cancel: false,\n        pointIndex: i,\n        fill: rectOptions.fill,\n        border: {\n          color: rectOptions.stroke,\n          width: args.border.width\n        }\n      };\n      this_1.sparkline.trigger('pointRendering', pointArgs, function () {\n        temp = points[i];\n        rectOptions.id = id + i;\n        rectOptions.rect = new Rect(temp.x, temp.y, temp.width, temp.height);\n        _this.getSpecialPoint(true, temp, spark, rectOptions, i, highPos, lowPos, len);\n        rectOptions.fill = pointArgs.fill;\n        rectOptions.stroke = pointArgs.border.color;\n        temp.location.y = temp.markerPosition <= _this.axisHeight ? temp.y : temp.y + temp.height;\n        rectOptions['stroke-width'] = pointArgs.border.width;\n        temp.location.x = temp.x + temp.width / 2;\n        if (!pointArgs.cancel) {\n          var element = drawRectangle(spark, rectOptions, group);\n          element.setAttribute('role', 'img');\n          element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n          element.setAttribute('tabindex', i === 0 ? '0' : '-1');\n          group.appendChild(element);\n        }\n      });\n    };\n    var this_1 = this;\n    for (var i = 0; i < len; i++) {\n      _loop_1(i);\n    }\n    this.sparkline.svgObject.appendChild(group);\n  };\n  /**\n   * To render WinLoss series.\n   *\n   * @param {SparkValues[]} points - The data points for the winloss series.\n   * @param {ISeriesRenderingEventArgs} args - The rendering event arguments.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.renderWinLoss = function (points, args) {\n    var spark = this.sparkline;\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_g',\n      'clip-path': 'url(#' + this.clipId + ')'\n    });\n    var id = spark.element.id + '_sparkline_winloss_';\n    var options = new RectOption(id, '', args.border, spark.opacity, null);\n    var temp;\n    var len = points.length;\n    var paletteLength = spark.palette.length;\n    var colors = spark.palette.length ? spark.palette : getSeriesColor(this.sparkline.theme);\n    for (var i = 0; i < len; i++) {\n      temp = points[i];\n      options.id = id + i;\n      options.fill = paletteLength ? spark.palette[i % paletteLength] : temp.yVal === this.axisValue ? this.sparkline.tiePointColor || '#a216f3' : temp.yVal > this.axisValue ? args.fill || colors[i % colors.length] : spark.negativePointColor || '#e20f07';\n      options.stroke = args.border.color ? args.border.color : options.fill;\n      options.rect = new Rect(temp.x, temp.y, temp.width, temp.height);\n      temp.location.x = temp.x + temp.width / 2;\n      temp.location.y = temp.yVal >= this.axisValue ? temp.y : temp.y + temp.height;\n      var pointArgs = this.triggerPointRender('pointRendering', i, options.fill, {\n        color: options.stroke,\n        width: args.border.width\n      });\n      options.fill = pointArgs.fill;\n      options.stroke = pointArgs.border.color;\n      options['stroke-width'] = pointArgs.border.width;\n      if (!pointArgs.cancel) {\n        var element = drawRectangle(spark, options, group);\n        element.setAttribute('role', 'img');\n        element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n        element.setAttribute('tabindex', i === 0 ? '0' : '-1');\n      }\n    }\n    this.sparkline.svgObject.appendChild(group);\n  };\n  SparklineRenderer.prototype.renderMarker = function (points) {\n    var _this = this;\n    var spark = this.sparkline;\n    var marker = spark.markerSettings;\n    if (spark.type === 'Pie' || spark.type === 'WinLoss' || !marker.visible.length) {\n      return;\n    }\n    var locations = extend([], [], points);\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_marker_g',\n      'clip-path': 'url(#' + this.clipId + ')'\n    });\n    var temp;\n    var id = spark.element.id + '_sparkline_marker_';\n    var option = new CircleOption('', marker.fill, marker.border, marker.opacity, 0, 0, marker.size / 2, '');\n    var highPos;\n    var lowPos;\n    var visible = marker.visible.join();\n    if (visible.toLowerCase().indexOf('high') > -1 || visible.toLowerCase().indexOf('low') > -1) {\n      var pointsYPos = locations.map(function (a) {\n        return a.markerPosition;\n      });\n      highPos = Math.min.apply(null, pointsYPos);\n      lowPos = Math.max.apply(null, pointsYPos);\n    }\n    this.negativePointIndexes = [];\n    var _loop_2 = function (i, length_1) {\n      temp = points[i];\n      option.id = id + i;\n      option.cx = temp.location.x;\n      option.cy = temp.location.y;\n      option.fill = marker.fill;\n      var render = visible.toLowerCase().indexOf('all') > -1;\n      render = this_2.getSpecialPoint(render, temp, spark, option, i, highPos, lowPos, length_1, visible.toLowerCase());\n      option.stroke = marker.border.color || option.fill;\n      var markerArgs = {\n        name: 'markerRendering',\n        cancel: false,\n        border: {\n          color: option.stroke,\n          width: marker.border.width\n        },\n        fill: option.fill,\n        pointIndex: i,\n        sparkline: this_2.sparkline,\n        x: option.cx,\n        y: option.cy,\n        size: marker.size\n      };\n      this_2.sparkline.trigger('markerRendering', markerArgs, function () {\n        if (render && !markerArgs.cancel) {\n          option.id = id + i;\n          option.cx = markerArgs.x;\n          option.cy = markerArgs.y;\n          option.fill = markerArgs.fill;\n          option.stroke = markerArgs.border.color;\n          option['stroke-width'] = markerArgs.border.width;\n          option.r = markerArgs.size / 2;\n          var element = drawCircle(spark, option, group);\n          element.setAttribute('role', 'img');\n          element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n          if (_this.sparkline.type.indexOf('Line') > -1 || _this.sparkline.type.indexOf('Area') > -1) {\n            element.setAttribute('tabindex', i === 0 ? '0' : '-1');\n          }\n          group.appendChild(element);\n        }\n      });\n    };\n    var this_2 = this;\n    for (var i = 0, length_1 = points.length; i < length_1; i++) {\n      _loop_2(i, length_1);\n    }\n    this.sparkline.svgObject.appendChild(group);\n  };\n  /**\n   * To get special point color and option.\n   *\n   * @param {boolean} render - Indicates whether to render the special point.\n   * @param {SparkValues} temp - The data point for the special point.\n   * @param {Sparkline} spark - The sparkline instance.\n   * @param {PathOption} option - The option for the special point.\n   * @param {number} i - The index of the special point.\n   * @param {number} highPos - The position of the high value.\n   * @param {number} lowPos - The position of the low value.\n   * @param {number} length - The total number of data points.\n   * @param {string} visible - The visibility state of the special point.\n   * @returns {boolean} - Indicates whether the special point is rendered.\n   */\n  SparklineRenderer.prototype.getSpecialPoint = function (render, temp, spark, option, i, highPos, lowPos, length, visible) {\n    if (visible === void 0) {\n      visible = '';\n    }\n    if (temp.markerPosition > this.axisHeight) {\n      option.fill = spark.negativePointColor || option.fill;\n      this.negativePointIndexes.push(i);\n      render = render || visible.indexOf('negative') > -1;\n    }\n    if (i === 0) {\n      option.fill = spark.startPointColor || option.fill;\n      this.startPointIndex = i;\n      render = render || visible.indexOf('start') > -1;\n    } else if (i === length - 1) {\n      option.fill = spark.endPointColor || option.fill;\n      this.endPointIndex = i;\n      render = render || visible.indexOf('end') > -1;\n    }\n    if (temp.markerPosition === highPos) {\n      option.fill = spark.highPointColor || option.fill;\n      this.highPointIndex = i;\n      render = render || visible.indexOf('high') > -1;\n    } else if (temp.markerPosition === lowPos) {\n      option.fill = spark.lowPointColor || option.fill;\n      this.lowPointIndex = i;\n      render = render || visible.indexOf('low') > -1;\n    }\n    if (visible.indexOf('none') > -1) {\n      render = false;\n    }\n    return render;\n  };\n  /**\n   * To render data label for sparkline.\n   *\n   * @param {SparkValues[]} points - The data points for the series datalabels.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.renderLabel = function (points) {\n    var _this = this;\n    var spark = this.sparkline;\n    var dataLabel = spark.dataLabelSettings;\n    var color = dataLabel.textStyle.color || spark.sparkTheme.dataLabelColor;\n    if (spark.type === 'WinLoss' || !dataLabel.visible.length) {\n      return;\n    }\n    var locations = extend([], [], points);\n    var id = spark.element.id + '_sparkline_label_';\n    var group = this.sparkline.renderer.createGroup({\n      id: spark.element.id + '_sparkline_label_g',\n      style: 'pointer-events: none;'\n    });\n    group.setAttribute('aria-hidden', 'true');\n    var g;\n    var temp;\n    var textId = id + 'text_';\n    var rectId = id + 'rect_';\n    var option = new TextOption('', 0, 0, 'middle', '', 'middle');\n    var labelStyle = dataLabel.textStyle;\n    var pointsYPos = locations.map(function (a) {\n      return a.markerPosition;\n    });\n    var highPos = Math.min.apply(null, pointsYPos);\n    var lowPos = Math.max.apply(null, pointsYPos);\n    var space = 1;\n    var padding = dataLabel.fill !== 'transparent' || dataLabel.border.width ? 2 : 0;\n    var size = measureText('sparkline_measure_text', labelStyle, this.sparkline.sparkTheme.dataLabelFont);\n    var rectOptions = new RectOption('', dataLabel.fill, dataLabel.border, dataLabel.opacity, null);\n    var edgeLabelOption;\n    var _loop_3 = function (i, length_2) {\n      temp = points[i];\n      option.id = textId + i;\n      option.x = temp.location.x + dataLabel.offset.x;\n      option.y = (spark.type === 'Pie' ? temp.location.y : temp.markerPosition > this_3.axisHeight ? temp.location.y + size.height / 2 + space + 2 + padding : temp.location.y - size.height / 2 - space - padding) + dataLabel.offset.y;\n      option.text = dataLabel.format !== '' ? this_3.formatter(dataLabel.format, this_3.sparkline.dataSource[i]) : temp.yVal.toString();\n      var labelArgs = {\n        name: 'dataLabelRendering',\n        cancel: false,\n        border: dataLabel.border,\n        fill: dataLabel.fill,\n        pointIndex: i,\n        sparkline: this_3.sparkline,\n        x: option.x,\n        y: option.y,\n        text: option.text,\n        color: color\n      };\n      this_3.sparkline.trigger('dataLabelRendering', labelArgs, function () {\n        size = measureText(labelArgs.text, labelStyle, _this.sparkline.sparkTheme.dataLabelFont);\n        option.text = labelArgs.text;\n        var renderLabel = dataLabel.visible.join().toLowerCase().indexOf('all') > -1;\n        renderLabel = _this.getLabelVisible(renderLabel, temp, i, dataLabel, length_2, highPos, lowPos);\n        edgeLabelOption = _this.arrangeLabelPosition(dataLabel.edgeLabelMode, renderLabel, labelArgs.x, i, length_2, size, padding);\n        if (renderLabel && !labelArgs.cancel && edgeLabelOption.render) {\n          rectOptions.id = rectId + i;\n          rectOptions.fill = labelArgs.fill;\n          rectOptions.stroke = labelArgs.border.color;\n          rectOptions['stroke-width'] = labelArgs.border.width;\n          option.y = labelArgs.y;\n          option.x = edgeLabelOption.x;\n          rectOptions.rect = new Rect(option.x - (size.width / 2 + padding), option.y - padding - size.height / 1.75, size.width + padding * 2, size.height + padding * 2);\n          g = _this.sparkline.renderer.createGroup({\n            id: id + 'g' + i\n          });\n          drawRectangle(spark, rectOptions, g);\n          renderTextElement(option, labelStyle, labelArgs.color, g, _this.sparkline.sparkTheme.dataLabelFont);\n          group.appendChild(g);\n        }\n      });\n    };\n    var this_3 = this;\n    for (var i = 0, length_2 = points.length; i < length_2; i++) {\n      _loop_3(i, length_2);\n    }\n    this.sparkline.svgObject.appendChild(group);\n  };\n  SparklineRenderer.prototype.arrangeLabelPosition = function (edgeLabel, render, x, index, length, size, padding) {\n    if (edgeLabel === 'None') {\n      return {\n        x: x,\n        render: render\n      };\n    }\n    if (index === 0 && x - size.width / 2 - padding <= 0) {\n      if (edgeLabel === 'Hide') {\n        render = false;\n      } else {\n        x = this.sparkline.padding.left + padding + size.width / 2;\n      }\n    } else if (index === length - 1 && x + size.width / 2 + padding >= this.sparkline.availableSize.width) {\n      if (edgeLabel === 'Hide') {\n        render = false;\n      } else {\n        x -= size.width / 2 + padding;\n      }\n    }\n    return {\n      x: x,\n      render: render\n    };\n  };\n  /**\n   * To get special point color and option.\n   *\n   * @param {boolean} render - Indicates whether to render the special point.\n   * @param {SparkValues} temp - The data point for the special point.\n   * @param {number} i - The index of the sparkline instance.\n   * @param {SparklineDataLabelSettingsModel} label - The options for the special point.\n   * @param {number} length - The total number of data points.\n   * @param {number} highPos - The position of the high value.\n   * @param {number} lowPos - The position of the low value.\n   * @returns {boolean} - Indicates whether the special point is rendered.\n   */\n  SparklineRenderer.prototype.getLabelVisible = function (render, temp, i, label, length, highPos, lowPos) {\n    var labelVisible = label.visible.join().toLowerCase();\n    if (temp.markerPosition > this.axisHeight) {\n      render = render || labelVisible.indexOf('negative') > -1;\n    }\n    if (i === 0) {\n      render = render || labelVisible.indexOf('start') > -1;\n    } else if (i === length - 1) {\n      render = render || labelVisible.indexOf('end') > -1;\n    }\n    if (temp.markerPosition === highPos) {\n      render = render || labelVisible.indexOf('high') > -1;\n    } else if (temp.markerPosition === lowPos) {\n      render = render || labelVisible.indexOf('low') > -1;\n    }\n    if (label.visible.join().toLowerCase().indexOf('none') > -1) {\n      render = false;\n    }\n    return render;\n  };\n  /**\n   * To format text.\n   *\n   * @param {string} format - The format string to apply.\n   * @param {object} data - The data object to format.\n   * @returns {string} - The formatted text.\n   */\n  SparklineRenderer.prototype.formatter = function (format, data) {\n    if (isNullOrUndefined(format)) {\n      return null;\n    }\n    var keys = Object.keys(data);\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var key = keys_1[_i];\n      format = format.split('${' + key + '}').join(data[key]);\n    }\n    return format;\n  };\n  /**\n   * To calculate min and max for x and y axis.\n   *\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.axisCalculation = function () {\n    this.findRanges(this.sparkline.sparklineData);\n  };\n  /**\n   * To find x axis interval.\n   *\n   * @param {Object[]} data - The data points.\n   * @param {string} x - The x-axis field name.\n   * @returns {number} - The calculated interval.\n   */\n  SparklineRenderer.prototype.getInterval = function (data, x) {\n    var interval = 1;\n    var x1 = data[0][x];\n    var x2 = isNullOrUndefined(data[1]) ? undefined : data[1][x];\n    if (!isNullOrUndefined(x1) && !isNullOrUndefined(x2)) {\n      var temp = extend([], data);\n      var validData_1 = [];\n      temp.forEach(function (value) {\n        if (!isNullOrUndefined(value[x])) {\n          validData_1.push(value);\n        }\n      });\n      validData_1.sort(function (a, b) {\n        if (isNullOrUndefined(a[x]) || isNullOrUndefined(b[x])) {\n          return 0;\n        }\n        return a[x] - b[x];\n      });\n      validData_1 = this.sparkline.enableRtl ? validData_1.reverse() : validData_1;\n      interval = validData_1[1][x] - validData_1[0][x];\n    }\n    return interval;\n  };\n  /**\n   * To find x axis interval for padding.\n   *\n   * @param {Object[]} data - The data points.\n   * @param {string} x - The x-axis field name.\n   * @param {SparklineValueType} type - The type of sparkline value.\n   * @param {number} delta - The delta values.\n   * @returns {number} - The calculated x-axis interval for padding.\n   */\n  SparklineRenderer.prototype.getPaddingInterval = function (data, x, type, delta) {\n    var interval = 1;\n    var size = this.sparkline.availableSize.height;\n    var intervalCount = interval * data.length;\n    intervalCount = Math.max(size * (intervalCount / 100), 1);\n    var niceInterval = delta / intervalCount;\n    for (var _i = 0, _a = this.sparkline.intervalDivs; _i < _a.length; _i++) {\n      var intervalVal = _a[_i];\n      var currentInterval = interval * intervalVal;\n      if (intervalCount < delta / currentInterval) {\n        break;\n      }\n      niceInterval = currentInterval;\n    }\n    return niceInterval;\n  };\n  /**\n   * To calculate axis ranges internally.\n   *\n   * @param {Object[]} data - The data points.\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.findRanges = function (data) {\n    var model = this.sparkline;\n    var max;\n    var min;\n    var minX;\n    var maxX;\n    var maxPointsLength = data.length;\n    var temp;\n    var sumofValues = 0;\n    var isNumericArray = Array.isArray(data) && typeof data[0] !== 'object';\n    if (isNumericArray) {\n      if (model.type === 'Pie') {\n        for (var i = 0; i < maxPointsLength; i++) {\n          sumofValues += Math.abs(data[i]);\n        }\n      } else {\n        max = Math.max.apply(null, data);\n        min = Math.min.apply(null, data);\n        minX = 0;\n        maxX = maxPointsLength - 1;\n      }\n    } else {\n      if (model.type === 'Pie') {\n        for (var i = 0; i < maxPointsLength; i++) {\n          sumofValues += Math.abs(data[i][model.yName]);\n        }\n      } else {\n        if (isNullOrUndefined(data[0][model.xName])) {\n          var x_1 = data.map(function (z) {\n            return z[model.yName];\n          });\n          max = Math.max.apply(null, x_1);\n          min = Math.min.apply(null, x_1);\n        } else {\n          temp = extend([], data);\n          temp = temp.sort(function (a, b) {\n            return a[model.yName] - b[model.yName];\n          });\n          max = temp[temp.length - 1][model.yName];\n          min = temp[0][model.yName];\n        }\n        if (!isNullOrUndefined(data[0][model.xName])) {\n          temp = temp.sort(function (a, b) {\n            return a[model.xName] - b[model.xName];\n          });\n          temp = this.sparkline.enableRtl ? temp.reverse() : temp;\n          maxX = temp[temp.length - 1][model.xName];\n          minX = temp[0][model.xName];\n        } else {\n          minX = 0;\n          maxX = maxPointsLength - 1;\n        }\n      }\n    }\n    var y2;\n    var height;\n    var width;\n    var x1 = 0;\n    var y1;\n    var padding = model.padding;\n    var point;\n    var axis = model.axisSettings;\n    var value = axis.value;\n    if (model.type !== 'Pie') {\n      this.maxLength = maxPointsLength;\n      height = model.availableSize.height - (padding.bottom + padding.top);\n      width = model.availableSize.width - (padding.left + padding.right);\n      maxX = isNullOrUndefined(axis.maxX) ? maxX : axis.maxX;\n      minX = isNullOrUndefined(axis.minX) ? minX : axis.minX;\n      max = isNullOrUndefined(axis.maxY) ? max : axis.maxY;\n      min = isNullOrUndefined(axis.minY) ? min : axis.minY;\n      var color = axis.lineSettings.color || this.sparkline.sparkTheme.axisLineColor;\n      var eventArgs = {\n        name: 'axisRendering',\n        cancel: false,\n        sparkline: model,\n        maxX: maxX,\n        minX: minX,\n        maxY: max,\n        minY: min,\n        value: axis.value,\n        lineColor: color,\n        lineWidth: axis.lineSettings.width\n      };\n      model.trigger('axisRendering', eventArgs);\n      if (eventArgs.cancel) {\n        this.visiblePoints = [];\n        return;\n      }\n      maxX = eventArgs.maxX;\n      minX = eventArgs.minX;\n      max = eventArgs.maxY;\n      min = eventArgs.minY;\n      value = this.axisValue = eventArgs.value;\n      this.axisColor = eventArgs.lineColor;\n      this.axisWidth = eventArgs.lineWidth;\n    }\n    var unitX = maxX - minX;\n    var unitY = max - min;\n    unitX = unitX === 0 ? 1 : unitX;\n    unitY = unitY === 0 ? 1 : unitY;\n    this.unitX = unitX;\n    this.unitY = unitY;\n    this.min = min;\n    x1 = 0;\n    y1 = height - height / unitY * -min;\n    y1 = min < 0 && max <= 0 ? 0 : min < 0 && max > 0 ? y1 : height;\n    if (value >= min && value <= max) {\n      y1 = height - Math.round(height * ((value - min) / this.unitY));\n    }\n    this.axisHeight = y1 + padding.top;\n    var percent;\n    var x;\n    var y;\n    var visiblePoints = [];\n    var delta = max - min;\n    var interval = this.getInterval(data, model.xName);\n    var interVal = this.getPaddingInterval(data, model.xName, model.valueType, delta);\n    for (var i = 0; i < maxPointsLength; i++) {\n      if (isNullOrUndefined(data[i][model.xName]) && isNullOrUndefined(data[i][model.yName]) && data[i][model.yName] !== 0 && isNumericArray) {\n        x = i;\n        y = data[i];\n      } else if (isNullOrUndefined(data[i][model.xName])) {\n        x = i;\n        y = data[i][model.yName];\n      } else {\n        x = data[i][model.xName];\n        y = data[i][model.yName];\n      }\n      if (isNullOrUndefined(x) || isNullOrUndefined(y)) {\n        continue;\n      }\n      if (model.type === 'Line' || model.type === 'Area') {\n        y2 = min !== max && maxPointsLength !== 1 ? height - Math.round(height * ((y - min) / this.unitY)) : padding.top;\n        point = {\n          x: minX !== maxX ? Math.round(width * ((x - minX) / this.unitX)) : width / 2,\n          y: y2,\n          markerPosition: y2\n        };\n      } else if (model.type === 'Column' || model.type === 'WinLoss') {\n        var colWidth = width / ((maxX - minX) / interval + 1);\n        var calSpace = 0.5;\n        var space = calSpace * 2; //calspace is default space for column and winloss\n        colWidth -= space;\n        x1 = (x - minX) / interval * (colWidth + space) + space / 2;\n        if (model.type === 'WinLoss') {\n          // win or gain column height half of the height , draw(zero) height factor\n          var winLossFactor = 0.5;\n          var drawHeightFactor = 40;\n          y2 = y > value ? height / 4 : y < value ? height * winLossFactor : height * winLossFactor - height / drawHeightFactor;\n          point = {\n            x: x1,\n            y: y2,\n            height: y !== value ? height / 4 : height / 20,\n            width: colWidth,\n            markerPosition: y2 > y1 ? y1 + Math.abs(y2 - y1) : y2\n          };\n        } else {\n          if (i === 0 && model.rangePadding !== 'None') {\n            min -= model.rangePadding === 'Additional' ? interVal + padding.top : interVal;\n            max += model.rangePadding === 'Additional' ? interVal + padding.top : interVal;\n            unitX = maxX - minX;\n            unitY = max - min;\n            unitX = unitX === 0 ? 1 : unitX;\n            unitY = unitY === 0 ? 1 : unitY;\n            this.unitX = unitX;\n            this.unitY = unitY;\n            this.min = min;\n          }\n          var z = height / this.unitY * (y - min);\n          var z1 = y === min && y > value ? maxPointsLength !== 1 && this.unitY !== 1 ? height / this.unitY * (min / 2) : z | 1 : y === max && y < value && maxPointsLength !== 1 && this.unitY !== 1 ? height / this.unitY * (-max / 2) : z;\n          y2 = Math.abs(height - z1);\n          point = {\n            x: x1,\n            y: y2 > y1 ? y1 : y2,\n            height: Math.abs(y2 - y1),\n            width: colWidth,\n            markerPosition: y2 > y1 ? y1 + Math.abs(y2 - y1) : y2\n          };\n        }\n      } else if (model.type === 'Pie') {\n        percent = Math.abs(y) / sumofValues * 100;\n        point = {\n          percent: percent,\n          degree: Math.abs(y) / sumofValues * 360\n        };\n      }\n      if (model.type !== 'Pie') {\n        point.x += padding.left;\n        point.y += padding.top;\n      }\n      if (model.type !== 'WinLoss') {\n        point.markerPosition += padding.top;\n      }\n      point.location = {\n        x: point.x,\n        y: point.y\n      };\n      point.xVal = x;\n      point.yVal = y;\n      visiblePoints.push(point);\n    }\n    visiblePoints.sort(function (a, b) {\n      return a.x - b.x;\n    });\n    this.visiblePoints = visiblePoints;\n  };\n  /**\n   * To render the sparkline axis.\n   *\n   * @returns {void}\n   */\n  SparklineRenderer.prototype.drawAxis = function () {\n    var spark = this.sparkline;\n    var height = this.axisHeight;\n    if (spark.type !== 'WinLoss' && spark.type !== 'Pie' && spark.axisSettings.lineSettings.visible) {\n      var xAxis = {\n        'id': spark.element.id + '_Sparkline_XAxis',\n        'x1': spark.padding.left,\n        'y1': height,\n        'x2': spark.availableSize.width - spark.padding.right,\n        'y2': height,\n        'stroke': this.axisColor,\n        'opacity': spark.axisSettings.lineSettings.opacity,\n        'stroke-dasharray': spark.axisSettings.lineSettings.dashArray,\n        'stroke-width': this.axisWidth,\n        'clip-path': 'url(#' + this.clipId + ')'\n      };\n      spark.svgObject.appendChild(spark.renderer.drawLine(xAxis));\n    }\n  };\n  /**\n   * To trigger point render event.\n   *\n   * @param {string} name - The name of the data point.\n   * @param {number} i - The index of the data point.\n   * @param {string} fill - The fill color of the data point.\n   * @param {SparklineBorderModel} border - The border settings of the data point.\n   * @returns {ISparklinePointEventArgs} - The event arguments for the point render event.\n   */\n  SparklineRenderer.prototype.triggerPointRender = function (name, i, fill, border) {\n    var args = {\n      name: name,\n      cancel: false,\n      border: border,\n      fill: fill,\n      sparkline: this.sparkline,\n      pointIndex: i\n    };\n    this.sparkline.trigger(name, args);\n    return args;\n  };\n  return SparklineRenderer;\n}();\nexport { SparklineRenderer };","map":{"version":3,"names":["extend","isNullOrUndefined","PathOption","drawPath","drawRectangle","RectOption","Rect","CircleOption","drawCircle","getSeriesColor","measureText","renderTextElement","TextOption","DataManager","Query","SparklineRenderer","sparkline","prototype","processData","data","dataSource","length","isNaN","valueType","enableRtl","reverse","sparklineData","axisCalculation","processDataManager","_this","dataModule","queryModule","query","dataManager","executeQuery","then","e","setProperties","processSparklineData","processCategory","x","y","xName","yName","temp","xValues","forEach","value","indexOf","push","currentData","processDateTime","getTime","renderSeries","spark","clipId","element","id","drawAxis","argsData","name","cancel","lineWidth","border","fill","seriesRenderingSuccess","args","visiblePoints","type","rangeBandSettings","group","renderer","createGroup","i","axisSettings","minY","startRange","maxY","endRange","rangeBand","svgObject","appendChild","renderMarker","renderLabel","bind","trigger","index","model","height","availableSize","padding","top","width","left","stValue","edValue","stHeight","unitY","min","edHeight","color","sparkTheme","rangeBandColor","path","pathOption","opacity","renderLine","points","g","theme","axisLineColor","d","len","renderPie","bottom","right","area","X","Y","deg","stRad","edRad","stroke","strokeWidth","colors","palette","low","high","locations","highPointColor","lowPointColor","pointsYvalues","map","a","yVal","Math","apply","max","negativePointIndexes","stDeg","edDeg","flag","PI","sX","cos","sY","sin","eX","eY","pathArc","getPieSpecialPoint","pointArgs","triggerPointRender","setAttribute","diffRadian","mid","location","option","negativePointColor","startPointColor","startPointIndex","endPointColor","endPointIndex","highPointIndex","lowPointIndex","renderArea","str","axisHeight","renderColumn","lowPos","highPos","pointsYPos","markerPosition","rectOptions","_loop_1","rect","this_1","getSpecialPoint","pointIndex","renderWinLoss","options","paletteLength","axisValue","tiePointColor","marker","markerSettings","visible","size","join","toLowerCase","_loop_2","length_1","cx","cy","render","this_2","markerArgs","r","dataLabel","dataLabelSettings","textStyle","dataLabelColor","style","textId","rectId","labelStyle","space","dataLabelFont","edgeLabelOption","_loop_3","length_2","offset","this_3","text","format","formatter","toString","labelArgs","getLabelVisible","arrangeLabelPosition","edgeLabelMode","edgeLabel","label","labelVisible","keys","Object","_i","keys_1","key","split","findRanges","getInterval","interval","x1","x2","undefined","validData_1","sort","b","getPaddingInterval","delta","intervalCount","niceInterval","_a","intervalDivs","intervalVal","currentInterval","minX","maxX","maxPointsLength","sumofValues","isNumericArray","Array","isArray","abs","x_1","z","y2","y1","point","axis","maxLength","lineSettings","eventArgs","lineColor","axisColor","axisWidth","unitX","round","percent","interVal","colWidth","calSpace","winLossFactor","drawHeightFactor","rangePadding","z1","degree","xVal","xAxis","dashArray","drawLine"],"sources":["C:/Users/gabby/trax-x/node_modules/@syncfusion/ej2-charts/src/sparkline/rendering/sparkline-renderer.js"],"sourcesContent":["import { extend, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { PathOption, drawPath, drawRectangle, RectOption, Rect, CircleOption, drawCircle, getSeriesColor } from '../utils/helper';\nimport { measureText, renderTextElement, TextOption } from '../utils/helper';\nimport { DataManager, Query } from '@syncfusion/ej2-data';\n/**\n * Sparkline rendering calculation file\n */\nvar SparklineRenderer = /** @class */ (function () {\n    /**\n     * Sparkline data calculations.\n     *\n     * @param {Sparkline} sparkline - The Sparkline control.\n     */\n    function SparklineRenderer(sparkline) {\n        this.sparkline = sparkline;\n    }\n    /**\n     * To process the sparkline data.\n     *\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.processData = function () {\n        var data = this.sparkline.dataSource;\n        if (isNullOrUndefined(data) || !data.length) {\n            return;\n        }\n        else if (!isNaN(this.sparkline.dataSource[0]) || this.sparkline.valueType === 'Numeric') {\n            data = (this.sparkline.enableRtl) ? data.reverse() : data;\n            this.sparkline.sparklineData = data; // extend([], data) as Object[];\n        }\n        else {\n            this['process' + this.sparkline.valueType]();\n        }\n        this.axisCalculation();\n    };\n    SparklineRenderer.prototype.processDataManager = function () {\n        var _this = this;\n        var dataModule;\n        var queryModule;\n        if (this.sparkline.dataSource instanceof DataManager) {\n            dataModule = this.sparkline.dataSource;\n            queryModule = this.sparkline.query instanceof Query ? this.sparkline.query : new Query();\n            var dataManager = dataModule.executeQuery(queryModule);\n            dataManager.then(function (e) {\n                _this.sparkline.setProperties({ dataSource: e['result'] }, true);\n                _this.sparkline.sparklineData = _this.sparkline.dataSource;\n                _this.sparkline.processSparklineData();\n            });\n        }\n        else {\n            this.sparkline.processSparklineData();\n        }\n    };\n    /**\n     * To process sparkline category data.\n     *\n     * @param {Object[]} data - The data array to process.\n     * @param {string} x - The name of the x-field.\n     * @param {string} y - The name of the y-field.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.processCategory = function (data, x, y) {\n        var _this = this;\n        if (data === void 0) { data = this.sparkline.dataSource; }\n        if (x === void 0) { x = this.sparkline.xName; }\n        if (y === void 0) { y = this.sparkline.yName; }\n        var temp = [];\n        var xValues = [];\n        data.forEach(function (value) {\n            if (xValues.indexOf(value[x]) === -1) {\n                xValues.push(value[x]);\n            }\n            var currentData = {};\n            currentData[_this.sparkline.xName] = xValues.indexOf(value[x]);\n            currentData[_this.sparkline.yName] = value[y];\n            temp.push(currentData);\n        });\n        this.sparkline.sparklineData = temp;\n    };\n    /**\n     * To process sparkline DateTime data.\n     *\n     * @param {Object[]} data - The data array to process.\n     * @param {string} x - The name of the x-field.\n     * @param {string} y - The name of the y-field.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.processDateTime = function (data, x, y) {\n        if (data === void 0) { data = this.sparkline.dataSource; }\n        if (x === void 0) { x = this.sparkline.xName; }\n        if (y === void 0) { y = this.sparkline.yName; }\n        var temp = [];\n        data.forEach(function (value) {\n            var currentData = {};\n            currentData[x] = value[x].getTime();\n            currentData[y] = value[y];\n            temp.push(currentData);\n        });\n        this.sparkline.sparklineData = temp;\n    };\n    /**\n     * To render sparkline series.\n     *\n     * @private\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.renderSeries = function () {\n        var _this = this;\n        var spark = this.sparkline;\n        this.clipId = spark.element.id + '_sparkline_clip_path';\n        this.drawAxis();\n        var argsData = {\n            name: 'seriesRendering',\n            cancel: false,\n            lineWidth: spark.lineWidth,\n            border: spark.border,\n            fill: spark.fill,\n            sparkline: spark\n        };\n        var seriesRenderingSuccess = function (args) {\n            if (!_this.visiblePoints || args.cancel) {\n                return;\n            }\n            if (spark.type !== 'Pie' && spark.type !== 'WinLoss' && spark.rangeBandSettings.length) {\n                var group = _this.sparkline.renderer.createGroup({ id: _this.sparkline.element.id + '_sparkline_rangeband_g' });\n                for (var i = 0; i < spark.rangeBandSettings.length; i++) {\n                    if ((spark.axisSettings.minY <= spark.rangeBandSettings[i].startRange) ||\n                        (spark.axisSettings.maxY >= spark.rangeBandSettings[i].endRange)) {\n                        _this.rangeBand(spark.rangeBandSettings[i], group, i);\n                    }\n                }\n                _this.sparkline.svgObject.appendChild(group);\n            }\n            _this['render' + spark.type](_this.visiblePoints, args);\n            _this.renderMarker(_this.visiblePoints);\n            _this.renderLabel(_this.visiblePoints);\n        };\n        seriesRenderingSuccess.bind(this);\n        spark.trigger('seriesRendering', argsData, seriesRenderingSuccess);\n    };\n    /**\n     * To render a range band.\n     *\n     * @param {RangeBandSettingsModel} rangeBandSettings - The settings for the range band.\n     * @param {Element} group - The group element to render the range band.\n     * @param {number} index - The index of the range band.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.rangeBand = function (rangeBandSettings, group, index) {\n        var model = this.sparkline;\n        var height = (model.availableSize.height) - model.padding.top * 2;\n        var width = (model.availableSize.width) - model.padding.left * 2;\n        var stValue = rangeBandSettings.startRange;\n        var edValue = rangeBandSettings.endRange;\n        var stHeight = (height - ((height / this.unitY) * (stValue - this.min))) + model.padding.top;\n        var edHeight = (height - ((height / this.unitY) * (edValue - this.min))) + model.padding.top;\n        var color = rangeBandSettings.color || this.sparkline.sparkTheme.rangeBandColor;\n        if (edHeight > (height + model.padding.top)) {\n            edHeight = (height + model.padding.top);\n        }\n        else if (edHeight < (0 + model.padding.top)) {\n            edHeight = (0 + model.padding.top);\n        }\n        if (stHeight > (height + model.padding.top)) {\n            stHeight = (height + model.padding.top);\n        }\n        else if (stHeight < (0 + model.padding.top)) {\n            stHeight = (0 + model.padding.top);\n        }\n        var path = 'M ' + (model.padding.left) + ' ' + stHeight + ' L ' + (width + (model.padding.left)) + ' ' + stHeight +\n            ' L ' + (width + (model.padding.left)) + ' ' + edHeight + ' L ' + (model.padding.left) + ' ' + edHeight + ' Z ';\n        var pathOption = {\n            'id': model.element.id + '_rangeBand_' + index,\n            'fill': color,\n            'opacity': rangeBandSettings.opacity,\n            'stroke': 'transparent',\n            'stroke-width': model.lineWidth,\n            'd': path,\n            'stroke-dasharray': ''\n        };\n        drawPath(this.sparkline, pathOption, group);\n    };\n    /**\n     * To render line series.\n     *\n     * @param {SparkValues[]} points - The data points for the line series.\n     * @param {ISeriesRenderingEventArgs} args - The rendering event arguments.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.renderLine = function (points, args) {\n        var spark = this.sparkline;\n        var g = this.sparkline.renderer.createGroup({\n            id: spark.element.id + '_sparkline_g',\n            'clip-path': 'url(#' + this.clipId + ')'\n        });\n        var color = this.sparkline.fill;\n        color = (this.sparkline.fill === '#00bdae' && this.sparkline.theme === 'Bootstrap4')\n            ? this.sparkline.sparkTheme.axisLineColor : color;\n        var pathOption = new PathOption(spark.element.id + '_sparkline_line', 'transparent', args.lineWidth, color, spark.opacity);\n        var d = '';\n        for (var i = 0, len = points.length; i < len; i++) {\n            if (i === 0) {\n                d = 'M ' + points[0].x + ' ' + points[i].y + ' ';\n            }\n            d += 'L ' + points[i].x + ' ' + points[i].y + ' ';\n        }\n        pathOption.d = d;\n        pathOption['aria-label'] = 'Line series with' + points.length + 'data points';\n        drawPath(this.sparkline, pathOption, g);\n        this.sparkline.svgObject.appendChild(g);\n    };\n    /**\n     * To render pie series.\n     *\n     * @param {SparkValues[]} points - The data points for the pie series.\n     * @param {ISeriesRenderingEventArgs} args - The rendering event arguments.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.renderPie = function (points, args) {\n        var spark = this.sparkline;\n        var height = spark.availableSize.height - (spark.padding.top + spark.padding.bottom);\n        var width = spark.availableSize.width - (spark.padding.left + spark.padding.right);\n        var area = (height <= width) ? height / 2 : width / 2;\n        var X = spark.availableSize.width / 2; // center position of x\n        var Y = spark.availableSize.height / 2; // center position of y\n        var deg = 0;\n        var stRad;\n        var edRad;\n        var stroke = args.border.color;\n        var opacity = spark.opacity;\n        var strokeWidth = args.border.width;\n        var colors = (spark.palette.length) ? spark.palette : getSeriesColor(this.sparkline.theme);\n        var group = this.sparkline.renderer.createGroup({ id: spark.element.id + '_sparkline_g' });\n        var low;\n        var high;\n        var locations = extend([], [], points);\n        if (spark.highPointColor || spark.lowPointColor) {\n            var pointsYvalues = locations.map(function (a) { return a.yVal; });\n            low = Math.min.apply(null, pointsYvalues);\n            high = Math.max.apply(null, pointsYvalues);\n        }\n        this.negativePointIndexes = [];\n        for (var i = 0, stDeg = 90, edDeg = void 0, flag = void 0; i < points.length; i++) {\n            stDeg += deg;\n            deg = points[i]['degree'];\n            deg = (deg === 360 ? deg - 0.001 : deg);\n            edDeg = stDeg + deg;\n            stRad = (stDeg - 90) * Math.PI / 180.0;\n            edRad = (edDeg - 90) * Math.PI / 180.0;\n            points[i]['stAng'] = stRad;\n            points[i]['endAng'] = edRad;\n            flag = (deg < 180) ? '0' : '1';\n            var temp = points[i]['coordinates'] = {\n                sX: X + (area * Math.cos(stRad)), sY: Y +\n                    (area * Math.sin(stRad)), eX: X + (area * Math.cos(edRad)), eY: Y + (area * Math.sin(edRad))\n            };\n            var pathArc = 'M ' + X + ' ' + Y + ' L ' + temp['eX'] + ' ' + temp['eY'] + ' A ' + area + ' ' +\n                area + ' 0 ' + flag + ',0 ' + temp['sX'] + ' ' + temp['sY'] + ' Z';\n            var pathOption = {\n                'id': spark.element.id + '_sparkline_pie_' + i,\n                'opacity': opacity,\n                'fill': colors[i % colors.length],\n                'stroke': stroke,\n                'stroke-width': strokeWidth,\n                'd': pathArc,\n                'stroke-dasharray': ''\n            };\n            this.getPieSpecialPoint(points[i], spark, pathOption, i, high, low, points.length);\n            var pointArgs = this.triggerPointRender('pointRendering', i, pathOption.fill, { color: stroke, width: strokeWidth });\n            pathOption.fill = pointArgs.fill;\n            pathOption.stroke = pointArgs.border.color;\n            pathOption['stroke-width'] = pointArgs.border.width;\n            if (!pointArgs.cancel) {\n                var element = drawPath(this.sparkline, pathOption, group);\n                element.setAttribute('role', 'img');\n                element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n                element.setAttribute('tabindex', i === 0 ? '0' : '-1');\n            }\n            var diffRadian = edRad - stRad;\n            var mid = {\n                x: X + ((area / 2) * Math.cos(stRad + (diffRadian / 2))),\n                y: Y + ((area / 2) * Math.sin(stRad + (diffRadian / 2)))\n            };\n            points[i].location.x = mid.x;\n            points[i].location.y = mid.y;\n        }\n        this.sparkline.svgObject.appendChild(group);\n    };\n    /**\n     * To get special point color and option for Pie series.\n     *\n     * @param {SparkValues} temp - The data point for the special point.\n     * @param {Sparkline} spark - The sparkline instance.\n     * @param {PathOption} option - The option for the special point.\n     * @param {number} i - The index of the special point.\n     * @param {number} high - The high value.\n     * @param {number} low - The low value.\n     * @param {number} length - The total number of data points.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.getPieSpecialPoint = function (temp, spark, option, i, high, low, length) {\n        if (temp.yVal < 0 && spark.negativePointColor) {\n            option.fill = spark.negativePointColor;\n            this.negativePointIndexes.push(i);\n        }\n        if (i === 0 && spark.startPointColor) {\n            option.fill = spark.startPointColor;\n            this.startPointIndex = i;\n        }\n        else if ((i === (length - 1)) && spark.endPointColor) {\n            option.fill = spark.endPointColor;\n            this.endPointIndex = i;\n        }\n        if (temp.yVal === high && spark.highPointColor) {\n            option.fill = spark.highPointColor;\n            this.highPointIndex = i;\n        }\n        else if (temp.yVal === low && spark.lowPointColor) {\n            option.fill = spark.lowPointColor;\n            this.lowPointIndex = i;\n        }\n    };\n    /**\n     * To render area series.\n     *\n     * @param {SparkValues[]} points - The data points for the area series.\n     * @param {ISeriesRenderingEventArgs} args - The rendering event arguments.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.renderArea = function (points, args) {\n        var spark = this.sparkline;\n        var group = this.sparkline.renderer.createGroup({\n            id: spark.element.id + '_sparkline_g',\n            'clip-path': 'url(#' + this.clipId + ')'\n        });\n        var pathOption = new PathOption(spark.element.id + '_sparkline_area', args.fill, 0, 'transparent', spark.opacity);\n        var d = '';\n        var str = '';\n        for (var i = 0, len = points.length; i < len; i++) {\n            if (i !== 0) {\n                str += 'L ' + points[i].x + ' ' + points[i].y + ' ';\n            }\n            else {\n                d = 'M ' + points[i].x + ' ' + this.axisHeight + ' ';\n                str = 'M ' + points[i].x + ' ' + points[i].y + ' ';\n            }\n            d += 'L ' + points[i].x + ' ' + points[i].y + ' ';\n            if (i === (len - 1)) {\n                d += 'L ' + points[i].x + ' ' + this.axisHeight + ' Z';\n            }\n        }\n        pathOption.d = d;\n        pathOption['aria-label'] = 'Area series with' + points.length + 'data points';\n        drawPath(this.sparkline, pathOption, group);\n        pathOption = new PathOption(spark.element.id + '_sparkline_area_str', 'transparent', args.border.width, args.border.color, spark.opacity, '', str);\n        drawPath(this.sparkline, pathOption, group);\n        this.sparkline.svgObject.appendChild(group);\n    };\n    /**\n     * To render column series.\n     *\n     * @param {SparkValues[]} points - The data points for the column series.\n     * @param {ISeriesRenderingEventArgs} args - The rendering event arguments.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.renderColumn = function (points, args) {\n        var _this = this;\n        var spark = this.sparkline;\n        var locations = extend([], [], points);\n        var group = this.sparkline.renderer.createGroup({\n            id: spark.element.id + '_sparkline_g',\n            'clip-path': 'url(#' + this.clipId + ')'\n        });\n        var lowPos;\n        var highPos;\n        if (this.sparkline.highPointColor || this.sparkline.lowPointColor) {\n            var pointsYPos = locations.map(function (a) { return a.markerPosition; });\n            highPos = Math.min.apply(null, pointsYPos);\n            lowPos = Math.max.apply(null, pointsYPos);\n        }\n        var id = spark.element.id + '_sparkline_column_';\n        var rectOptions = new RectOption(id, '', args.border, spark.opacity, null);\n        var temp;\n        var len = points.length;\n        this.negativePointIndexes = [];\n        var colors = (spark.palette.length) ? spark.palette : getSeriesColor(this.sparkline.theme);\n        var _loop_1 = function (i) {\n            temp = points[i];\n            rectOptions.id = id + i;\n            rectOptions.fill = spark.fill !== '#00bdae' ? spark.fill : colors[0];\n            rectOptions.rect = new Rect(temp.x, temp.y, temp.width, temp.height);\n            this_1.getSpecialPoint(true, temp, spark, rectOptions, i, highPos, lowPos, len);\n            temp.location.y = (temp.markerPosition <= this_1.axisHeight) ? temp.y : (temp.y + temp.height);\n            temp.location.x = temp.x + (temp.width / 2);\n            rectOptions.stroke = args.border.color ? (args.border.color) : rectOptions.fill;\n            var pointArgs = {\n                name: 'pointRendering', cancel: false, pointIndex: i, fill: rectOptions.fill,\n                border: { color: rectOptions.stroke, width: args.border.width }\n            };\n            this_1.sparkline.trigger('pointRendering', pointArgs, function () {\n                temp = points[i];\n                rectOptions.id = id + i;\n                rectOptions.rect = new Rect(temp.x, temp.y, temp.width, temp.height);\n                _this.getSpecialPoint(true, temp, spark, rectOptions, i, highPos, lowPos, len);\n                rectOptions.fill = pointArgs.fill;\n                rectOptions.stroke = pointArgs.border.color;\n                temp.location.y = (temp.markerPosition <= _this.axisHeight) ? temp.y : (temp.y + temp.height);\n                rectOptions['stroke-width'] = pointArgs.border.width;\n                temp.location.x = temp.x + (temp.width / 2);\n                if (!pointArgs.cancel) {\n                    var element = drawRectangle(spark, rectOptions, group);\n                    element.setAttribute('role', 'img');\n                    element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n                    element.setAttribute('tabindex', i === 0 ? '0' : '-1');\n                    group.appendChild(element);\n                }\n            });\n        };\n        var this_1 = this;\n        for (var i = 0; i < len; i++) {\n            _loop_1(i);\n        }\n        this.sparkline.svgObject.appendChild(group);\n    };\n    /**\n     * To render WinLoss series.\n     *\n     * @param {SparkValues[]} points - The data points for the winloss series.\n     * @param {ISeriesRenderingEventArgs} args - The rendering event arguments.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.renderWinLoss = function (points, args) {\n        var spark = this.sparkline;\n        var group = this.sparkline.renderer.createGroup({\n            id: spark.element.id + '_sparkline_g',\n            'clip-path': 'url(#' + this.clipId + ')'\n        });\n        var id = spark.element.id + '_sparkline_winloss_';\n        var options = new RectOption(id, '', args.border, spark.opacity, null);\n        var temp;\n        var len = points.length;\n        var paletteLength = spark.palette.length;\n        var colors = (spark.palette.length) ? spark.palette : getSeriesColor(this.sparkline.theme);\n        for (var i = 0; i < len; i++) {\n            temp = points[i];\n            options.id = id + i;\n            options.fill = (paletteLength) ? spark.palette[i % paletteLength] : ((temp.yVal === this.axisValue) ?\n                (this.sparkline.tiePointColor || '#a216f3') : ((temp.yVal > this.axisValue) ? args.fill || colors[i % colors.length] :\n                (spark.negativePointColor || '#e20f07')));\n            options.stroke = (args.border.color) ? (args.border.color) : options.fill;\n            options.rect = new Rect(temp.x, temp.y, temp.width, temp.height);\n            temp.location.x = temp.x + (temp.width / 2);\n            temp.location.y = (temp.yVal >= this.axisValue) ? (temp.y) : (temp.y + temp.height);\n            var pointArgs = this.triggerPointRender('pointRendering', i, options.fill, { color: options.stroke, width: args.border.width });\n            options.fill = pointArgs.fill;\n            options.stroke = pointArgs.border.color;\n            options['stroke-width'] = pointArgs.border.width;\n            if (!pointArgs.cancel) {\n                var element = drawRectangle(spark, options, group);\n                element.setAttribute('role', 'img');\n                element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n                element.setAttribute('tabindex', i === 0 ? '0' : '-1');\n            }\n        }\n        this.sparkline.svgObject.appendChild(group);\n    };\n    SparklineRenderer.prototype.renderMarker = function (points) {\n        var _this = this;\n        var spark = this.sparkline;\n        var marker = spark.markerSettings;\n        if ((spark.type === 'Pie' || spark.type === 'WinLoss' || !marker.visible.length)) {\n            return;\n        }\n        var locations = extend([], [], points);\n        var group = this.sparkline.renderer.createGroup({\n            id: spark.element.id + '_sparkline_marker_g',\n            'clip-path': 'url(#' + this.clipId + ')'\n        });\n        var temp;\n        var id = spark.element.id + '_sparkline_marker_';\n        var option = new CircleOption('', marker.fill, marker.border, marker.opacity, 0, 0, marker.size / 2, '');\n        var highPos;\n        var lowPos;\n        var visible = marker.visible.join();\n        if ((visible.toLowerCase().indexOf('high') > -1) || (visible.toLowerCase().indexOf('low') > -1)) {\n            var pointsYPos = locations.map(function (a) { return a.markerPosition; });\n            highPos = Math.min.apply(null, pointsYPos);\n            lowPos = Math.max.apply(null, pointsYPos);\n        }\n        this.negativePointIndexes = [];\n        var _loop_2 = function (i, length_1) {\n            temp = points[i];\n            option.id = id + i;\n            option.cx = temp.location.x;\n            option.cy = temp.location.y;\n            option.fill = marker.fill;\n            var render = (visible.toLowerCase().indexOf('all') > -1);\n            render = this_2.getSpecialPoint(render, temp, spark, option, i, highPos, lowPos, length_1, visible.toLowerCase());\n            option.stroke = marker.border.color || option.fill;\n            var markerArgs = {\n                name: 'markerRendering', cancel: false,\n                border: { color: option.stroke, width: marker.border.width },\n                fill: option.fill, pointIndex: i,\n                sparkline: this_2.sparkline,\n                x: option.cx, y: option.cy, size: marker.size\n            };\n            this_2.sparkline.trigger('markerRendering', markerArgs, function () {\n                if (render && !markerArgs.cancel) {\n                    option.id = id + i;\n                    option.cx = markerArgs.x;\n                    option.cy = markerArgs.y;\n                    option.fill = markerArgs.fill;\n                    option.stroke = markerArgs.border.color;\n                    option['stroke-width'] = markerArgs.border.width;\n                    option.r = markerArgs.size / 2;\n                    var element = drawCircle(spark, option, group);\n                    element.setAttribute('role', 'img');\n                    element.setAttribute('aria-label', spark.dataSource[i][spark.xName] + ' : ' + points[i].yVal);\n                    if ((_this.sparkline.type.indexOf('Line') > -1) || (_this.sparkline.type.indexOf('Area') > -1)) {\n                        element.setAttribute('tabindex', i === 0 ? '0' : '-1');\n                    }\n                    group.appendChild(element);\n                }\n            });\n        };\n        var this_2 = this;\n        for (var i = 0, length_1 = points.length; i < length_1; i++) {\n            _loop_2(i, length_1);\n        }\n        this.sparkline.svgObject.appendChild(group);\n    };\n    /**\n     * To get special point color and option.\n     *\n     * @param {boolean} render - Indicates whether to render the special point.\n     * @param {SparkValues} temp - The data point for the special point.\n     * @param {Sparkline} spark - The sparkline instance.\n     * @param {PathOption} option - The option for the special point.\n     * @param {number} i - The index of the special point.\n     * @param {number} highPos - The position of the high value.\n     * @param {number} lowPos - The position of the low value.\n     * @param {number} length - The total number of data points.\n     * @param {string} visible - The visibility state of the special point.\n     * @returns {boolean} - Indicates whether the special point is rendered.\n     */\n    SparklineRenderer.prototype.getSpecialPoint = function (render, temp, spark, option, i, highPos, lowPos, length, visible) {\n        if (visible === void 0) { visible = ''; }\n        if (temp.markerPosition > this.axisHeight) {\n            option.fill = spark.negativePointColor || option.fill;\n            this.negativePointIndexes.push(i);\n            render = render || (visible.indexOf('negative') > -1);\n        }\n        if (i === 0) {\n            option.fill = spark.startPointColor || option.fill;\n            this.startPointIndex = i;\n            render = render || (visible.indexOf('start') > -1);\n        }\n        else if ((i === (length - 1))) {\n            option.fill = spark.endPointColor || option.fill;\n            this.endPointIndex = i;\n            render = render || (visible.indexOf('end') > -1);\n        }\n        if (temp.markerPosition === highPos) {\n            option.fill = spark.highPointColor || option.fill;\n            this.highPointIndex = i;\n            render = render || (visible.indexOf('high') > -1);\n        }\n        else if (temp.markerPosition === lowPos) {\n            option.fill = spark.lowPointColor || option.fill;\n            this.lowPointIndex = i;\n            render = render || (visible.indexOf('low') > -1);\n        }\n        if (visible.indexOf('none') > -1) {\n            render = false;\n        }\n        return render;\n    };\n    /**\n     * To render data label for sparkline.\n     *\n     * @param {SparkValues[]} points - The data points for the series datalabels.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.renderLabel = function (points) {\n        var _this = this;\n        var spark = this.sparkline;\n        var dataLabel = spark.dataLabelSettings;\n        var color = dataLabel.textStyle.color || spark.sparkTheme.dataLabelColor;\n        if ((spark.type === 'WinLoss' || !dataLabel.visible.length)) {\n            return;\n        }\n        var locations = extend([], [], points);\n        var id = spark.element.id + '_sparkline_label_';\n        var group = this.sparkline.renderer.createGroup({\n            id: spark.element.id + '_sparkline_label_g',\n            style: 'pointer-events: none;'\n        });\n        group.setAttribute('aria-hidden', 'true');\n        var g;\n        var temp;\n        var textId = id + 'text_';\n        var rectId = id + 'rect_';\n        var option = new TextOption('', 0, 0, 'middle', '', 'middle');\n        var labelStyle = dataLabel.textStyle;\n        var pointsYPos = locations.map(function (a) { return a.markerPosition; });\n        var highPos = Math.min.apply(null, pointsYPos);\n        var lowPos = Math.max.apply(null, pointsYPos);\n        var space = 1;\n        var padding = (dataLabel.fill !== 'transparent' || dataLabel.border.width) ? 2 : 0;\n        var size = measureText('sparkline_measure_text', labelStyle, this.sparkline.sparkTheme.dataLabelFont);\n        var rectOptions = new RectOption('', dataLabel.fill, dataLabel.border, dataLabel.opacity, null);\n        var edgeLabelOption;\n        var _loop_3 = function (i, length_2) {\n            temp = points[i];\n            option.id = textId + i;\n            option.x = temp.location.x + dataLabel.offset.x;\n            option.y = ((spark.type === 'Pie') ? temp.location.y : ((temp.markerPosition > this_3.axisHeight) ? (temp.location.y +\n                (size.height / 2) + space + 2 + padding) : (temp.location.y - (size.height / 2) - space - padding))) + dataLabel.offset.y;\n            option.text = (dataLabel.format !== '') ? this_3.formatter(dataLabel.format, this_3.sparkline.dataSource[i]) :\n                temp.yVal.toString();\n            var labelArgs = {\n                name: 'dataLabelRendering', cancel: false,\n                border: dataLabel.border, fill: dataLabel.fill, pointIndex: i,\n                sparkline: this_3.sparkline,\n                x: option.x, y: option.y, text: option.text, color: color\n            };\n            this_3.sparkline.trigger('dataLabelRendering', labelArgs, function () {\n                size = measureText(labelArgs.text, labelStyle, _this.sparkline.sparkTheme.dataLabelFont);\n                option.text = labelArgs.text;\n                var renderLabel = (dataLabel.visible.join().toLowerCase().indexOf('all') > -1);\n                renderLabel = _this.getLabelVisible(renderLabel, temp, i, dataLabel, length_2, highPos, lowPos);\n                edgeLabelOption = _this.arrangeLabelPosition(dataLabel.edgeLabelMode, renderLabel, labelArgs.x, i, length_2, size, padding);\n                if (renderLabel && !labelArgs.cancel && edgeLabelOption.render) {\n                    rectOptions.id = rectId + i;\n                    rectOptions.fill = labelArgs.fill;\n                    rectOptions.stroke = labelArgs.border.color;\n                    rectOptions['stroke-width'] = labelArgs.border.width;\n                    option.y = labelArgs.y;\n                    option.x = edgeLabelOption.x;\n                    rectOptions.rect = new Rect(option.x - ((size.width / 2) + padding), (option.y - padding - (size.height / 1.75)), size.width + (padding * 2), size.height + (padding * 2));\n                    g = _this.sparkline.renderer.createGroup({ id: id + 'g' + i });\n                    drawRectangle(spark, rectOptions, g);\n                    renderTextElement(option, labelStyle, labelArgs.color, g, _this.sparkline.sparkTheme.dataLabelFont);\n                    group.appendChild(g);\n                }\n            });\n        };\n        var this_3 = this;\n        for (var i = 0, length_2 = points.length; i < length_2; i++) {\n            _loop_3(i, length_2);\n        }\n        this.sparkline.svgObject.appendChild(group);\n    };\n    SparklineRenderer.prototype.arrangeLabelPosition = function (edgeLabel, render, x, index, length, size, padding) {\n        if (edgeLabel === 'None') {\n            return { x: x, render: render };\n        }\n        if (index === 0 && ((x - (size.width / 2) - padding) <= 0)) {\n            if (edgeLabel === 'Hide') {\n                render = false;\n            }\n            else {\n                x = this.sparkline.padding.left + padding + (size.width / 2);\n            }\n        }\n        else if (index === length - 1 && ((x + (size.width / 2) + padding) >= this.sparkline.availableSize.width)) {\n            if (edgeLabel === 'Hide') {\n                render = false;\n            }\n            else {\n                x -= (size.width / 2 + padding);\n            }\n        }\n        return { x: x, render: render };\n    };\n    /**\n     * To get special point color and option.\n     *\n     * @param {boolean} render - Indicates whether to render the special point.\n     * @param {SparkValues} temp - The data point for the special point.\n     * @param {number} i - The index of the sparkline instance.\n     * @param {SparklineDataLabelSettingsModel} label - The options for the special point.\n     * @param {number} length - The total number of data points.\n     * @param {number} highPos - The position of the high value.\n     * @param {number} lowPos - The position of the low value.\n     * @returns {boolean} - Indicates whether the special point is rendered.\n     */\n    SparklineRenderer.prototype.getLabelVisible = function (render, temp, i, label, length, highPos, lowPos) {\n        var labelVisible = label.visible.join().toLowerCase();\n        if (temp.markerPosition > this.axisHeight) {\n            render = render || (labelVisible.indexOf('negative') > -1);\n        }\n        if (i === 0) {\n            render = render || (labelVisible.indexOf('start') > -1);\n        }\n        else if ((i === (length - 1))) {\n            render = render || (labelVisible.indexOf('end') > -1);\n        }\n        if (temp.markerPosition === highPos) {\n            render = render || (labelVisible.indexOf('high') > -1);\n        }\n        else if (temp.markerPosition === lowPos) {\n            render = render || (labelVisible.indexOf('low') > -1);\n        }\n        if (label.visible.join().toLowerCase().indexOf('none') > -1) {\n            render = false;\n        }\n        return render;\n    };\n    /**\n     * To format text.\n     *\n     * @param {string} format - The format string to apply.\n     * @param {object} data - The data object to format.\n     * @returns {string} - The formatted text.\n     */\n    SparklineRenderer.prototype.formatter = function (format, data) {\n        if (isNullOrUndefined(format)) {\n            return null;\n        }\n        var keys = Object.keys(data);\n        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n            var key = keys_1[_i];\n            format = format.split('${' + key + '}').join(data[key]);\n        }\n        return format;\n    };\n    /**\n     * To calculate min and max for x and y axis.\n     *\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.axisCalculation = function () {\n        this.findRanges(this.sparkline.sparklineData);\n    };\n    /**\n     * To find x axis interval.\n     *\n     * @param {Object[]} data - The data points.\n     * @param {string} x - The x-axis field name.\n     * @returns {number} - The calculated interval.\n     */\n    SparklineRenderer.prototype.getInterval = function (data, x) {\n        var interval = 1;\n        var x1 = data[0][x];\n        var x2 = isNullOrUndefined(data[1]) ? undefined : data[1][x];\n        if (!isNullOrUndefined(x1) && !isNullOrUndefined(x2)) {\n            var temp = extend([], data);\n            var validData_1 = [];\n            temp.forEach(function (value) {\n                if (!isNullOrUndefined(value[x])) {\n                    validData_1.push(value);\n                }\n            });\n            validData_1.sort(function (a, b) {\n                if (isNullOrUndefined(a[x]) || isNullOrUndefined(b[x])) {\n                    return 0;\n                }\n                return a[x] - b[x];\n            });\n            validData_1 = (this.sparkline.enableRtl) ? validData_1.reverse() : validData_1;\n            interval = validData_1[1][x] - validData_1[0][x];\n        }\n        return interval;\n    };\n    /**\n     * To find x axis interval for padding.\n     *\n     * @param {Object[]} data - The data points.\n     * @param {string} x - The x-axis field name.\n     * @param {SparklineValueType} type - The type of sparkline value.\n     * @param {number} delta - The delta values.\n     * @returns {number} - The calculated x-axis interval for padding.\n     */\n    SparklineRenderer.prototype.getPaddingInterval = function (data, x, type, delta) {\n        var interval = 1;\n        var size = this.sparkline.availableSize.height;\n        var intervalCount = interval * data.length;\n        intervalCount = Math.max((size * (intervalCount / 100)), 1);\n        var niceInterval = delta / intervalCount;\n        for (var _i = 0, _a = this.sparkline.intervalDivs; _i < _a.length; _i++) {\n            var intervalVal = _a[_i];\n            var currentInterval = interval * intervalVal;\n            if (intervalCount < (delta / currentInterval)) {\n                break;\n            }\n            niceInterval = currentInterval;\n        }\n        return niceInterval;\n    };\n    /**\n     * To calculate axis ranges internally.\n     *\n     * @param {Object[]} data - The data points.\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.findRanges = function (data) {\n        var model = this.sparkline;\n        var max;\n        var min;\n        var minX;\n        var maxX;\n        var maxPointsLength = data.length;\n        var temp;\n        var sumofValues = 0;\n        var isNumericArray = Array.isArray(data) && typeof data[0] !== 'object';\n        if (isNumericArray) {\n            if (model.type === 'Pie') {\n                for (var i = 0; i < maxPointsLength; i++) {\n                    sumofValues += Math.abs(data[i]);\n                }\n            }\n            else {\n                max = Math.max.apply(null, data);\n                min = Math.min.apply(null, data);\n                minX = 0;\n                maxX = maxPointsLength - 1;\n            }\n        }\n        else {\n            if (model.type === 'Pie') {\n                for (var i = 0; i < maxPointsLength; i++) {\n                    sumofValues += Math.abs(data[i][model.yName]);\n                }\n            }\n            else {\n                if (isNullOrUndefined(data[0][model.xName])) {\n                    var x_1 = data.map(function (z) { return z[model.yName]; });\n                    max = Math.max.apply(null, x_1);\n                    min = Math.min.apply(null, x_1);\n                }\n                else {\n                    temp = extend([], data);\n                    temp = temp.sort(function (a, b) { return a[model.yName] - b[model.yName]; });\n                    max = temp[temp.length - 1][model.yName];\n                    min = temp[0][model.yName];\n                }\n                if (!isNullOrUndefined(data[0][model.xName])) {\n                    temp = temp.sort(function (a, b) { return a[model.xName] - b[model.xName]; });\n                    temp = (this.sparkline.enableRtl) ? temp.reverse() : temp;\n                    maxX = temp[temp.length - 1][model.xName];\n                    minX = temp[0][model.xName];\n                }\n                else {\n                    minX = 0;\n                    maxX = maxPointsLength - 1;\n                }\n            }\n        }\n        var y2;\n        var height;\n        var width;\n        var x1 = 0;\n        var y1;\n        var padding = model.padding;\n        var point;\n        var axis = model.axisSettings;\n        var value = axis.value;\n        if (model.type !== 'Pie') {\n            this.maxLength = maxPointsLength;\n            height = model.availableSize.height - (padding.bottom + padding.top);\n            width = model.availableSize.width - (padding.left + padding.right);\n            maxX = isNullOrUndefined(axis.maxX) ? maxX : axis.maxX;\n            minX = isNullOrUndefined(axis.minX) ? minX : axis.minX;\n            max = isNullOrUndefined(axis.maxY) ? max : axis.maxY;\n            min = isNullOrUndefined(axis.minY) ? min : axis.minY;\n            var color = axis.lineSettings.color || this.sparkline.sparkTheme.axisLineColor;\n            var eventArgs = {\n                name: 'axisRendering', cancel: false, sparkline: model,\n                maxX: maxX, minX: minX, maxY: max, minY: min, value: axis.value,\n                lineColor: color, lineWidth: axis.lineSettings.width\n            };\n            model.trigger('axisRendering', eventArgs);\n            if (eventArgs.cancel) {\n                this.visiblePoints = [];\n                return;\n            }\n            maxX = eventArgs.maxX;\n            minX = eventArgs.minX;\n            max = eventArgs.maxY;\n            min = eventArgs.minY;\n            value = this.axisValue = eventArgs.value;\n            this.axisColor = eventArgs.lineColor;\n            this.axisWidth = eventArgs.lineWidth;\n        }\n        var unitX = maxX - minX;\n        var unitY = max - min;\n        unitX = (unitX === 0) ? 1 : unitX;\n        unitY = (unitY === 0) ? 1 : unitY;\n        this.unitX = unitX;\n        this.unitY = unitY;\n        this.min = min;\n        x1 = 0;\n        y1 = height - ((height / unitY) * (-min));\n        y1 = (min < 0 && max <= 0) ? 0 : (min < 0 && max > 0) ? y1 : height;\n        if (value >= min && value <= max) {\n            y1 = height - Math.round(height * ((value - min) / this.unitY));\n        }\n        this.axisHeight = y1 + padding.top;\n        var percent;\n        var x;\n        var y;\n        var visiblePoints = [];\n        var delta = max - min;\n        var interval = this.getInterval(data, model.xName);\n        var interVal = this.getPaddingInterval(data, model.xName, model.valueType, delta);\n        for (var i = 0; i < maxPointsLength; i++) {\n            if (isNullOrUndefined(data[i][model.xName]) && isNullOrUndefined(data[i][model.yName]) &&\n                ((data[i][model.yName]) !== 0) && isNumericArray) {\n                x = i;\n                y = data[i];\n            }\n            else if (isNullOrUndefined(data[i][model.xName])) {\n                x = i;\n                y = data[i][model.yName];\n            }\n            else {\n                x = data[i][model.xName];\n                y = data[i][model.yName];\n            }\n            if (isNullOrUndefined(x) || isNullOrUndefined(y)) {\n                continue;\n            }\n            if (model.type === 'Line' || model.type === 'Area') {\n                y2 = (min !== max && maxPointsLength !== 1) ? height - Math.round(height * ((y - min) / this.unitY)) : padding.top;\n                point = { x: (minX !== maxX) ? Math.round(width * ((x - minX) / this.unitX)) : width / 2, y: y2, markerPosition: y2 };\n            }\n            else if (model.type === 'Column' || model.type === 'WinLoss') {\n                var colWidth = width / (((maxX - minX) / interval) + 1);\n                var calSpace = 0.5;\n                var space = (calSpace * 2); //calspace is default space for column and winloss\n                colWidth -= (space);\n                x1 = (((x - minX) / interval) * (colWidth + space)) + (space / 2);\n                if (model.type === 'WinLoss') {\n                    // win or gain column height half of the height , draw(zero) height factor\n                    var winLossFactor = 0.5;\n                    var drawHeightFactor = 40;\n                    y2 = (y > value) ? (height / 4) : (y < value) ? (height * winLossFactor) :\n                        ((height * winLossFactor) - (height / drawHeightFactor));\n                    point = {\n                        x: x1, y: y2, height: (y !== value) ? (height / 4) : height / 20, width: colWidth,\n                        markerPosition: (y2 > y1) ? (y1 + Math.abs(y2 - y1)) : y2\n                    };\n                }\n                else {\n                    if (i === 0 && model.rangePadding !== 'None') {\n                        min -= model.rangePadding === 'Additional' ? (interVal + padding.top) : interVal;\n                        max += model.rangePadding === 'Additional' ? (interVal + padding.top) : interVal;\n                        unitX = maxX - minX;\n                        unitY = max - min;\n                        unitX = (unitX === 0) ? 1 : unitX;\n                        unitY = (unitY === 0) ? 1 : unitY;\n                        this.unitX = unitX;\n                        this.unitY = unitY;\n                        this.min = min;\n                    }\n                    var z = ((height / this.unitY) * (y - min));\n                    var z1 = (y === min && y > value) ? ((maxPointsLength !== 1 && this.unitY !== 1) ?\n                        (height / this.unitY) * (min / 2) : (z | 1)) :\n                        (y === max && y < value && maxPointsLength !== 1 && this.unitY !== 1) ? (height / this.unitY) * (-max / 2) : z;\n                    y2 = Math.abs(height - z1);\n                    point = {\n                        x: x1, y: (y2 > y1) ? y1 : y2, height: Math.abs(y2 - y1),\n                        width: colWidth, markerPosition: (y2 > y1) ? (y1 + Math.abs(y2 - y1)) : y2\n                    };\n                }\n            }\n            else if (model.type === 'Pie') {\n                percent = (Math.abs(y) / sumofValues) * 100;\n                point = {\n                    percent: percent, degree: ((Math.abs(y) / sumofValues) * 360)\n                };\n            }\n            if (model.type !== 'Pie') {\n                point.x += padding.left;\n                point.y += padding.top;\n            }\n            if (model.type !== 'WinLoss') {\n                point.markerPosition += padding.top;\n            }\n            point.location = { x: point.x, y: point.y };\n            point.xVal = x;\n            point.yVal = y;\n            visiblePoints.push(point);\n        }\n        visiblePoints.sort(function (a, b) {\n            return a.x - b.x;\n        });\n        this.visiblePoints = visiblePoints;\n    };\n    /**\n     * To render the sparkline axis.\n     *\n     * @returns {void}\n     */\n    SparklineRenderer.prototype.drawAxis = function () {\n        var spark = this.sparkline;\n        var height = this.axisHeight;\n        if ((spark.type !== 'WinLoss') && (spark.type !== 'Pie') && spark.axisSettings.lineSettings.visible) {\n            var xAxis = {\n                'id': spark.element.id + '_Sparkline_XAxis',\n                'x1': spark.padding.left, 'y1': height,\n                'x2': spark.availableSize.width - spark.padding.right, 'y2': height,\n                'stroke': this.axisColor,\n                'opacity': spark.axisSettings.lineSettings.opacity,\n                'stroke-dasharray': spark.axisSettings.lineSettings.dashArray,\n                'stroke-width': this.axisWidth,\n                'clip-path': 'url(#' + this.clipId + ')'\n            };\n            spark.svgObject.appendChild(spark.renderer.drawLine(xAxis));\n        }\n    };\n    /**\n     * To trigger point render event.\n     *\n     * @param {string} name - The name of the data point.\n     * @param {number} i - The index of the data point.\n     * @param {string} fill - The fill color of the data point.\n     * @param {SparklineBorderModel} border - The border settings of the data point.\n     * @returns {ISparklinePointEventArgs} - The event arguments for the point render event.\n     */\n    SparklineRenderer.prototype.triggerPointRender = function (name, i, fill, border) {\n        var args = {\n            name: name, cancel: false,\n            border: border, fill: fill,\n            sparkline: this.sparkline,\n            pointIndex: i\n        };\n        this.sparkline.trigger(name, args);\n        return args;\n    };\n    return SparklineRenderer;\n}());\nexport { SparklineRenderer };\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,iBAAiB,QAAQ,sBAAsB;AAChE,SAASC,UAAU,EAAEC,QAAQ,EAAEC,aAAa,EAAEC,UAAU,EAAEC,IAAI,EAAEC,YAAY,EAAEC,UAAU,EAAEC,cAAc,QAAQ,iBAAiB;AACjI,SAASC,WAAW,EAAEC,iBAAiB,EAAEC,UAAU,QAAQ,iBAAiB;AAC5E,SAASC,WAAW,EAAEC,KAAK,QAAQ,sBAAsB;AACzD;AACA;AACA;AACA,IAAIC,iBAAiB,GAAG,aAAe,YAAY;EAC/C;AACJ;AACA;AACA;AACA;EACI,SAASA,iBAAiBA,CAACC,SAAS,EAAE;IAClC,IAAI,CAACA,SAAS,GAAGA,SAAS;EAC9B;EACA;AACJ;AACA;AACA;AACA;EACID,iBAAiB,CAACE,SAAS,CAACC,WAAW,GAAG,YAAY;IAClD,IAAIC,IAAI,GAAG,IAAI,CAACH,SAAS,CAACI,UAAU;IACpC,IAAInB,iBAAiB,CAACkB,IAAI,CAAC,IAAI,CAACA,IAAI,CAACE,MAAM,EAAE;MACzC;IACJ,CAAC,MACI,IAAI,CAACC,KAAK,CAAC,IAAI,CAACN,SAAS,CAACI,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,IAAI,CAACJ,SAAS,CAACO,SAAS,KAAK,SAAS,EAAE;MACrFJ,IAAI,GAAI,IAAI,CAACH,SAAS,CAACQ,SAAS,GAAIL,IAAI,CAACM,OAAO,CAAC,CAAC,GAAGN,IAAI;MACzD,IAAI,CAACH,SAAS,CAACU,aAAa,GAAGP,IAAI,CAAC,CAAC;IACzC,CAAC,MACI;MACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAACH,SAAS,CAACO,SAAS,CAAC,CAAC,CAAC;IAChD;IACA,IAAI,CAACI,eAAe,CAAC,CAAC;EAC1B,CAAC;EACDZ,iBAAiB,CAACE,SAAS,CAACW,kBAAkB,GAAG,YAAY;IACzD,IAAIC,KAAK,GAAG,IAAI;IAChB,IAAIC,UAAU;IACd,IAAIC,WAAW;IACf,IAAI,IAAI,CAACf,SAAS,CAACI,UAAU,YAAYP,WAAW,EAAE;MAClDiB,UAAU,GAAG,IAAI,CAACd,SAAS,CAACI,UAAU;MACtCW,WAAW,GAAG,IAAI,CAACf,SAAS,CAACgB,KAAK,YAAYlB,KAAK,GAAG,IAAI,CAACE,SAAS,CAACgB,KAAK,GAAG,IAAIlB,KAAK,CAAC,CAAC;MACxF,IAAImB,WAAW,GAAGH,UAAU,CAACI,YAAY,CAACH,WAAW,CAAC;MACtDE,WAAW,CAACE,IAAI,CAAC,UAAUC,CAAC,EAAE;QAC1BP,KAAK,CAACb,SAAS,CAACqB,aAAa,CAAC;UAAEjB,UAAU,EAAEgB,CAAC,CAAC,QAAQ;QAAE,CAAC,EAAE,IAAI,CAAC;QAChEP,KAAK,CAACb,SAAS,CAACU,aAAa,GAAGG,KAAK,CAACb,SAAS,CAACI,UAAU;QAC1DS,KAAK,CAACb,SAAS,CAACsB,oBAAoB,CAAC,CAAC;MAC1C,CAAC,CAAC;IACN,CAAC,MACI;MACD,IAAI,CAACtB,SAAS,CAACsB,oBAAoB,CAAC,CAAC;IACzC;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIvB,iBAAiB,CAACE,SAAS,CAACsB,eAAe,GAAG,UAAUpB,IAAI,EAAEqB,CAAC,EAAEC,CAAC,EAAE;IAChE,IAAIZ,KAAK,GAAG,IAAI;IAChB,IAAIV,IAAI,KAAK,KAAK,CAAC,EAAE;MAAEA,IAAI,GAAG,IAAI,CAACH,SAAS,CAACI,UAAU;IAAE;IACzD,IAAIoB,CAAC,KAAK,KAAK,CAAC,EAAE;MAAEA,CAAC,GAAG,IAAI,CAACxB,SAAS,CAAC0B,KAAK;IAAE;IAC9C,IAAID,CAAC,KAAK,KAAK,CAAC,EAAE;MAAEA,CAAC,GAAG,IAAI,CAACzB,SAAS,CAAC2B,KAAK;IAAE;IAC9C,IAAIC,IAAI,GAAG,EAAE;IACb,IAAIC,OAAO,GAAG,EAAE;IAChB1B,IAAI,CAAC2B,OAAO,CAAC,UAAUC,KAAK,EAAE;MAC1B,IAAIF,OAAO,CAACG,OAAO,CAACD,KAAK,CAACP,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;QAClCK,OAAO,CAACI,IAAI,CAACF,KAAK,CAACP,CAAC,CAAC,CAAC;MAC1B;MACA,IAAIU,WAAW,GAAG,CAAC,CAAC;MACpBA,WAAW,CAACrB,KAAK,CAACb,SAAS,CAAC0B,KAAK,CAAC,GAAGG,OAAO,CAACG,OAAO,CAACD,KAAK,CAACP,CAAC,CAAC,CAAC;MAC9DU,WAAW,CAACrB,KAAK,CAACb,SAAS,CAAC2B,KAAK,CAAC,GAAGI,KAAK,CAACN,CAAC,CAAC;MAC7CG,IAAI,CAACK,IAAI,CAACC,WAAW,CAAC;IAC1B,CAAC,CAAC;IACF,IAAI,CAAClC,SAAS,CAACU,aAAa,GAAGkB,IAAI;EACvC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI7B,iBAAiB,CAACE,SAAS,CAACkC,eAAe,GAAG,UAAUhC,IAAI,EAAEqB,CAAC,EAAEC,CAAC,EAAE;IAChE,IAAItB,IAAI,KAAK,KAAK,CAAC,EAAE;MAAEA,IAAI,GAAG,IAAI,CAACH,SAAS,CAACI,UAAU;IAAE;IACzD,IAAIoB,CAAC,KAAK,KAAK,CAAC,EAAE;MAAEA,CAAC,GAAG,IAAI,CAACxB,SAAS,CAAC0B,KAAK;IAAE;IAC9C,IAAID,CAAC,KAAK,KAAK,CAAC,EAAE;MAAEA,CAAC,GAAG,IAAI,CAACzB,SAAS,CAAC2B,KAAK;IAAE;IAC9C,IAAIC,IAAI,GAAG,EAAE;IACbzB,IAAI,CAAC2B,OAAO,CAAC,UAAUC,KAAK,EAAE;MAC1B,IAAIG,WAAW,GAAG,CAAC,CAAC;MACpBA,WAAW,CAACV,CAAC,CAAC,GAAGO,KAAK,CAACP,CAAC,CAAC,CAACY,OAAO,CAAC,CAAC;MACnCF,WAAW,CAACT,CAAC,CAAC,GAAGM,KAAK,CAACN,CAAC,CAAC;MACzBG,IAAI,CAACK,IAAI,CAACC,WAAW,CAAC;IAC1B,CAAC,CAAC;IACF,IAAI,CAAClC,SAAS,CAACU,aAAa,GAAGkB,IAAI;EACvC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI7B,iBAAiB,CAACE,SAAS,CAACoC,YAAY,GAAG,YAAY;IACnD,IAAIxB,KAAK,GAAG,IAAI;IAChB,IAAIyB,KAAK,GAAG,IAAI,CAACtC,SAAS;IAC1B,IAAI,CAACuC,MAAM,GAAGD,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,sBAAsB;IACvD,IAAI,CAACC,QAAQ,CAAC,CAAC;IACf,IAAIC,QAAQ,GAAG;MACXC,IAAI,EAAE,iBAAiB;MACvBC,MAAM,EAAE,KAAK;MACbC,SAAS,EAAER,KAAK,CAACQ,SAAS;MAC1BC,MAAM,EAAET,KAAK,CAACS,MAAM;MACpBC,IAAI,EAAEV,KAAK,CAACU,IAAI;MAChBhD,SAAS,EAAEsC;IACf,CAAC;IACD,IAAIW,sBAAsB,GAAG,SAAAA,CAAUC,IAAI,EAAE;MACzC,IAAI,CAACrC,KAAK,CAACsC,aAAa,IAAID,IAAI,CAACL,MAAM,EAAE;QACrC;MACJ;MACA,IAAIP,KAAK,CAACc,IAAI,KAAK,KAAK,IAAId,KAAK,CAACc,IAAI,KAAK,SAAS,IAAId,KAAK,CAACe,iBAAiB,CAAChD,MAAM,EAAE;QACpF,IAAIiD,KAAK,GAAGzC,KAAK,CAACb,SAAS,CAACuD,QAAQ,CAACC,WAAW,CAAC;UAAEf,EAAE,EAAE5B,KAAK,CAACb,SAAS,CAACwC,OAAO,CAACC,EAAE,GAAG;QAAyB,CAAC,CAAC;QAC/G,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnB,KAAK,CAACe,iBAAiB,CAAChD,MAAM,EAAEoD,CAAC,EAAE,EAAE;UACrD,IAAKnB,KAAK,CAACoB,YAAY,CAACC,IAAI,IAAIrB,KAAK,CAACe,iBAAiB,CAACI,CAAC,CAAC,CAACG,UAAU,IAChEtB,KAAK,CAACoB,YAAY,CAACG,IAAI,IAAIvB,KAAK,CAACe,iBAAiB,CAACI,CAAC,CAAC,CAACK,QAAS,EAAE;YAClEjD,KAAK,CAACkD,SAAS,CAACzB,KAAK,CAACe,iBAAiB,CAACI,CAAC,CAAC,EAAEH,KAAK,EAAEG,CAAC,CAAC;UACzD;QACJ;QACA5C,KAAK,CAACb,SAAS,CAACgE,SAAS,CAACC,WAAW,CAACX,KAAK,CAAC;MAChD;MACAzC,KAAK,CAAC,QAAQ,GAAGyB,KAAK,CAACc,IAAI,CAAC,CAACvC,KAAK,CAACsC,aAAa,EAAED,IAAI,CAAC;MACvDrC,KAAK,CAACqD,YAAY,CAACrD,KAAK,CAACsC,aAAa,CAAC;MACvCtC,KAAK,CAACsD,WAAW,CAACtD,KAAK,CAACsC,aAAa,CAAC;IAC1C,CAAC;IACDF,sBAAsB,CAACmB,IAAI,CAAC,IAAI,CAAC;IACjC9B,KAAK,CAAC+B,OAAO,CAAC,iBAAiB,EAAE1B,QAAQ,EAAEM,sBAAsB,CAAC;EACtE,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIlD,iBAAiB,CAACE,SAAS,CAAC8D,SAAS,GAAG,UAAUV,iBAAiB,EAAEC,KAAK,EAAEgB,KAAK,EAAE;IAC/E,IAAIC,KAAK,GAAG,IAAI,CAACvE,SAAS;IAC1B,IAAIwE,MAAM,GAAID,KAAK,CAACE,aAAa,CAACD,MAAM,GAAID,KAAK,CAACG,OAAO,CAACC,GAAG,GAAG,CAAC;IACjE,IAAIC,KAAK,GAAIL,KAAK,CAACE,aAAa,CAACG,KAAK,GAAIL,KAAK,CAACG,OAAO,CAACG,IAAI,GAAG,CAAC;IAChE,IAAIC,OAAO,GAAGzB,iBAAiB,CAACO,UAAU;IAC1C,IAAImB,OAAO,GAAG1B,iBAAiB,CAACS,QAAQ;IACxC,IAAIkB,QAAQ,GAAIR,MAAM,GAAKA,MAAM,GAAG,IAAI,CAACS,KAAK,IAAKH,OAAO,GAAG,IAAI,CAACI,GAAG,CAAE,GAAIX,KAAK,CAACG,OAAO,CAACC,GAAG;IAC5F,IAAIQ,QAAQ,GAAIX,MAAM,GAAKA,MAAM,GAAG,IAAI,CAACS,KAAK,IAAKF,OAAO,GAAG,IAAI,CAACG,GAAG,CAAE,GAAIX,KAAK,CAACG,OAAO,CAACC,GAAG;IAC5F,IAAIS,KAAK,GAAG/B,iBAAiB,CAAC+B,KAAK,IAAI,IAAI,CAACpF,SAAS,CAACqF,UAAU,CAACC,cAAc;IAC/E,IAAIH,QAAQ,GAAIX,MAAM,GAAGD,KAAK,CAACG,OAAO,CAACC,GAAI,EAAE;MACzCQ,QAAQ,GAAIX,MAAM,GAAGD,KAAK,CAACG,OAAO,CAACC,GAAI;IAC3C,CAAC,MACI,IAAIQ,QAAQ,GAAI,CAAC,GAAGZ,KAAK,CAACG,OAAO,CAACC,GAAI,EAAE;MACzCQ,QAAQ,GAAI,CAAC,GAAGZ,KAAK,CAACG,OAAO,CAACC,GAAI;IACtC;IACA,IAAIK,QAAQ,GAAIR,MAAM,GAAGD,KAAK,CAACG,OAAO,CAACC,GAAI,EAAE;MACzCK,QAAQ,GAAIR,MAAM,GAAGD,KAAK,CAACG,OAAO,CAACC,GAAI;IAC3C,CAAC,MACI,IAAIK,QAAQ,GAAI,CAAC,GAAGT,KAAK,CAACG,OAAO,CAACC,GAAI,EAAE;MACzCK,QAAQ,GAAI,CAAC,GAAGT,KAAK,CAACG,OAAO,CAACC,GAAI;IACtC;IACA,IAAIY,IAAI,GAAG,IAAI,GAAIhB,KAAK,CAACG,OAAO,CAACG,IAAK,GAAG,GAAG,GAAGG,QAAQ,GAAG,KAAK,IAAIJ,KAAK,GAAIL,KAAK,CAACG,OAAO,CAACG,IAAK,CAAC,GAAG,GAAG,GAAGG,QAAQ,GAC7G,KAAK,IAAIJ,KAAK,GAAIL,KAAK,CAACG,OAAO,CAACG,IAAK,CAAC,GAAG,GAAG,GAAGM,QAAQ,GAAG,KAAK,GAAIZ,KAAK,CAACG,OAAO,CAACG,IAAK,GAAG,GAAG,GAAGM,QAAQ,GAAG,KAAK;IACnH,IAAIK,UAAU,GAAG;MACb,IAAI,EAAEjB,KAAK,CAAC/B,OAAO,CAACC,EAAE,GAAG,aAAa,GAAG6B,KAAK;MAC9C,MAAM,EAAEc,KAAK;MACb,SAAS,EAAE/B,iBAAiB,CAACoC,OAAO;MACpC,QAAQ,EAAE,aAAa;MACvB,cAAc,EAAElB,KAAK,CAACzB,SAAS;MAC/B,GAAG,EAAEyC,IAAI;MACT,kBAAkB,EAAE;IACxB,CAAC;IACDpG,QAAQ,CAAC,IAAI,CAACa,SAAS,EAAEwF,UAAU,EAAElC,KAAK,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIvD,iBAAiB,CAACE,SAAS,CAACyF,UAAU,GAAG,UAAUC,MAAM,EAAEzC,IAAI,EAAE;IAC7D,IAAIZ,KAAK,GAAG,IAAI,CAACtC,SAAS;IAC1B,IAAI4F,CAAC,GAAG,IAAI,CAAC5F,SAAS,CAACuD,QAAQ,CAACC,WAAW,CAAC;MACxCf,EAAE,EAAEH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,cAAc;MACrC,WAAW,EAAE,OAAO,GAAG,IAAI,CAACF,MAAM,GAAG;IACzC,CAAC,CAAC;IACF,IAAI6C,KAAK,GAAG,IAAI,CAACpF,SAAS,CAACgD,IAAI;IAC/BoC,KAAK,GAAI,IAAI,CAACpF,SAAS,CAACgD,IAAI,KAAK,SAAS,IAAI,IAAI,CAAChD,SAAS,CAAC6F,KAAK,KAAK,YAAY,GAC7E,IAAI,CAAC7F,SAAS,CAACqF,UAAU,CAACS,aAAa,GAAGV,KAAK;IACrD,IAAII,UAAU,GAAG,IAAItG,UAAU,CAACoD,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,iBAAiB,EAAE,aAAa,EAAES,IAAI,CAACJ,SAAS,EAAEsC,KAAK,EAAE9C,KAAK,CAACmD,OAAO,CAAC;IAC1H,IAAIM,CAAC,GAAG,EAAE;IACV,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEuC,GAAG,GAAGL,MAAM,CAACtF,MAAM,EAAEoD,CAAC,GAAGuC,GAAG,EAAEvC,CAAC,EAAE,EAAE;MAC/C,IAAIA,CAAC,KAAK,CAAC,EAAE;QACTsC,CAAC,GAAG,IAAI,GAAGJ,MAAM,CAAC,CAAC,CAAC,CAACnE,CAAC,GAAG,GAAG,GAAGmE,MAAM,CAAClC,CAAC,CAAC,CAAChC,CAAC,GAAG,GAAG;MACpD;MACAsE,CAAC,IAAI,IAAI,GAAGJ,MAAM,CAAClC,CAAC,CAAC,CAACjC,CAAC,GAAG,GAAG,GAAGmE,MAAM,CAAClC,CAAC,CAAC,CAAChC,CAAC,GAAG,GAAG;IACrD;IACA+D,UAAU,CAACO,CAAC,GAAGA,CAAC;IAChBP,UAAU,CAAC,YAAY,CAAC,GAAG,kBAAkB,GAAGG,MAAM,CAACtF,MAAM,GAAG,aAAa;IAC7ElB,QAAQ,CAAC,IAAI,CAACa,SAAS,EAAEwF,UAAU,EAAEI,CAAC,CAAC;IACvC,IAAI,CAAC5F,SAAS,CAACgE,SAAS,CAACC,WAAW,CAAC2B,CAAC,CAAC;EAC3C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACI7F,iBAAiB,CAACE,SAAS,CAACgG,SAAS,GAAG,UAAUN,MAAM,EAAEzC,IAAI,EAAE;IAC5D,IAAIZ,KAAK,GAAG,IAAI,CAACtC,SAAS;IAC1B,IAAIwE,MAAM,GAAGlC,KAAK,CAACmC,aAAa,CAACD,MAAM,IAAIlC,KAAK,CAACoC,OAAO,CAACC,GAAG,GAAGrC,KAAK,CAACoC,OAAO,CAACwB,MAAM,CAAC;IACpF,IAAItB,KAAK,GAAGtC,KAAK,CAACmC,aAAa,CAACG,KAAK,IAAItC,KAAK,CAACoC,OAAO,CAACG,IAAI,GAAGvC,KAAK,CAACoC,OAAO,CAACyB,KAAK,CAAC;IAClF,IAAIC,IAAI,GAAI5B,MAAM,IAAII,KAAK,GAAIJ,MAAM,GAAG,CAAC,GAAGI,KAAK,GAAG,CAAC;IACrD,IAAIyB,CAAC,GAAG/D,KAAK,CAACmC,aAAa,CAACG,KAAK,GAAG,CAAC,CAAC,CAAC;IACvC,IAAI0B,CAAC,GAAGhE,KAAK,CAACmC,aAAa,CAACD,MAAM,GAAG,CAAC,CAAC,CAAC;IACxC,IAAI+B,GAAG,GAAG,CAAC;IACX,IAAIC,KAAK;IACT,IAAIC,KAAK;IACT,IAAIC,MAAM,GAAGxD,IAAI,CAACH,MAAM,CAACqC,KAAK;IAC9B,IAAIK,OAAO,GAAGnD,KAAK,CAACmD,OAAO;IAC3B,IAAIkB,WAAW,GAAGzD,IAAI,CAACH,MAAM,CAAC6B,KAAK;IACnC,IAAIgC,MAAM,GAAItE,KAAK,CAACuE,OAAO,CAACxG,MAAM,GAAIiC,KAAK,CAACuE,OAAO,GAAGpH,cAAc,CAAC,IAAI,CAACO,SAAS,CAAC6F,KAAK,CAAC;IAC1F,IAAIvC,KAAK,GAAG,IAAI,CAACtD,SAAS,CAACuD,QAAQ,CAACC,WAAW,CAAC;MAAEf,EAAE,EAAEH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG;IAAe,CAAC,CAAC;IAC1F,IAAIqE,GAAG;IACP,IAAIC,IAAI;IACR,IAAIC,SAAS,GAAGhI,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE2G,MAAM,CAAC;IACtC,IAAIrD,KAAK,CAAC2E,cAAc,IAAI3E,KAAK,CAAC4E,aAAa,EAAE;MAC7C,IAAIC,aAAa,GAAGH,SAAS,CAACI,GAAG,CAAC,UAAUC,CAAC,EAAE;QAAE,OAAOA,CAAC,CAACC,IAAI;MAAE,CAAC,CAAC;MAClER,GAAG,GAAGS,IAAI,CAACrC,GAAG,CAACsC,KAAK,CAAC,IAAI,EAAEL,aAAa,CAAC;MACzCJ,IAAI,GAAGQ,IAAI,CAACE,GAAG,CAACD,KAAK,CAAC,IAAI,EAAEL,aAAa,CAAC;IAC9C;IACA,IAAI,CAACO,oBAAoB,GAAG,EAAE;IAC9B,KAAK,IAAIjE,CAAC,GAAG,CAAC,EAAEkE,KAAK,GAAG,EAAE,EAAEC,KAAK,GAAG,KAAK,CAAC,EAAEC,IAAI,GAAG,KAAK,CAAC,EAAEpE,CAAC,GAAGkC,MAAM,CAACtF,MAAM,EAAEoD,CAAC,EAAE,EAAE;MAC/EkE,KAAK,IAAIpB,GAAG;MACZA,GAAG,GAAGZ,MAAM,CAAClC,CAAC,CAAC,CAAC,QAAQ,CAAC;MACzB8C,GAAG,GAAIA,GAAG,KAAK,GAAG,GAAGA,GAAG,GAAG,KAAK,GAAGA,GAAI;MACvCqB,KAAK,GAAGD,KAAK,GAAGpB,GAAG;MACnBC,KAAK,GAAG,CAACmB,KAAK,GAAG,EAAE,IAAIJ,IAAI,CAACO,EAAE,GAAG,KAAK;MACtCrB,KAAK,GAAG,CAACmB,KAAK,GAAG,EAAE,IAAIL,IAAI,CAACO,EAAE,GAAG,KAAK;MACtCnC,MAAM,CAAClC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG+C,KAAK;MAC1Bb,MAAM,CAAClC,CAAC,CAAC,CAAC,QAAQ,CAAC,GAAGgD,KAAK;MAC3BoB,IAAI,GAAItB,GAAG,GAAG,GAAG,GAAI,GAAG,GAAG,GAAG;MAC9B,IAAI3E,IAAI,GAAG+D,MAAM,CAAClC,CAAC,CAAC,CAAC,aAAa,CAAC,GAAG;QAClCsE,EAAE,EAAE1B,CAAC,GAAID,IAAI,GAAGmB,IAAI,CAACS,GAAG,CAACxB,KAAK,CAAE;QAAEyB,EAAE,EAAE3B,CAAC,GAClCF,IAAI,GAAGmB,IAAI,CAACW,GAAG,CAAC1B,KAAK,CAAE;QAAE2B,EAAE,EAAE9B,CAAC,GAAID,IAAI,GAAGmB,IAAI,CAACS,GAAG,CAACvB,KAAK,CAAE;QAAE2B,EAAE,EAAE9B,CAAC,GAAIF,IAAI,GAAGmB,IAAI,CAACW,GAAG,CAACzB,KAAK;MAClG,CAAC;MACD,IAAI4B,OAAO,GAAG,IAAI,GAAGhC,CAAC,GAAG,GAAG,GAAGC,CAAC,GAAG,KAAK,GAAG1E,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,GAAGA,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,GAAGwE,IAAI,GAAG,GAAG,GACzFA,IAAI,GAAG,KAAK,GAAGyB,IAAI,GAAG,KAAK,GAAGjG,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG,GAAGA,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI;MACtE,IAAI4D,UAAU,GAAG;QACb,IAAI,EAAElD,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,iBAAiB,GAAGgB,CAAC;QAC9C,SAAS,EAAEgC,OAAO;QAClB,MAAM,EAAEmB,MAAM,CAACnD,CAAC,GAAGmD,MAAM,CAACvG,MAAM,CAAC;QACjC,QAAQ,EAAEqG,MAAM;QAChB,cAAc,EAAEC,WAAW;QAC3B,GAAG,EAAE0B,OAAO;QACZ,kBAAkB,EAAE;MACxB,CAAC;MACD,IAAI,CAACC,kBAAkB,CAAC3C,MAAM,CAAClC,CAAC,CAAC,EAAEnB,KAAK,EAAEkD,UAAU,EAAE/B,CAAC,EAAEsD,IAAI,EAAED,GAAG,EAAEnB,MAAM,CAACtF,MAAM,CAAC;MAClF,IAAIkI,SAAS,GAAG,IAAI,CAACC,kBAAkB,CAAC,gBAAgB,EAAE/E,CAAC,EAAE+B,UAAU,CAACxC,IAAI,EAAE;QAAEoC,KAAK,EAAEsB,MAAM;QAAE9B,KAAK,EAAE+B;MAAY,CAAC,CAAC;MACpHnB,UAAU,CAACxC,IAAI,GAAGuF,SAAS,CAACvF,IAAI;MAChCwC,UAAU,CAACkB,MAAM,GAAG6B,SAAS,CAACxF,MAAM,CAACqC,KAAK;MAC1CI,UAAU,CAAC,cAAc,CAAC,GAAG+C,SAAS,CAACxF,MAAM,CAAC6B,KAAK;MACnD,IAAI,CAAC2D,SAAS,CAAC1F,MAAM,EAAE;QACnB,IAAIL,OAAO,GAAGrD,QAAQ,CAAC,IAAI,CAACa,SAAS,EAAEwF,UAAU,EAAElC,KAAK,CAAC;QACzDd,OAAO,CAACiG,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC;QACnCjG,OAAO,CAACiG,YAAY,CAAC,YAAY,EAAEnG,KAAK,CAAClC,UAAU,CAACqD,CAAC,CAAC,CAACnB,KAAK,CAACZ,KAAK,CAAC,GAAG,KAAK,GAAGiE,MAAM,CAAClC,CAAC,CAAC,CAAC6D,IAAI,CAAC;QAC7F9E,OAAO,CAACiG,YAAY,CAAC,UAAU,EAAEhF,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC;MAC1D;MACA,IAAIiF,UAAU,GAAGjC,KAAK,GAAGD,KAAK;MAC9B,IAAImC,GAAG,GAAG;QACNnH,CAAC,EAAE6E,CAAC,GAAKD,IAAI,GAAG,CAAC,GAAImB,IAAI,CAACS,GAAG,CAACxB,KAAK,GAAIkC,UAAU,GAAG,CAAE,CAAE;QACxDjH,CAAC,EAAE6E,CAAC,GAAKF,IAAI,GAAG,CAAC,GAAImB,IAAI,CAACW,GAAG,CAAC1B,KAAK,GAAIkC,UAAU,GAAG,CAAE;MAC1D,CAAC;MACD/C,MAAM,CAAClC,CAAC,CAAC,CAACmF,QAAQ,CAACpH,CAAC,GAAGmH,GAAG,CAACnH,CAAC;MAC5BmE,MAAM,CAAClC,CAAC,CAAC,CAACmF,QAAQ,CAACnH,CAAC,GAAGkH,GAAG,CAAClH,CAAC;IAChC;IACA,IAAI,CAACzB,SAAS,CAACgE,SAAS,CAACC,WAAW,CAACX,KAAK,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIvD,iBAAiB,CAACE,SAAS,CAACqI,kBAAkB,GAAG,UAAU1G,IAAI,EAAEU,KAAK,EAAEuG,MAAM,EAAEpF,CAAC,EAAEsD,IAAI,EAAED,GAAG,EAAEzG,MAAM,EAAE;IAClG,IAAIuB,IAAI,CAAC0F,IAAI,GAAG,CAAC,IAAIhF,KAAK,CAACwG,kBAAkB,EAAE;MAC3CD,MAAM,CAAC7F,IAAI,GAAGV,KAAK,CAACwG,kBAAkB;MACtC,IAAI,CAACpB,oBAAoB,CAACzF,IAAI,CAACwB,CAAC,CAAC;IACrC;IACA,IAAIA,CAAC,KAAK,CAAC,IAAInB,KAAK,CAACyG,eAAe,EAAE;MAClCF,MAAM,CAAC7F,IAAI,GAAGV,KAAK,CAACyG,eAAe;MACnC,IAAI,CAACC,eAAe,GAAGvF,CAAC;IAC5B,CAAC,MACI,IAAKA,CAAC,KAAMpD,MAAM,GAAG,CAAE,IAAKiC,KAAK,CAAC2G,aAAa,EAAE;MAClDJ,MAAM,CAAC7F,IAAI,GAAGV,KAAK,CAAC2G,aAAa;MACjC,IAAI,CAACC,aAAa,GAAGzF,CAAC;IAC1B;IACA,IAAI7B,IAAI,CAAC0F,IAAI,KAAKP,IAAI,IAAIzE,KAAK,CAAC2E,cAAc,EAAE;MAC5C4B,MAAM,CAAC7F,IAAI,GAAGV,KAAK,CAAC2E,cAAc;MAClC,IAAI,CAACkC,cAAc,GAAG1F,CAAC;IAC3B,CAAC,MACI,IAAI7B,IAAI,CAAC0F,IAAI,KAAKR,GAAG,IAAIxE,KAAK,CAAC4E,aAAa,EAAE;MAC/C2B,MAAM,CAAC7F,IAAI,GAAGV,KAAK,CAAC4E,aAAa;MACjC,IAAI,CAACkC,aAAa,GAAG3F,CAAC;IAC1B;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACI1D,iBAAiB,CAACE,SAAS,CAACoJ,UAAU,GAAG,UAAU1D,MAAM,EAAEzC,IAAI,EAAE;IAC7D,IAAIZ,KAAK,GAAG,IAAI,CAACtC,SAAS;IAC1B,IAAIsD,KAAK,GAAG,IAAI,CAACtD,SAAS,CAACuD,QAAQ,CAACC,WAAW,CAAC;MAC5Cf,EAAE,EAAEH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,cAAc;MACrC,WAAW,EAAE,OAAO,GAAG,IAAI,CAACF,MAAM,GAAG;IACzC,CAAC,CAAC;IACF,IAAIiD,UAAU,GAAG,IAAItG,UAAU,CAACoD,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,iBAAiB,EAAES,IAAI,CAACF,IAAI,EAAE,CAAC,EAAE,aAAa,EAAEV,KAAK,CAACmD,OAAO,CAAC;IACjH,IAAIM,CAAC,GAAG,EAAE;IACV,IAAIuD,GAAG,GAAG,EAAE;IACZ,KAAK,IAAI7F,CAAC,GAAG,CAAC,EAAEuC,GAAG,GAAGL,MAAM,CAACtF,MAAM,EAAEoD,CAAC,GAAGuC,GAAG,EAAEvC,CAAC,EAAE,EAAE;MAC/C,IAAIA,CAAC,KAAK,CAAC,EAAE;QACT6F,GAAG,IAAI,IAAI,GAAG3D,MAAM,CAAClC,CAAC,CAAC,CAACjC,CAAC,GAAG,GAAG,GAAGmE,MAAM,CAAClC,CAAC,CAAC,CAAChC,CAAC,GAAG,GAAG;MACvD,CAAC,MACI;QACDsE,CAAC,GAAG,IAAI,GAAGJ,MAAM,CAAClC,CAAC,CAAC,CAACjC,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC+H,UAAU,GAAG,GAAG;QACpDD,GAAG,GAAG,IAAI,GAAG3D,MAAM,CAAClC,CAAC,CAAC,CAACjC,CAAC,GAAG,GAAG,GAAGmE,MAAM,CAAClC,CAAC,CAAC,CAAChC,CAAC,GAAG,GAAG;MACtD;MACAsE,CAAC,IAAI,IAAI,GAAGJ,MAAM,CAAClC,CAAC,CAAC,CAACjC,CAAC,GAAG,GAAG,GAAGmE,MAAM,CAAClC,CAAC,CAAC,CAAChC,CAAC,GAAG,GAAG;MACjD,IAAIgC,CAAC,KAAMuC,GAAG,GAAG,CAAE,EAAE;QACjBD,CAAC,IAAI,IAAI,GAAGJ,MAAM,CAAClC,CAAC,CAAC,CAACjC,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC+H,UAAU,GAAG,IAAI;MAC1D;IACJ;IACA/D,UAAU,CAACO,CAAC,GAAGA,CAAC;IAChBP,UAAU,CAAC,YAAY,CAAC,GAAG,kBAAkB,GAAGG,MAAM,CAACtF,MAAM,GAAG,aAAa;IAC7ElB,QAAQ,CAAC,IAAI,CAACa,SAAS,EAAEwF,UAAU,EAAElC,KAAK,CAAC;IAC3CkC,UAAU,GAAG,IAAItG,UAAU,CAACoD,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,qBAAqB,EAAE,aAAa,EAAES,IAAI,CAACH,MAAM,CAAC6B,KAAK,EAAE1B,IAAI,CAACH,MAAM,CAACqC,KAAK,EAAE9C,KAAK,CAACmD,OAAO,EAAE,EAAE,EAAE6D,GAAG,CAAC;IAClJnK,QAAQ,CAAC,IAAI,CAACa,SAAS,EAAEwF,UAAU,EAAElC,KAAK,CAAC;IAC3C,IAAI,CAACtD,SAAS,CAACgE,SAAS,CAACC,WAAW,CAACX,KAAK,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIvD,iBAAiB,CAACE,SAAS,CAACuJ,YAAY,GAAG,UAAU7D,MAAM,EAAEzC,IAAI,EAAE;IAC/D,IAAIrC,KAAK,GAAG,IAAI;IAChB,IAAIyB,KAAK,GAAG,IAAI,CAACtC,SAAS;IAC1B,IAAIgH,SAAS,GAAGhI,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE2G,MAAM,CAAC;IACtC,IAAIrC,KAAK,GAAG,IAAI,CAACtD,SAAS,CAACuD,QAAQ,CAACC,WAAW,CAAC;MAC5Cf,EAAE,EAAEH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,cAAc;MACrC,WAAW,EAAE,OAAO,GAAG,IAAI,CAACF,MAAM,GAAG;IACzC,CAAC,CAAC;IACF,IAAIkH,MAAM;IACV,IAAIC,OAAO;IACX,IAAI,IAAI,CAAC1J,SAAS,CAACiH,cAAc,IAAI,IAAI,CAACjH,SAAS,CAACkH,aAAa,EAAE;MAC/D,IAAIyC,UAAU,GAAG3C,SAAS,CAACI,GAAG,CAAC,UAAUC,CAAC,EAAE;QAAE,OAAOA,CAAC,CAACuC,cAAc;MAAE,CAAC,CAAC;MACzEF,OAAO,GAAGnC,IAAI,CAACrC,GAAG,CAACsC,KAAK,CAAC,IAAI,EAAEmC,UAAU,CAAC;MAC1CF,MAAM,GAAGlC,IAAI,CAACE,GAAG,CAACD,KAAK,CAAC,IAAI,EAAEmC,UAAU,CAAC;IAC7C;IACA,IAAIlH,EAAE,GAAGH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,oBAAoB;IAChD,IAAIoH,WAAW,GAAG,IAAIxK,UAAU,CAACoD,EAAE,EAAE,EAAE,EAAES,IAAI,CAACH,MAAM,EAAET,KAAK,CAACmD,OAAO,EAAE,IAAI,CAAC;IAC1E,IAAI7D,IAAI;IACR,IAAIoE,GAAG,GAAGL,MAAM,CAACtF,MAAM;IACvB,IAAI,CAACqH,oBAAoB,GAAG,EAAE;IAC9B,IAAId,MAAM,GAAItE,KAAK,CAACuE,OAAO,CAACxG,MAAM,GAAIiC,KAAK,CAACuE,OAAO,GAAGpH,cAAc,CAAC,IAAI,CAACO,SAAS,CAAC6F,KAAK,CAAC;IAC1F,IAAIiE,OAAO,GAAG,SAAAA,CAAUrG,CAAC,EAAE;MACvB7B,IAAI,GAAG+D,MAAM,CAAClC,CAAC,CAAC;MAChBoG,WAAW,CAACpH,EAAE,GAAGA,EAAE,GAAGgB,CAAC;MACvBoG,WAAW,CAAC7G,IAAI,GAAGV,KAAK,CAACU,IAAI,KAAK,SAAS,GAAGV,KAAK,CAACU,IAAI,GAAG4D,MAAM,CAAC,CAAC,CAAC;MACpEiD,WAAW,CAACE,IAAI,GAAG,IAAIzK,IAAI,CAACsC,IAAI,CAACJ,CAAC,EAAEI,IAAI,CAACH,CAAC,EAAEG,IAAI,CAACgD,KAAK,EAAEhD,IAAI,CAAC4C,MAAM,CAAC;MACpEwF,MAAM,CAACC,eAAe,CAAC,IAAI,EAAErI,IAAI,EAAEU,KAAK,EAAEuH,WAAW,EAAEpG,CAAC,EAAEiG,OAAO,EAAED,MAAM,EAAEzD,GAAG,CAAC;MAC/EpE,IAAI,CAACgH,QAAQ,CAACnH,CAAC,GAAIG,IAAI,CAACgI,cAAc,IAAII,MAAM,CAACT,UAAU,GAAI3H,IAAI,CAACH,CAAC,GAAIG,IAAI,CAACH,CAAC,GAAGG,IAAI,CAAC4C,MAAO;MAC9F5C,IAAI,CAACgH,QAAQ,CAACpH,CAAC,GAAGI,IAAI,CAACJ,CAAC,GAAII,IAAI,CAACgD,KAAK,GAAG,CAAE;MAC3CiF,WAAW,CAACnD,MAAM,GAAGxD,IAAI,CAACH,MAAM,CAACqC,KAAK,GAAIlC,IAAI,CAACH,MAAM,CAACqC,KAAK,GAAIyE,WAAW,CAAC7G,IAAI;MAC/E,IAAIuF,SAAS,GAAG;QACZ3F,IAAI,EAAE,gBAAgB;QAAEC,MAAM,EAAE,KAAK;QAAEqH,UAAU,EAAEzG,CAAC;QAAET,IAAI,EAAE6G,WAAW,CAAC7G,IAAI;QAC5ED,MAAM,EAAE;UAAEqC,KAAK,EAAEyE,WAAW,CAACnD,MAAM;UAAE9B,KAAK,EAAE1B,IAAI,CAACH,MAAM,CAAC6B;QAAM;MAClE,CAAC;MACDoF,MAAM,CAAChK,SAAS,CAACqE,OAAO,CAAC,gBAAgB,EAAEkE,SAAS,EAAE,YAAY;QAC9D3G,IAAI,GAAG+D,MAAM,CAAClC,CAAC,CAAC;QAChBoG,WAAW,CAACpH,EAAE,GAAGA,EAAE,GAAGgB,CAAC;QACvBoG,WAAW,CAACE,IAAI,GAAG,IAAIzK,IAAI,CAACsC,IAAI,CAACJ,CAAC,EAAEI,IAAI,CAACH,CAAC,EAAEG,IAAI,CAACgD,KAAK,EAAEhD,IAAI,CAAC4C,MAAM,CAAC;QACpE3D,KAAK,CAACoJ,eAAe,CAAC,IAAI,EAAErI,IAAI,EAAEU,KAAK,EAAEuH,WAAW,EAAEpG,CAAC,EAAEiG,OAAO,EAAED,MAAM,EAAEzD,GAAG,CAAC;QAC9E6D,WAAW,CAAC7G,IAAI,GAAGuF,SAAS,CAACvF,IAAI;QACjC6G,WAAW,CAACnD,MAAM,GAAG6B,SAAS,CAACxF,MAAM,CAACqC,KAAK;QAC3CxD,IAAI,CAACgH,QAAQ,CAACnH,CAAC,GAAIG,IAAI,CAACgI,cAAc,IAAI/I,KAAK,CAAC0I,UAAU,GAAI3H,IAAI,CAACH,CAAC,GAAIG,IAAI,CAACH,CAAC,GAAGG,IAAI,CAAC4C,MAAO;QAC7FqF,WAAW,CAAC,cAAc,CAAC,GAAGtB,SAAS,CAACxF,MAAM,CAAC6B,KAAK;QACpDhD,IAAI,CAACgH,QAAQ,CAACpH,CAAC,GAAGI,IAAI,CAACJ,CAAC,GAAII,IAAI,CAACgD,KAAK,GAAG,CAAE;QAC3C,IAAI,CAAC2D,SAAS,CAAC1F,MAAM,EAAE;UACnB,IAAIL,OAAO,GAAGpD,aAAa,CAACkD,KAAK,EAAEuH,WAAW,EAAEvG,KAAK,CAAC;UACtDd,OAAO,CAACiG,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC;UACnCjG,OAAO,CAACiG,YAAY,CAAC,YAAY,EAAEnG,KAAK,CAAClC,UAAU,CAACqD,CAAC,CAAC,CAACnB,KAAK,CAACZ,KAAK,CAAC,GAAG,KAAK,GAAGiE,MAAM,CAAClC,CAAC,CAAC,CAAC6D,IAAI,CAAC;UAC7F9E,OAAO,CAACiG,YAAY,CAAC,UAAU,EAAEhF,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC;UACtDH,KAAK,CAACW,WAAW,CAACzB,OAAO,CAAC;QAC9B;MACJ,CAAC,CAAC;IACN,CAAC;IACD,IAAIwH,MAAM,GAAG,IAAI;IACjB,KAAK,IAAIvG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuC,GAAG,EAAEvC,CAAC,EAAE,EAAE;MAC1BqG,OAAO,CAACrG,CAAC,CAAC;IACd;IACA,IAAI,CAACzD,SAAS,CAACgE,SAAS,CAACC,WAAW,CAACX,KAAK,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIvD,iBAAiB,CAACE,SAAS,CAACkK,aAAa,GAAG,UAAUxE,MAAM,EAAEzC,IAAI,EAAE;IAChE,IAAIZ,KAAK,GAAG,IAAI,CAACtC,SAAS;IAC1B,IAAIsD,KAAK,GAAG,IAAI,CAACtD,SAAS,CAACuD,QAAQ,CAACC,WAAW,CAAC;MAC5Cf,EAAE,EAAEH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,cAAc;MACrC,WAAW,EAAE,OAAO,GAAG,IAAI,CAACF,MAAM,GAAG;IACzC,CAAC,CAAC;IACF,IAAIE,EAAE,GAAGH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,qBAAqB;IACjD,IAAI2H,OAAO,GAAG,IAAI/K,UAAU,CAACoD,EAAE,EAAE,EAAE,EAAES,IAAI,CAACH,MAAM,EAAET,KAAK,CAACmD,OAAO,EAAE,IAAI,CAAC;IACtE,IAAI7D,IAAI;IACR,IAAIoE,GAAG,GAAGL,MAAM,CAACtF,MAAM;IACvB,IAAIgK,aAAa,GAAG/H,KAAK,CAACuE,OAAO,CAACxG,MAAM;IACxC,IAAIuG,MAAM,GAAItE,KAAK,CAACuE,OAAO,CAACxG,MAAM,GAAIiC,KAAK,CAACuE,OAAO,GAAGpH,cAAc,CAAC,IAAI,CAACO,SAAS,CAAC6F,KAAK,CAAC;IAC1F,KAAK,IAAIpC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuC,GAAG,EAAEvC,CAAC,EAAE,EAAE;MAC1B7B,IAAI,GAAG+D,MAAM,CAAClC,CAAC,CAAC;MAChB2G,OAAO,CAAC3H,EAAE,GAAGA,EAAE,GAAGgB,CAAC;MACnB2G,OAAO,CAACpH,IAAI,GAAIqH,aAAa,GAAI/H,KAAK,CAACuE,OAAO,CAACpD,CAAC,GAAG4G,aAAa,CAAC,GAAKzI,IAAI,CAAC0F,IAAI,KAAK,IAAI,CAACgD,SAAS,GAC7F,IAAI,CAACtK,SAAS,CAACuK,aAAa,IAAI,SAAS,GAAM3I,IAAI,CAAC0F,IAAI,GAAG,IAAI,CAACgD,SAAS,GAAIpH,IAAI,CAACF,IAAI,IAAI4D,MAAM,CAACnD,CAAC,GAAGmD,MAAM,CAACvG,MAAM,CAAC,GACnHiC,KAAK,CAACwG,kBAAkB,IAAI,SAAY;MAC7CsB,OAAO,CAAC1D,MAAM,GAAIxD,IAAI,CAACH,MAAM,CAACqC,KAAK,GAAKlC,IAAI,CAACH,MAAM,CAACqC,KAAK,GAAIgF,OAAO,CAACpH,IAAI;MACzEoH,OAAO,CAACL,IAAI,GAAG,IAAIzK,IAAI,CAACsC,IAAI,CAACJ,CAAC,EAAEI,IAAI,CAACH,CAAC,EAAEG,IAAI,CAACgD,KAAK,EAAEhD,IAAI,CAAC4C,MAAM,CAAC;MAChE5C,IAAI,CAACgH,QAAQ,CAACpH,CAAC,GAAGI,IAAI,CAACJ,CAAC,GAAII,IAAI,CAACgD,KAAK,GAAG,CAAE;MAC3ChD,IAAI,CAACgH,QAAQ,CAACnH,CAAC,GAAIG,IAAI,CAAC0F,IAAI,IAAI,IAAI,CAACgD,SAAS,GAAK1I,IAAI,CAACH,CAAC,GAAKG,IAAI,CAACH,CAAC,GAAGG,IAAI,CAAC4C,MAAO;MACnF,IAAI+D,SAAS,GAAG,IAAI,CAACC,kBAAkB,CAAC,gBAAgB,EAAE/E,CAAC,EAAE2G,OAAO,CAACpH,IAAI,EAAE;QAAEoC,KAAK,EAAEgF,OAAO,CAAC1D,MAAM;QAAE9B,KAAK,EAAE1B,IAAI,CAACH,MAAM,CAAC6B;MAAM,CAAC,CAAC;MAC/HwF,OAAO,CAACpH,IAAI,GAAGuF,SAAS,CAACvF,IAAI;MAC7BoH,OAAO,CAAC1D,MAAM,GAAG6B,SAAS,CAACxF,MAAM,CAACqC,KAAK;MACvCgF,OAAO,CAAC,cAAc,CAAC,GAAG7B,SAAS,CAACxF,MAAM,CAAC6B,KAAK;MAChD,IAAI,CAAC2D,SAAS,CAAC1F,MAAM,EAAE;QACnB,IAAIL,OAAO,GAAGpD,aAAa,CAACkD,KAAK,EAAE8H,OAAO,EAAE9G,KAAK,CAAC;QAClDd,OAAO,CAACiG,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC;QACnCjG,OAAO,CAACiG,YAAY,CAAC,YAAY,EAAEnG,KAAK,CAAClC,UAAU,CAACqD,CAAC,CAAC,CAACnB,KAAK,CAACZ,KAAK,CAAC,GAAG,KAAK,GAAGiE,MAAM,CAAClC,CAAC,CAAC,CAAC6D,IAAI,CAAC;QAC7F9E,OAAO,CAACiG,YAAY,CAAC,UAAU,EAAEhF,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC;MAC1D;IACJ;IACA,IAAI,CAACzD,SAAS,CAACgE,SAAS,CAACC,WAAW,CAACX,KAAK,CAAC;EAC/C,CAAC;EACDvD,iBAAiB,CAACE,SAAS,CAACiE,YAAY,GAAG,UAAUyB,MAAM,EAAE;IACzD,IAAI9E,KAAK,GAAG,IAAI;IAChB,IAAIyB,KAAK,GAAG,IAAI,CAACtC,SAAS;IAC1B,IAAIwK,MAAM,GAAGlI,KAAK,CAACmI,cAAc;IACjC,IAAKnI,KAAK,CAACc,IAAI,KAAK,KAAK,IAAId,KAAK,CAACc,IAAI,KAAK,SAAS,IAAI,CAACoH,MAAM,CAACE,OAAO,CAACrK,MAAM,EAAG;MAC9E;IACJ;IACA,IAAI2G,SAAS,GAAGhI,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE2G,MAAM,CAAC;IACtC,IAAIrC,KAAK,GAAG,IAAI,CAACtD,SAAS,CAACuD,QAAQ,CAACC,WAAW,CAAC;MAC5Cf,EAAE,EAAEH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,qBAAqB;MAC5C,WAAW,EAAE,OAAO,GAAG,IAAI,CAACF,MAAM,GAAG;IACzC,CAAC,CAAC;IACF,IAAIX,IAAI;IACR,IAAIa,EAAE,GAAGH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,oBAAoB;IAChD,IAAIoG,MAAM,GAAG,IAAItJ,YAAY,CAAC,EAAE,EAAEiL,MAAM,CAACxH,IAAI,EAAEwH,MAAM,CAACzH,MAAM,EAAEyH,MAAM,CAAC/E,OAAO,EAAE,CAAC,EAAE,CAAC,EAAE+E,MAAM,CAACG,IAAI,GAAG,CAAC,EAAE,EAAE,CAAC;IACxG,IAAIjB,OAAO;IACX,IAAID,MAAM;IACV,IAAIiB,OAAO,GAAGF,MAAM,CAACE,OAAO,CAACE,IAAI,CAAC,CAAC;IACnC,IAAKF,OAAO,CAACG,WAAW,CAAC,CAAC,CAAC7I,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAM0I,OAAO,CAACG,WAAW,CAAC,CAAC,CAAC7I,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAE,EAAE;MAC7F,IAAI2H,UAAU,GAAG3C,SAAS,CAACI,GAAG,CAAC,UAAUC,CAAC,EAAE;QAAE,OAAOA,CAAC,CAACuC,cAAc;MAAE,CAAC,CAAC;MACzEF,OAAO,GAAGnC,IAAI,CAACrC,GAAG,CAACsC,KAAK,CAAC,IAAI,EAAEmC,UAAU,CAAC;MAC1CF,MAAM,GAAGlC,IAAI,CAACE,GAAG,CAACD,KAAK,CAAC,IAAI,EAAEmC,UAAU,CAAC;IAC7C;IACA,IAAI,CAACjC,oBAAoB,GAAG,EAAE;IAC9B,IAAIoD,OAAO,GAAG,SAAAA,CAAUrH,CAAC,EAAEsH,QAAQ,EAAE;MACjCnJ,IAAI,GAAG+D,MAAM,CAAClC,CAAC,CAAC;MAChBoF,MAAM,CAACpG,EAAE,GAAGA,EAAE,GAAGgB,CAAC;MAClBoF,MAAM,CAACmC,EAAE,GAAGpJ,IAAI,CAACgH,QAAQ,CAACpH,CAAC;MAC3BqH,MAAM,CAACoC,EAAE,GAAGrJ,IAAI,CAACgH,QAAQ,CAACnH,CAAC;MAC3BoH,MAAM,CAAC7F,IAAI,GAAGwH,MAAM,CAACxH,IAAI;MACzB,IAAIkI,MAAM,GAAIR,OAAO,CAACG,WAAW,CAAC,CAAC,CAAC7I,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAE;MACxDkJ,MAAM,GAAGC,MAAM,CAAClB,eAAe,CAACiB,MAAM,EAAEtJ,IAAI,EAAEU,KAAK,EAAEuG,MAAM,EAAEpF,CAAC,EAAEiG,OAAO,EAAED,MAAM,EAAEsB,QAAQ,EAAEL,OAAO,CAACG,WAAW,CAAC,CAAC,CAAC;MACjHhC,MAAM,CAACnC,MAAM,GAAG8D,MAAM,CAACzH,MAAM,CAACqC,KAAK,IAAIyD,MAAM,CAAC7F,IAAI;MAClD,IAAIoI,UAAU,GAAG;QACbxI,IAAI,EAAE,iBAAiB;QAAEC,MAAM,EAAE,KAAK;QACtCE,MAAM,EAAE;UAAEqC,KAAK,EAAEyD,MAAM,CAACnC,MAAM;UAAE9B,KAAK,EAAE4F,MAAM,CAACzH,MAAM,CAAC6B;QAAM,CAAC;QAC5D5B,IAAI,EAAE6F,MAAM,CAAC7F,IAAI;QAAEkH,UAAU,EAAEzG,CAAC;QAChCzD,SAAS,EAAEmL,MAAM,CAACnL,SAAS;QAC3BwB,CAAC,EAAEqH,MAAM,CAACmC,EAAE;QAAEvJ,CAAC,EAAEoH,MAAM,CAACoC,EAAE;QAAEN,IAAI,EAAEH,MAAM,CAACG;MAC7C,CAAC;MACDQ,MAAM,CAACnL,SAAS,CAACqE,OAAO,CAAC,iBAAiB,EAAE+G,UAAU,EAAE,YAAY;QAChE,IAAIF,MAAM,IAAI,CAACE,UAAU,CAACvI,MAAM,EAAE;UAC9BgG,MAAM,CAACpG,EAAE,GAAGA,EAAE,GAAGgB,CAAC;UAClBoF,MAAM,CAACmC,EAAE,GAAGI,UAAU,CAAC5J,CAAC;UACxBqH,MAAM,CAACoC,EAAE,GAAGG,UAAU,CAAC3J,CAAC;UACxBoH,MAAM,CAAC7F,IAAI,GAAGoI,UAAU,CAACpI,IAAI;UAC7B6F,MAAM,CAACnC,MAAM,GAAG0E,UAAU,CAACrI,MAAM,CAACqC,KAAK;UACvCyD,MAAM,CAAC,cAAc,CAAC,GAAGuC,UAAU,CAACrI,MAAM,CAAC6B,KAAK;UAChDiE,MAAM,CAACwC,CAAC,GAAGD,UAAU,CAACT,IAAI,GAAG,CAAC;UAC9B,IAAInI,OAAO,GAAGhD,UAAU,CAAC8C,KAAK,EAAEuG,MAAM,EAAEvF,KAAK,CAAC;UAC9Cd,OAAO,CAACiG,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC;UACnCjG,OAAO,CAACiG,YAAY,CAAC,YAAY,EAAEnG,KAAK,CAAClC,UAAU,CAACqD,CAAC,CAAC,CAACnB,KAAK,CAACZ,KAAK,CAAC,GAAG,KAAK,GAAGiE,MAAM,CAAClC,CAAC,CAAC,CAAC6D,IAAI,CAAC;UAC7F,IAAKzG,KAAK,CAACb,SAAS,CAACoD,IAAI,CAACpB,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAMnB,KAAK,CAACb,SAAS,CAACoD,IAAI,CAACpB,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAE,EAAE;YAC5FQ,OAAO,CAACiG,YAAY,CAAC,UAAU,EAAEhF,CAAC,KAAK,CAAC,GAAG,GAAG,GAAG,IAAI,CAAC;UAC1D;UACAH,KAAK,CAACW,WAAW,CAACzB,OAAO,CAAC;QAC9B;MACJ,CAAC,CAAC;IACN,CAAC;IACD,IAAI2I,MAAM,GAAG,IAAI;IACjB,KAAK,IAAI1H,CAAC,GAAG,CAAC,EAAEsH,QAAQ,GAAGpF,MAAM,CAACtF,MAAM,EAAEoD,CAAC,GAAGsH,QAAQ,EAAEtH,CAAC,EAAE,EAAE;MACzDqH,OAAO,CAACrH,CAAC,EAAEsH,QAAQ,CAAC;IACxB;IACA,IAAI,CAAC/K,SAAS,CAACgE,SAAS,CAACC,WAAW,CAACX,KAAK,CAAC;EAC/C,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIvD,iBAAiB,CAACE,SAAS,CAACgK,eAAe,GAAG,UAAUiB,MAAM,EAAEtJ,IAAI,EAAEU,KAAK,EAAEuG,MAAM,EAAEpF,CAAC,EAAEiG,OAAO,EAAED,MAAM,EAAEpJ,MAAM,EAAEqK,OAAO,EAAE;IACtH,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;MAAEA,OAAO,GAAG,EAAE;IAAE;IACxC,IAAI9I,IAAI,CAACgI,cAAc,GAAG,IAAI,CAACL,UAAU,EAAE;MACvCV,MAAM,CAAC7F,IAAI,GAAGV,KAAK,CAACwG,kBAAkB,IAAID,MAAM,CAAC7F,IAAI;MACrD,IAAI,CAAC0E,oBAAoB,CAACzF,IAAI,CAACwB,CAAC,CAAC;MACjCyH,MAAM,GAAGA,MAAM,IAAKR,OAAO,CAAC1I,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAE;IACzD;IACA,IAAIyB,CAAC,KAAK,CAAC,EAAE;MACToF,MAAM,CAAC7F,IAAI,GAAGV,KAAK,CAACyG,eAAe,IAAIF,MAAM,CAAC7F,IAAI;MAClD,IAAI,CAACgG,eAAe,GAAGvF,CAAC;MACxByH,MAAM,GAAGA,MAAM,IAAKR,OAAO,CAAC1I,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAE;IACtD,CAAC,MACI,IAAKyB,CAAC,KAAMpD,MAAM,GAAG,CAAE,EAAG;MAC3BwI,MAAM,CAAC7F,IAAI,GAAGV,KAAK,CAAC2G,aAAa,IAAIJ,MAAM,CAAC7F,IAAI;MAChD,IAAI,CAACkG,aAAa,GAAGzF,CAAC;MACtByH,MAAM,GAAGA,MAAM,IAAKR,OAAO,CAAC1I,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAE;IACpD;IACA,IAAIJ,IAAI,CAACgI,cAAc,KAAKF,OAAO,EAAE;MACjCb,MAAM,CAAC7F,IAAI,GAAGV,KAAK,CAAC2E,cAAc,IAAI4B,MAAM,CAAC7F,IAAI;MACjD,IAAI,CAACmG,cAAc,GAAG1F,CAAC;MACvByH,MAAM,GAAGA,MAAM,IAAKR,OAAO,CAAC1I,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAE;IACrD,CAAC,MACI,IAAIJ,IAAI,CAACgI,cAAc,KAAKH,MAAM,EAAE;MACrCZ,MAAM,CAAC7F,IAAI,GAAGV,KAAK,CAAC4E,aAAa,IAAI2B,MAAM,CAAC7F,IAAI;MAChD,IAAI,CAACoG,aAAa,GAAG3F,CAAC;MACtByH,MAAM,GAAGA,MAAM,IAAKR,OAAO,CAAC1I,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAE;IACpD;IACA,IAAI0I,OAAO,CAAC1I,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE;MAC9BkJ,MAAM,GAAG,KAAK;IAClB;IACA,OAAOA,MAAM;EACjB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACInL,iBAAiB,CAACE,SAAS,CAACkE,WAAW,GAAG,UAAUwB,MAAM,EAAE;IACxD,IAAI9E,KAAK,GAAG,IAAI;IAChB,IAAIyB,KAAK,GAAG,IAAI,CAACtC,SAAS;IAC1B,IAAIsL,SAAS,GAAGhJ,KAAK,CAACiJ,iBAAiB;IACvC,IAAInG,KAAK,GAAGkG,SAAS,CAACE,SAAS,CAACpG,KAAK,IAAI9C,KAAK,CAAC+C,UAAU,CAACoG,cAAc;IACxE,IAAKnJ,KAAK,CAACc,IAAI,KAAK,SAAS,IAAI,CAACkI,SAAS,CAACZ,OAAO,CAACrK,MAAM,EAAG;MACzD;IACJ;IACA,IAAI2G,SAAS,GAAGhI,MAAM,CAAC,EAAE,EAAE,EAAE,EAAE2G,MAAM,CAAC;IACtC,IAAIlD,EAAE,GAAGH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,mBAAmB;IAC/C,IAAIa,KAAK,GAAG,IAAI,CAACtD,SAAS,CAACuD,QAAQ,CAACC,WAAW,CAAC;MAC5Cf,EAAE,EAAEH,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,oBAAoB;MAC3CiJ,KAAK,EAAE;IACX,CAAC,CAAC;IACFpI,KAAK,CAACmF,YAAY,CAAC,aAAa,EAAE,MAAM,CAAC;IACzC,IAAI7C,CAAC;IACL,IAAIhE,IAAI;IACR,IAAI+J,MAAM,GAAGlJ,EAAE,GAAG,OAAO;IACzB,IAAImJ,MAAM,GAAGnJ,EAAE,GAAG,OAAO;IACzB,IAAIoG,MAAM,GAAG,IAAIjJ,UAAU,CAAC,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,EAAE,EAAE,EAAE,QAAQ,CAAC;IAC7D,IAAIiM,UAAU,GAAGP,SAAS,CAACE,SAAS;IACpC,IAAI7B,UAAU,GAAG3C,SAAS,CAACI,GAAG,CAAC,UAAUC,CAAC,EAAE;MAAE,OAAOA,CAAC,CAACuC,cAAc;IAAE,CAAC,CAAC;IACzE,IAAIF,OAAO,GAAGnC,IAAI,CAACrC,GAAG,CAACsC,KAAK,CAAC,IAAI,EAAEmC,UAAU,CAAC;IAC9C,IAAIF,MAAM,GAAGlC,IAAI,CAACE,GAAG,CAACD,KAAK,CAAC,IAAI,EAAEmC,UAAU,CAAC;IAC7C,IAAImC,KAAK,GAAG,CAAC;IACb,IAAIpH,OAAO,GAAI4G,SAAS,CAACtI,IAAI,KAAK,aAAa,IAAIsI,SAAS,CAACvI,MAAM,CAAC6B,KAAK,GAAI,CAAC,GAAG,CAAC;IAClF,IAAI+F,IAAI,GAAGjL,WAAW,CAAC,wBAAwB,EAAEmM,UAAU,EAAE,IAAI,CAAC7L,SAAS,CAACqF,UAAU,CAAC0G,aAAa,CAAC;IACrG,IAAIlC,WAAW,GAAG,IAAIxK,UAAU,CAAC,EAAE,EAAEiM,SAAS,CAACtI,IAAI,EAAEsI,SAAS,CAACvI,MAAM,EAAEuI,SAAS,CAAC7F,OAAO,EAAE,IAAI,CAAC;IAC/F,IAAIuG,eAAe;IACnB,IAAIC,OAAO,GAAG,SAAAA,CAAUxI,CAAC,EAAEyI,QAAQ,EAAE;MACjCtK,IAAI,GAAG+D,MAAM,CAAClC,CAAC,CAAC;MAChBoF,MAAM,CAACpG,EAAE,GAAGkJ,MAAM,GAAGlI,CAAC;MACtBoF,MAAM,CAACrH,CAAC,GAAGI,IAAI,CAACgH,QAAQ,CAACpH,CAAC,GAAG8J,SAAS,CAACa,MAAM,CAAC3K,CAAC;MAC/CqH,MAAM,CAACpH,CAAC,GAAG,CAAEa,KAAK,CAACc,IAAI,KAAK,KAAK,GAAIxB,IAAI,CAACgH,QAAQ,CAACnH,CAAC,GAAKG,IAAI,CAACgI,cAAc,GAAGwC,MAAM,CAAC7C,UAAU,GAAK3H,IAAI,CAACgH,QAAQ,CAACnH,CAAC,GAC/GkJ,IAAI,CAACnG,MAAM,GAAG,CAAE,GAAGsH,KAAK,GAAG,CAAC,GAAGpH,OAAO,GAAK9C,IAAI,CAACgH,QAAQ,CAACnH,CAAC,GAAIkJ,IAAI,CAACnG,MAAM,GAAG,CAAE,GAAGsH,KAAK,GAAGpH,OAAS,IAAI4G,SAAS,CAACa,MAAM,CAAC1K,CAAC;MAC7HoH,MAAM,CAACwD,IAAI,GAAIf,SAAS,CAACgB,MAAM,KAAK,EAAE,GAAIF,MAAM,CAACG,SAAS,CAACjB,SAAS,CAACgB,MAAM,EAAEF,MAAM,CAACpM,SAAS,CAACI,UAAU,CAACqD,CAAC,CAAC,CAAC,GACxG7B,IAAI,CAAC0F,IAAI,CAACkF,QAAQ,CAAC,CAAC;MACxB,IAAIC,SAAS,GAAG;QACZ7J,IAAI,EAAE,oBAAoB;QAAEC,MAAM,EAAE,KAAK;QACzCE,MAAM,EAAEuI,SAAS,CAACvI,MAAM;QAAEC,IAAI,EAAEsI,SAAS,CAACtI,IAAI;QAAEkH,UAAU,EAAEzG,CAAC;QAC7DzD,SAAS,EAAEoM,MAAM,CAACpM,SAAS;QAC3BwB,CAAC,EAAEqH,MAAM,CAACrH,CAAC;QAAEC,CAAC,EAAEoH,MAAM,CAACpH,CAAC;QAAE4K,IAAI,EAAExD,MAAM,CAACwD,IAAI;QAAEjH,KAAK,EAAEA;MACxD,CAAC;MACDgH,MAAM,CAACpM,SAAS,CAACqE,OAAO,CAAC,oBAAoB,EAAEoI,SAAS,EAAE,YAAY;QAClE9B,IAAI,GAAGjL,WAAW,CAAC+M,SAAS,CAACJ,IAAI,EAAER,UAAU,EAAEhL,KAAK,CAACb,SAAS,CAACqF,UAAU,CAAC0G,aAAa,CAAC;QACxFlD,MAAM,CAACwD,IAAI,GAAGI,SAAS,CAACJ,IAAI;QAC5B,IAAIlI,WAAW,GAAImH,SAAS,CAACZ,OAAO,CAACE,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC7I,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAE;QAC9EmC,WAAW,GAAGtD,KAAK,CAAC6L,eAAe,CAACvI,WAAW,EAAEvC,IAAI,EAAE6B,CAAC,EAAE6H,SAAS,EAAEY,QAAQ,EAAExC,OAAO,EAAED,MAAM,CAAC;QAC/FuC,eAAe,GAAGnL,KAAK,CAAC8L,oBAAoB,CAACrB,SAAS,CAACsB,aAAa,EAAEzI,WAAW,EAAEsI,SAAS,CAACjL,CAAC,EAAEiC,CAAC,EAAEyI,QAAQ,EAAEvB,IAAI,EAAEjG,OAAO,CAAC;QAC3H,IAAIP,WAAW,IAAI,CAACsI,SAAS,CAAC5J,MAAM,IAAImJ,eAAe,CAACd,MAAM,EAAE;UAC5DrB,WAAW,CAACpH,EAAE,GAAGmJ,MAAM,GAAGnI,CAAC;UAC3BoG,WAAW,CAAC7G,IAAI,GAAGyJ,SAAS,CAACzJ,IAAI;UACjC6G,WAAW,CAACnD,MAAM,GAAG+F,SAAS,CAAC1J,MAAM,CAACqC,KAAK;UAC3CyE,WAAW,CAAC,cAAc,CAAC,GAAG4C,SAAS,CAAC1J,MAAM,CAAC6B,KAAK;UACpDiE,MAAM,CAACpH,CAAC,GAAGgL,SAAS,CAAChL,CAAC;UACtBoH,MAAM,CAACrH,CAAC,GAAGwK,eAAe,CAACxK,CAAC;UAC5BqI,WAAW,CAACE,IAAI,GAAG,IAAIzK,IAAI,CAACuJ,MAAM,CAACrH,CAAC,IAAKmJ,IAAI,CAAC/F,KAAK,GAAG,CAAC,GAAIF,OAAO,CAAC,EAAGmE,MAAM,CAACpH,CAAC,GAAGiD,OAAO,GAAIiG,IAAI,CAACnG,MAAM,GAAG,IAAK,EAAGmG,IAAI,CAAC/F,KAAK,GAAIF,OAAO,GAAG,CAAE,EAAEiG,IAAI,CAACnG,MAAM,GAAIE,OAAO,GAAG,CAAE,CAAC;UAC1KkB,CAAC,GAAG/E,KAAK,CAACb,SAAS,CAACuD,QAAQ,CAACC,WAAW,CAAC;YAAEf,EAAE,EAAEA,EAAE,GAAG,GAAG,GAAGgB;UAAE,CAAC,CAAC;UAC9DrE,aAAa,CAACkD,KAAK,EAAEuH,WAAW,EAAEjE,CAAC,CAAC;UACpCjG,iBAAiB,CAACkJ,MAAM,EAAEgD,UAAU,EAAEY,SAAS,CAACrH,KAAK,EAAEQ,CAAC,EAAE/E,KAAK,CAACb,SAAS,CAACqF,UAAU,CAAC0G,aAAa,CAAC;UACnGzI,KAAK,CAACW,WAAW,CAAC2B,CAAC,CAAC;QACxB;MACJ,CAAC,CAAC;IACN,CAAC;IACD,IAAIwG,MAAM,GAAG,IAAI;IACjB,KAAK,IAAI3I,CAAC,GAAG,CAAC,EAAEyI,QAAQ,GAAGvG,MAAM,CAACtF,MAAM,EAAEoD,CAAC,GAAGyI,QAAQ,EAAEzI,CAAC,EAAE,EAAE;MACzDwI,OAAO,CAACxI,CAAC,EAAEyI,QAAQ,CAAC;IACxB;IACA,IAAI,CAAClM,SAAS,CAACgE,SAAS,CAACC,WAAW,CAACX,KAAK,CAAC;EAC/C,CAAC;EACDvD,iBAAiB,CAACE,SAAS,CAAC0M,oBAAoB,GAAG,UAAUE,SAAS,EAAE3B,MAAM,EAAE1J,CAAC,EAAE8C,KAAK,EAAEjE,MAAM,EAAEsK,IAAI,EAAEjG,OAAO,EAAE;IAC7G,IAAImI,SAAS,KAAK,MAAM,EAAE;MACtB,OAAO;QAAErL,CAAC,EAAEA,CAAC;QAAE0J,MAAM,EAAEA;MAAO,CAAC;IACnC;IACA,IAAI5G,KAAK,KAAK,CAAC,IAAM9C,CAAC,GAAImJ,IAAI,CAAC/F,KAAK,GAAG,CAAE,GAAGF,OAAO,IAAK,CAAE,EAAE;MACxD,IAAImI,SAAS,KAAK,MAAM,EAAE;QACtB3B,MAAM,GAAG,KAAK;MAClB,CAAC,MACI;QACD1J,CAAC,GAAG,IAAI,CAACxB,SAAS,CAAC0E,OAAO,CAACG,IAAI,GAAGH,OAAO,GAAIiG,IAAI,CAAC/F,KAAK,GAAG,CAAE;MAChE;IACJ,CAAC,MACI,IAAIN,KAAK,KAAKjE,MAAM,GAAG,CAAC,IAAMmB,CAAC,GAAImJ,IAAI,CAAC/F,KAAK,GAAG,CAAE,GAAGF,OAAO,IAAK,IAAI,CAAC1E,SAAS,CAACyE,aAAa,CAACG,KAAM,EAAE;MACvG,IAAIiI,SAAS,KAAK,MAAM,EAAE;QACtB3B,MAAM,GAAG,KAAK;MAClB,CAAC,MACI;QACD1J,CAAC,IAAKmJ,IAAI,CAAC/F,KAAK,GAAG,CAAC,GAAGF,OAAQ;MACnC;IACJ;IACA,OAAO;MAAElD,CAAC,EAAEA,CAAC;MAAE0J,MAAM,EAAEA;IAAO,CAAC;EACnC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACInL,iBAAiB,CAACE,SAAS,CAACyM,eAAe,GAAG,UAAUxB,MAAM,EAAEtJ,IAAI,EAAE6B,CAAC,EAAEqJ,KAAK,EAAEzM,MAAM,EAAEqJ,OAAO,EAAED,MAAM,EAAE;IACrG,IAAIsD,YAAY,GAAGD,KAAK,CAACpC,OAAO,CAACE,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;IACrD,IAAIjJ,IAAI,CAACgI,cAAc,GAAG,IAAI,CAACL,UAAU,EAAE;MACvC2B,MAAM,GAAGA,MAAM,IAAK6B,YAAY,CAAC/K,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAE;IAC9D;IACA,IAAIyB,CAAC,KAAK,CAAC,EAAE;MACTyH,MAAM,GAAGA,MAAM,IAAK6B,YAAY,CAAC/K,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,CAAE;IAC3D,CAAC,MACI,IAAKyB,CAAC,KAAMpD,MAAM,GAAG,CAAE,EAAG;MAC3B6K,MAAM,GAAGA,MAAM,IAAK6B,YAAY,CAAC/K,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAE;IACzD;IACA,IAAIJ,IAAI,CAACgI,cAAc,KAAKF,OAAO,EAAE;MACjCwB,MAAM,GAAGA,MAAM,IAAK6B,YAAY,CAAC/K,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAE;IAC1D,CAAC,MACI,IAAIJ,IAAI,CAACgI,cAAc,KAAKH,MAAM,EAAE;MACrCyB,MAAM,GAAGA,MAAM,IAAK6B,YAAY,CAAC/K,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAE;IACzD;IACA,IAAI8K,KAAK,CAACpC,OAAO,CAACE,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,CAAC7I,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE;MACzDkJ,MAAM,GAAG,KAAK;IAClB;IACA,OAAOA,MAAM;EACjB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACInL,iBAAiB,CAACE,SAAS,CAACsM,SAAS,GAAG,UAAUD,MAAM,EAAEnM,IAAI,EAAE;IAC5D,IAAIlB,iBAAiB,CAACqN,MAAM,CAAC,EAAE;MAC3B,OAAO,IAAI;IACf;IACA,IAAIU,IAAI,GAAGC,MAAM,CAACD,IAAI,CAAC7M,IAAI,CAAC;IAC5B,KAAK,IAAI+M,EAAE,GAAG,CAAC,EAAEC,MAAM,GAAGH,IAAI,EAAEE,EAAE,GAAGC,MAAM,CAAC9M,MAAM,EAAE6M,EAAE,EAAE,EAAE;MACtD,IAAIE,GAAG,GAAGD,MAAM,CAACD,EAAE,CAAC;MACpBZ,MAAM,GAAGA,MAAM,CAACe,KAAK,CAAC,IAAI,GAAGD,GAAG,GAAG,GAAG,CAAC,CAACxC,IAAI,CAACzK,IAAI,CAACiN,GAAG,CAAC,CAAC;IAC3D;IACA,OAAOd,MAAM;EACjB,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIvM,iBAAiB,CAACE,SAAS,CAACU,eAAe,GAAG,YAAY;IACtD,IAAI,CAAC2M,UAAU,CAAC,IAAI,CAACtN,SAAS,CAACU,aAAa,CAAC;EACjD,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;EACIX,iBAAiB,CAACE,SAAS,CAACsN,WAAW,GAAG,UAAUpN,IAAI,EAAEqB,CAAC,EAAE;IACzD,IAAIgM,QAAQ,GAAG,CAAC;IAChB,IAAIC,EAAE,GAAGtN,IAAI,CAAC,CAAC,CAAC,CAACqB,CAAC,CAAC;IACnB,IAAIkM,EAAE,GAAGzO,iBAAiB,CAACkB,IAAI,CAAC,CAAC,CAAC,CAAC,GAAGwN,SAAS,GAAGxN,IAAI,CAAC,CAAC,CAAC,CAACqB,CAAC,CAAC;IAC5D,IAAI,CAACvC,iBAAiB,CAACwO,EAAE,CAAC,IAAI,CAACxO,iBAAiB,CAACyO,EAAE,CAAC,EAAE;MAClD,IAAI9L,IAAI,GAAG5C,MAAM,CAAC,EAAE,EAAEmB,IAAI,CAAC;MAC3B,IAAIyN,WAAW,GAAG,EAAE;MACpBhM,IAAI,CAACE,OAAO,CAAC,UAAUC,KAAK,EAAE;QAC1B,IAAI,CAAC9C,iBAAiB,CAAC8C,KAAK,CAACP,CAAC,CAAC,CAAC,EAAE;UAC9BoM,WAAW,CAAC3L,IAAI,CAACF,KAAK,CAAC;QAC3B;MACJ,CAAC,CAAC;MACF6L,WAAW,CAACC,IAAI,CAAC,UAAUxG,CAAC,EAAEyG,CAAC,EAAE;QAC7B,IAAI7O,iBAAiB,CAACoI,CAAC,CAAC7F,CAAC,CAAC,CAAC,IAAIvC,iBAAiB,CAAC6O,CAAC,CAACtM,CAAC,CAAC,CAAC,EAAE;UACpD,OAAO,CAAC;QACZ;QACA,OAAO6F,CAAC,CAAC7F,CAAC,CAAC,GAAGsM,CAAC,CAACtM,CAAC,CAAC;MACtB,CAAC,CAAC;MACFoM,WAAW,GAAI,IAAI,CAAC5N,SAAS,CAACQ,SAAS,GAAIoN,WAAW,CAACnN,OAAO,CAAC,CAAC,GAAGmN,WAAW;MAC9EJ,QAAQ,GAAGI,WAAW,CAAC,CAAC,CAAC,CAACpM,CAAC,CAAC,GAAGoM,WAAW,CAAC,CAAC,CAAC,CAACpM,CAAC,CAAC;IACpD;IACA,OAAOgM,QAAQ;EACnB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIzN,iBAAiB,CAACE,SAAS,CAAC8N,kBAAkB,GAAG,UAAU5N,IAAI,EAAEqB,CAAC,EAAE4B,IAAI,EAAE4K,KAAK,EAAE;IAC7E,IAAIR,QAAQ,GAAG,CAAC;IAChB,IAAI7C,IAAI,GAAG,IAAI,CAAC3K,SAAS,CAACyE,aAAa,CAACD,MAAM;IAC9C,IAAIyJ,aAAa,GAAGT,QAAQ,GAAGrN,IAAI,CAACE,MAAM;IAC1C4N,aAAa,GAAG1G,IAAI,CAACE,GAAG,CAAEkD,IAAI,IAAIsD,aAAa,GAAG,GAAG,CAAC,EAAG,CAAC,CAAC;IAC3D,IAAIC,YAAY,GAAGF,KAAK,GAAGC,aAAa;IACxC,KAAK,IAAIf,EAAE,GAAG,CAAC,EAAEiB,EAAE,GAAG,IAAI,CAACnO,SAAS,CAACoO,YAAY,EAAElB,EAAE,GAAGiB,EAAE,CAAC9N,MAAM,EAAE6M,EAAE,EAAE,EAAE;MACrE,IAAImB,WAAW,GAAGF,EAAE,CAACjB,EAAE,CAAC;MACxB,IAAIoB,eAAe,GAAGd,QAAQ,GAAGa,WAAW;MAC5C,IAAIJ,aAAa,GAAID,KAAK,GAAGM,eAAgB,EAAE;QAC3C;MACJ;MACAJ,YAAY,GAAGI,eAAe;IAClC;IACA,OAAOJ,YAAY;EACvB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACInO,iBAAiB,CAACE,SAAS,CAACqN,UAAU,GAAG,UAAUnN,IAAI,EAAE;IACrD,IAAIoE,KAAK,GAAG,IAAI,CAACvE,SAAS;IAC1B,IAAIyH,GAAG;IACP,IAAIvC,GAAG;IACP,IAAIqJ,IAAI;IACR,IAAIC,IAAI;IACR,IAAIC,eAAe,GAAGtO,IAAI,CAACE,MAAM;IACjC,IAAIuB,IAAI;IACR,IAAI8M,WAAW,GAAG,CAAC;IACnB,IAAIC,cAAc,GAAGC,KAAK,CAACC,OAAO,CAAC1O,IAAI,CAAC,IAAI,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ;IACvE,IAAIwO,cAAc,EAAE;MAChB,IAAIpK,KAAK,CAACnB,IAAI,KAAK,KAAK,EAAE;QACtB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgL,eAAe,EAAEhL,CAAC,EAAE,EAAE;UACtCiL,WAAW,IAAInH,IAAI,CAACuH,GAAG,CAAC3O,IAAI,CAACsD,CAAC,CAAC,CAAC;QACpC;MACJ,CAAC,MACI;QACDgE,GAAG,GAAGF,IAAI,CAACE,GAAG,CAACD,KAAK,CAAC,IAAI,EAAErH,IAAI,CAAC;QAChC+E,GAAG,GAAGqC,IAAI,CAACrC,GAAG,CAACsC,KAAK,CAAC,IAAI,EAAErH,IAAI,CAAC;QAChCoO,IAAI,GAAG,CAAC;QACRC,IAAI,GAAGC,eAAe,GAAG,CAAC;MAC9B;IACJ,CAAC,MACI;MACD,IAAIlK,KAAK,CAACnB,IAAI,KAAK,KAAK,EAAE;QACtB,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgL,eAAe,EAAEhL,CAAC,EAAE,EAAE;UACtCiL,WAAW,IAAInH,IAAI,CAACuH,GAAG,CAAC3O,IAAI,CAACsD,CAAC,CAAC,CAACc,KAAK,CAAC5C,KAAK,CAAC,CAAC;QACjD;MACJ,CAAC,MACI;QACD,IAAI1C,iBAAiB,CAACkB,IAAI,CAAC,CAAC,CAAC,CAACoE,KAAK,CAAC7C,KAAK,CAAC,CAAC,EAAE;UACzC,IAAIqN,GAAG,GAAG5O,IAAI,CAACiH,GAAG,CAAC,UAAU4H,CAAC,EAAE;YAAE,OAAOA,CAAC,CAACzK,KAAK,CAAC5C,KAAK,CAAC;UAAE,CAAC,CAAC;UAC3D8F,GAAG,GAAGF,IAAI,CAACE,GAAG,CAACD,KAAK,CAAC,IAAI,EAAEuH,GAAG,CAAC;UAC/B7J,GAAG,GAAGqC,IAAI,CAACrC,GAAG,CAACsC,KAAK,CAAC,IAAI,EAAEuH,GAAG,CAAC;QACnC,CAAC,MACI;UACDnN,IAAI,GAAG5C,MAAM,CAAC,EAAE,EAAEmB,IAAI,CAAC;UACvByB,IAAI,GAAGA,IAAI,CAACiM,IAAI,CAAC,UAAUxG,CAAC,EAAEyG,CAAC,EAAE;YAAE,OAAOzG,CAAC,CAAC9C,KAAK,CAAC5C,KAAK,CAAC,GAAGmM,CAAC,CAACvJ,KAAK,CAAC5C,KAAK,CAAC;UAAE,CAAC,CAAC;UAC7E8F,GAAG,GAAG7F,IAAI,CAACA,IAAI,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACkE,KAAK,CAAC5C,KAAK,CAAC;UACxCuD,GAAG,GAAGtD,IAAI,CAAC,CAAC,CAAC,CAAC2C,KAAK,CAAC5C,KAAK,CAAC;QAC9B;QACA,IAAI,CAAC1C,iBAAiB,CAACkB,IAAI,CAAC,CAAC,CAAC,CAACoE,KAAK,CAAC7C,KAAK,CAAC,CAAC,EAAE;UAC1CE,IAAI,GAAGA,IAAI,CAACiM,IAAI,CAAC,UAAUxG,CAAC,EAAEyG,CAAC,EAAE;YAAE,OAAOzG,CAAC,CAAC9C,KAAK,CAAC7C,KAAK,CAAC,GAAGoM,CAAC,CAACvJ,KAAK,CAAC7C,KAAK,CAAC;UAAE,CAAC,CAAC;UAC7EE,IAAI,GAAI,IAAI,CAAC5B,SAAS,CAACQ,SAAS,GAAIoB,IAAI,CAACnB,OAAO,CAAC,CAAC,GAAGmB,IAAI;UACzD4M,IAAI,GAAG5M,IAAI,CAACA,IAAI,CAACvB,MAAM,GAAG,CAAC,CAAC,CAACkE,KAAK,CAAC7C,KAAK,CAAC;UACzC6M,IAAI,GAAG3M,IAAI,CAAC,CAAC,CAAC,CAAC2C,KAAK,CAAC7C,KAAK,CAAC;QAC/B,CAAC,MACI;UACD6M,IAAI,GAAG,CAAC;UACRC,IAAI,GAAGC,eAAe,GAAG,CAAC;QAC9B;MACJ;IACJ;IACA,IAAIQ,EAAE;IACN,IAAIzK,MAAM;IACV,IAAII,KAAK;IACT,IAAI6I,EAAE,GAAG,CAAC;IACV,IAAIyB,EAAE;IACN,IAAIxK,OAAO,GAAGH,KAAK,CAACG,OAAO;IAC3B,IAAIyK,KAAK;IACT,IAAIC,IAAI,GAAG7K,KAAK,CAACb,YAAY;IAC7B,IAAI3B,KAAK,GAAGqN,IAAI,CAACrN,KAAK;IACtB,IAAIwC,KAAK,CAACnB,IAAI,KAAK,KAAK,EAAE;MACtB,IAAI,CAACiM,SAAS,GAAGZ,eAAe;MAChCjK,MAAM,GAAGD,KAAK,CAACE,aAAa,CAACD,MAAM,IAAIE,OAAO,CAACwB,MAAM,GAAGxB,OAAO,CAACC,GAAG,CAAC;MACpEC,KAAK,GAAGL,KAAK,CAACE,aAAa,CAACG,KAAK,IAAIF,OAAO,CAACG,IAAI,GAAGH,OAAO,CAACyB,KAAK,CAAC;MAClEqI,IAAI,GAAGvP,iBAAiB,CAACmQ,IAAI,CAACZ,IAAI,CAAC,GAAGA,IAAI,GAAGY,IAAI,CAACZ,IAAI;MACtDD,IAAI,GAAGtP,iBAAiB,CAACmQ,IAAI,CAACb,IAAI,CAAC,GAAGA,IAAI,GAAGa,IAAI,CAACb,IAAI;MACtD9G,GAAG,GAAGxI,iBAAiB,CAACmQ,IAAI,CAACvL,IAAI,CAAC,GAAG4D,GAAG,GAAG2H,IAAI,CAACvL,IAAI;MACpDqB,GAAG,GAAGjG,iBAAiB,CAACmQ,IAAI,CAACzL,IAAI,CAAC,GAAGuB,GAAG,GAAGkK,IAAI,CAACzL,IAAI;MACpD,IAAIyB,KAAK,GAAGgK,IAAI,CAACE,YAAY,CAAClK,KAAK,IAAI,IAAI,CAACpF,SAAS,CAACqF,UAAU,CAACS,aAAa;MAC9E,IAAIyJ,SAAS,GAAG;QACZ3M,IAAI,EAAE,eAAe;QAAEC,MAAM,EAAE,KAAK;QAAE7C,SAAS,EAAEuE,KAAK;QACtDiK,IAAI,EAAEA,IAAI;QAAED,IAAI,EAAEA,IAAI;QAAE1K,IAAI,EAAE4D,GAAG;QAAE9D,IAAI,EAAEuB,GAAG;QAAEnD,KAAK,EAAEqN,IAAI,CAACrN,KAAK;QAC/DyN,SAAS,EAAEpK,KAAK;QAAEtC,SAAS,EAAEsM,IAAI,CAACE,YAAY,CAAC1K;MACnD,CAAC;MACDL,KAAK,CAACF,OAAO,CAAC,eAAe,EAAEkL,SAAS,CAAC;MACzC,IAAIA,SAAS,CAAC1M,MAAM,EAAE;QAClB,IAAI,CAACM,aAAa,GAAG,EAAE;QACvB;MACJ;MACAqL,IAAI,GAAGe,SAAS,CAACf,IAAI;MACrBD,IAAI,GAAGgB,SAAS,CAAChB,IAAI;MACrB9G,GAAG,GAAG8H,SAAS,CAAC1L,IAAI;MACpBqB,GAAG,GAAGqK,SAAS,CAAC5L,IAAI;MACpB5B,KAAK,GAAG,IAAI,CAACuI,SAAS,GAAGiF,SAAS,CAACxN,KAAK;MACxC,IAAI,CAAC0N,SAAS,GAAGF,SAAS,CAACC,SAAS;MACpC,IAAI,CAACE,SAAS,GAAGH,SAAS,CAACzM,SAAS;IACxC;IACA,IAAI6M,KAAK,GAAGnB,IAAI,GAAGD,IAAI;IACvB,IAAItJ,KAAK,GAAGwC,GAAG,GAAGvC,GAAG;IACrByK,KAAK,GAAIA,KAAK,KAAK,CAAC,GAAI,CAAC,GAAGA,KAAK;IACjC1K,KAAK,GAAIA,KAAK,KAAK,CAAC,GAAI,CAAC,GAAGA,KAAK;IACjC,IAAI,CAAC0K,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC1K,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,GAAG,GAAGA,GAAG;IACduI,EAAE,GAAG,CAAC;IACNyB,EAAE,GAAG1K,MAAM,GAAKA,MAAM,GAAGS,KAAK,GAAK,CAACC,GAAK;IACzCgK,EAAE,GAAIhK,GAAG,GAAG,CAAC,IAAIuC,GAAG,IAAI,CAAC,GAAI,CAAC,GAAIvC,GAAG,GAAG,CAAC,IAAIuC,GAAG,GAAG,CAAC,GAAIyH,EAAE,GAAG1K,MAAM;IACnE,IAAIzC,KAAK,IAAImD,GAAG,IAAInD,KAAK,IAAI0F,GAAG,EAAE;MAC9ByH,EAAE,GAAG1K,MAAM,GAAG+C,IAAI,CAACqI,KAAK,CAACpL,MAAM,IAAI,CAACzC,KAAK,GAAGmD,GAAG,IAAI,IAAI,CAACD,KAAK,CAAC,CAAC;IACnE;IACA,IAAI,CAACsE,UAAU,GAAG2F,EAAE,GAAGxK,OAAO,CAACC,GAAG;IAClC,IAAIkL,OAAO;IACX,IAAIrO,CAAC;IACL,IAAIC,CAAC;IACL,IAAI0B,aAAa,GAAG,EAAE;IACtB,IAAI6K,KAAK,GAAGvG,GAAG,GAAGvC,GAAG;IACrB,IAAIsI,QAAQ,GAAG,IAAI,CAACD,WAAW,CAACpN,IAAI,EAAEoE,KAAK,CAAC7C,KAAK,CAAC;IAClD,IAAIoO,QAAQ,GAAG,IAAI,CAAC/B,kBAAkB,CAAC5N,IAAI,EAAEoE,KAAK,CAAC7C,KAAK,EAAE6C,KAAK,CAAChE,SAAS,EAAEyN,KAAK,CAAC;IACjF,KAAK,IAAIvK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgL,eAAe,EAAEhL,CAAC,EAAE,EAAE;MACtC,IAAIxE,iBAAiB,CAACkB,IAAI,CAACsD,CAAC,CAAC,CAACc,KAAK,CAAC7C,KAAK,CAAC,CAAC,IAAIzC,iBAAiB,CAACkB,IAAI,CAACsD,CAAC,CAAC,CAACc,KAAK,CAAC5C,KAAK,CAAC,CAAC,IAChFxB,IAAI,CAACsD,CAAC,CAAC,CAACc,KAAK,CAAC5C,KAAK,CAAC,KAAM,CAAE,IAAIgN,cAAc,EAAE;QAClDnN,CAAC,GAAGiC,CAAC;QACLhC,CAAC,GAAGtB,IAAI,CAACsD,CAAC,CAAC;MACf,CAAC,MACI,IAAIxE,iBAAiB,CAACkB,IAAI,CAACsD,CAAC,CAAC,CAACc,KAAK,CAAC7C,KAAK,CAAC,CAAC,EAAE;QAC9CF,CAAC,GAAGiC,CAAC;QACLhC,CAAC,GAAGtB,IAAI,CAACsD,CAAC,CAAC,CAACc,KAAK,CAAC5C,KAAK,CAAC;MAC5B,CAAC,MACI;QACDH,CAAC,GAAGrB,IAAI,CAACsD,CAAC,CAAC,CAACc,KAAK,CAAC7C,KAAK,CAAC;QACxBD,CAAC,GAAGtB,IAAI,CAACsD,CAAC,CAAC,CAACc,KAAK,CAAC5C,KAAK,CAAC;MAC5B;MACA,IAAI1C,iBAAiB,CAACuC,CAAC,CAAC,IAAIvC,iBAAiB,CAACwC,CAAC,CAAC,EAAE;QAC9C;MACJ;MACA,IAAI8C,KAAK,CAACnB,IAAI,KAAK,MAAM,IAAImB,KAAK,CAACnB,IAAI,KAAK,MAAM,EAAE;QAChD6L,EAAE,GAAI/J,GAAG,KAAKuC,GAAG,IAAIgH,eAAe,KAAK,CAAC,GAAIjK,MAAM,GAAG+C,IAAI,CAACqI,KAAK,CAACpL,MAAM,IAAI,CAAC/C,CAAC,GAAGyD,GAAG,IAAI,IAAI,CAACD,KAAK,CAAC,CAAC,GAAGP,OAAO,CAACC,GAAG;QAClHwK,KAAK,GAAG;UAAE3N,CAAC,EAAG+M,IAAI,KAAKC,IAAI,GAAIjH,IAAI,CAACqI,KAAK,CAAChL,KAAK,IAAI,CAACpD,CAAC,GAAG+M,IAAI,IAAI,IAAI,CAACoB,KAAK,CAAC,CAAC,GAAG/K,KAAK,GAAG,CAAC;UAAEnD,CAAC,EAAEwN,EAAE;UAAErF,cAAc,EAAEqF;QAAG,CAAC;MACzH,CAAC,MACI,IAAI1K,KAAK,CAACnB,IAAI,KAAK,QAAQ,IAAImB,KAAK,CAACnB,IAAI,KAAK,SAAS,EAAE;QAC1D,IAAI2M,QAAQ,GAAGnL,KAAK,IAAK,CAAC4J,IAAI,GAAGD,IAAI,IAAIf,QAAQ,GAAI,CAAC,CAAC;QACvD,IAAIwC,QAAQ,GAAG,GAAG;QAClB,IAAIlE,KAAK,GAAIkE,QAAQ,GAAG,CAAE,CAAC,CAAC;QAC5BD,QAAQ,IAAKjE,KAAM;QACnB2B,EAAE,GAAK,CAACjM,CAAC,GAAG+M,IAAI,IAAIf,QAAQ,IAAKuC,QAAQ,GAAGjE,KAAK,CAAC,GAAKA,KAAK,GAAG,CAAE;QACjE,IAAIvH,KAAK,CAACnB,IAAI,KAAK,SAAS,EAAE;UAC1B;UACA,IAAI6M,aAAa,GAAG,GAAG;UACvB,IAAIC,gBAAgB,GAAG,EAAE;UACzBjB,EAAE,GAAIxN,CAAC,GAAGM,KAAK,GAAKyC,MAAM,GAAG,CAAC,GAAK/C,CAAC,GAAGM,KAAK,GAAKyC,MAAM,GAAGyL,aAAa,GACjEzL,MAAM,GAAGyL,aAAa,GAAKzL,MAAM,GAAG0L,gBAAkB;UAC5Df,KAAK,GAAG;YACJ3N,CAAC,EAAEiM,EAAE;YAAEhM,CAAC,EAAEwN,EAAE;YAAEzK,MAAM,EAAG/C,CAAC,KAAKM,KAAK,GAAKyC,MAAM,GAAG,CAAC,GAAIA,MAAM,GAAG,EAAE;YAAEI,KAAK,EAAEmL,QAAQ;YACjFnG,cAAc,EAAGqF,EAAE,GAAGC,EAAE,GAAKA,EAAE,GAAG3H,IAAI,CAACuH,GAAG,CAACG,EAAE,GAAGC,EAAE,CAAC,GAAID;UAC3D,CAAC;QACL,CAAC,MACI;UACD,IAAIxL,CAAC,KAAK,CAAC,IAAIc,KAAK,CAAC4L,YAAY,KAAK,MAAM,EAAE;YAC1CjL,GAAG,IAAIX,KAAK,CAAC4L,YAAY,KAAK,YAAY,GAAIL,QAAQ,GAAGpL,OAAO,CAACC,GAAG,GAAImL,QAAQ;YAChFrI,GAAG,IAAIlD,KAAK,CAAC4L,YAAY,KAAK,YAAY,GAAIL,QAAQ,GAAGpL,OAAO,CAACC,GAAG,GAAImL,QAAQ;YAChFH,KAAK,GAAGnB,IAAI,GAAGD,IAAI;YACnBtJ,KAAK,GAAGwC,GAAG,GAAGvC,GAAG;YACjByK,KAAK,GAAIA,KAAK,KAAK,CAAC,GAAI,CAAC,GAAGA,KAAK;YACjC1K,KAAK,GAAIA,KAAK,KAAK,CAAC,GAAI,CAAC,GAAGA,KAAK;YACjC,IAAI,CAAC0K,KAAK,GAAGA,KAAK;YAClB,IAAI,CAAC1K,KAAK,GAAGA,KAAK;YAClB,IAAI,CAACC,GAAG,GAAGA,GAAG;UAClB;UACA,IAAI8J,CAAC,GAAKxK,MAAM,GAAG,IAAI,CAACS,KAAK,IAAKxD,CAAC,GAAGyD,GAAG,CAAE;UAC3C,IAAIkL,EAAE,GAAI3O,CAAC,KAAKyD,GAAG,IAAIzD,CAAC,GAAGM,KAAK,GAAM0M,eAAe,KAAK,CAAC,IAAI,IAAI,CAACxJ,KAAK,KAAK,CAAC,GAC1ET,MAAM,GAAG,IAAI,CAACS,KAAK,IAAKC,GAAG,GAAG,CAAC,CAAC,GAAI8J,CAAC,GAAG,CAAE,GAC1CvN,CAAC,KAAKgG,GAAG,IAAIhG,CAAC,GAAGM,KAAK,IAAI0M,eAAe,KAAK,CAAC,IAAI,IAAI,CAACxJ,KAAK,KAAK,CAAC,GAAKT,MAAM,GAAG,IAAI,CAACS,KAAK,IAAK,CAACwC,GAAG,GAAG,CAAC,CAAC,GAAGuH,CAAC;UAClHC,EAAE,GAAG1H,IAAI,CAACuH,GAAG,CAACtK,MAAM,GAAG4L,EAAE,CAAC;UAC1BjB,KAAK,GAAG;YACJ3N,CAAC,EAAEiM,EAAE;YAAEhM,CAAC,EAAGwN,EAAE,GAAGC,EAAE,GAAIA,EAAE,GAAGD,EAAE;YAAEzK,MAAM,EAAE+C,IAAI,CAACuH,GAAG,CAACG,EAAE,GAAGC,EAAE,CAAC;YACxDtK,KAAK,EAAEmL,QAAQ;YAAEnG,cAAc,EAAGqF,EAAE,GAAGC,EAAE,GAAKA,EAAE,GAAG3H,IAAI,CAACuH,GAAG,CAACG,EAAE,GAAGC,EAAE,CAAC,GAAID;UAC5E,CAAC;QACL;MACJ,CAAC,MACI,IAAI1K,KAAK,CAACnB,IAAI,KAAK,KAAK,EAAE;QAC3ByM,OAAO,GAAItI,IAAI,CAACuH,GAAG,CAACrN,CAAC,CAAC,GAAGiN,WAAW,GAAI,GAAG;QAC3CS,KAAK,GAAG;UACJU,OAAO,EAAEA,OAAO;UAAEQ,MAAM,EAAI9I,IAAI,CAACuH,GAAG,CAACrN,CAAC,CAAC,GAAGiN,WAAW,GAAI;QAC7D,CAAC;MACL;MACA,IAAInK,KAAK,CAACnB,IAAI,KAAK,KAAK,EAAE;QACtB+L,KAAK,CAAC3N,CAAC,IAAIkD,OAAO,CAACG,IAAI;QACvBsK,KAAK,CAAC1N,CAAC,IAAIiD,OAAO,CAACC,GAAG;MAC1B;MACA,IAAIJ,KAAK,CAACnB,IAAI,KAAK,SAAS,EAAE;QAC1B+L,KAAK,CAACvF,cAAc,IAAIlF,OAAO,CAACC,GAAG;MACvC;MACAwK,KAAK,CAACvG,QAAQ,GAAG;QAAEpH,CAAC,EAAE2N,KAAK,CAAC3N,CAAC;QAAEC,CAAC,EAAE0N,KAAK,CAAC1N;MAAE,CAAC;MAC3C0N,KAAK,CAACmB,IAAI,GAAG9O,CAAC;MACd2N,KAAK,CAAC7H,IAAI,GAAG7F,CAAC;MACd0B,aAAa,CAAClB,IAAI,CAACkN,KAAK,CAAC;IAC7B;IACAhM,aAAa,CAAC0K,IAAI,CAAC,UAAUxG,CAAC,EAAEyG,CAAC,EAAE;MAC/B,OAAOzG,CAAC,CAAC7F,CAAC,GAAGsM,CAAC,CAACtM,CAAC;IACpB,CAAC,CAAC;IACF,IAAI,CAAC2B,aAAa,GAAGA,aAAa;EACtC,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIpD,iBAAiB,CAACE,SAAS,CAACyC,QAAQ,GAAG,YAAY;IAC/C,IAAIJ,KAAK,GAAG,IAAI,CAACtC,SAAS;IAC1B,IAAIwE,MAAM,GAAG,IAAI,CAAC+E,UAAU;IAC5B,IAAKjH,KAAK,CAACc,IAAI,KAAK,SAAS,IAAMd,KAAK,CAACc,IAAI,KAAK,KAAM,IAAId,KAAK,CAACoB,YAAY,CAAC4L,YAAY,CAAC5E,OAAO,EAAE;MACjG,IAAI6F,KAAK,GAAG;QACR,IAAI,EAAEjO,KAAK,CAACE,OAAO,CAACC,EAAE,GAAG,kBAAkB;QAC3C,IAAI,EAAEH,KAAK,CAACoC,OAAO,CAACG,IAAI;QAAE,IAAI,EAAEL,MAAM;QACtC,IAAI,EAAElC,KAAK,CAACmC,aAAa,CAACG,KAAK,GAAGtC,KAAK,CAACoC,OAAO,CAACyB,KAAK;QAAE,IAAI,EAAE3B,MAAM;QACnE,QAAQ,EAAE,IAAI,CAACiL,SAAS;QACxB,SAAS,EAAEnN,KAAK,CAACoB,YAAY,CAAC4L,YAAY,CAAC7J,OAAO;QAClD,kBAAkB,EAAEnD,KAAK,CAACoB,YAAY,CAAC4L,YAAY,CAACkB,SAAS;QAC7D,cAAc,EAAE,IAAI,CAACd,SAAS;QAC9B,WAAW,EAAE,OAAO,GAAG,IAAI,CAACnN,MAAM,GAAG;MACzC,CAAC;MACDD,KAAK,CAAC0B,SAAS,CAACC,WAAW,CAAC3B,KAAK,CAACiB,QAAQ,CAACkN,QAAQ,CAACF,KAAK,CAAC,CAAC;IAC/D;EACJ,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIxQ,iBAAiB,CAACE,SAAS,CAACuI,kBAAkB,GAAG,UAAU5F,IAAI,EAAEa,CAAC,EAAET,IAAI,EAAED,MAAM,EAAE;IAC9E,IAAIG,IAAI,GAAG;MACPN,IAAI,EAAEA,IAAI;MAAEC,MAAM,EAAE,KAAK;MACzBE,MAAM,EAAEA,MAAM;MAAEC,IAAI,EAAEA,IAAI;MAC1BhD,SAAS,EAAE,IAAI,CAACA,SAAS;MACzBkK,UAAU,EAAEzG;IAChB,CAAC;IACD,IAAI,CAACzD,SAAS,CAACqE,OAAO,CAACzB,IAAI,EAAEM,IAAI,CAAC;IAClC,OAAOA,IAAI;EACf,CAAC;EACD,OAAOnD,iBAAiB;AAC5B,CAAC,CAAC,CAAE;AACJ,SAASA,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}