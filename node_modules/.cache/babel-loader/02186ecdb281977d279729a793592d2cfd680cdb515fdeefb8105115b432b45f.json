{"ast":null,"code":"/**\n * StripLine src\n */\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { valueToCoefficient, textElement, RectOption, appendChildElement, appendClipElement, withIn, getElement, ImageOption, logBase } from '../../common/utils/helper';\nimport { measureText, TextOption, PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * The `StripLine` module is used to render strip lines in charts.\n */\nvar StripLine = /** @class */function () {\n  function StripLine() {}\n  /**\n   * Finding x, y, width and height of the strip line\n   *\n   * @param {Axis} axis axis\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} seriesClipRect seriesClipRect\n   * @param {number} startValue startValue\n   * @param {Axis} segmentAxis segmentAxis\n   * @param {Chart} chart chart instance\n   * @returns {Rect} rect\n   */\n  StripLine.prototype.measureStripLine = function (axis, stripline, seriesClipRect, startValue, segmentAxis, chart) {\n    var actualStart;\n    var actualEnd;\n    var orientation = axis.orientation;\n    var isDateTimeAxis = axis.valueType === 'DateTime';\n    if (stripline.isRepeat && stripline.size !== null) {\n      actualStart = startValue;\n      actualEnd = null;\n    } else {\n      if (axis.valueType === 'DateTimeCategory') {\n        var start = stripline.start;\n        var end = stripline.end;\n        actualStart = start != null && typeof start !== 'number' ? axis.labels.indexOf(this.dateToMilliSeconds(start, chart).toString()) : start;\n        actualEnd = end != null && typeof end !== 'number' ? axis.labels.indexOf(this.dateToMilliSeconds(end, chart).toString()) : end;\n      } else {\n        actualStart = stripline.start === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.start, chart) : +(axis.valueType === 'Logarithmic' ? logBase(stripline.start, axis.logBase) : stripline.start);\n        actualEnd = stripline.end === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.end, chart) : +(axis.valueType === 'Logarithmic' ? logBase(stripline.end, axis.logBase) : stripline.end);\n      }\n    }\n    var rect = this.getFromTovalue(actualStart, actualEnd, stripline.size, stripline.startFromAxis, axis, stripline);\n    var height = orientation === 'Vertical' ? (rect.to - rect.from) * axis.rect.height : seriesClipRect.height;\n    var width = orientation === 'Horizontal' ? (rect.to - rect.from) * axis.rect.width : seriesClipRect.width;\n    var x = orientation === 'Vertical' ? seriesClipRect.x : rect.from * axis.rect.width + axis.rect.x;\n    var y = orientation === 'Horizontal' ? seriesClipRect.y : axis.rect.y + axis.rect.height - (stripline.sizeType === 'Pixel' ? rect.from : rect.to) * axis.rect.height;\n    if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\n      var start = isDateTimeAxis && this.isCoreDate(stripline.segmentStart) ? this.dateToMilliSeconds(stripline.segmentStart, chart) : +stripline.segmentStart;\n      var end = isDateTimeAxis && this.isCoreDate(stripline.segmentEnd) ? this.dateToMilliSeconds(stripline.segmentEnd, chart) : +stripline.segmentEnd;\n      var segRect = this.getFromTovalue(start, end, null, null, segmentAxis, stripline);\n      if (segmentAxis.orientation === 'Vertical') {\n        y = segmentAxis.rect.y + segmentAxis.rect.height - segRect.to * segmentAxis.rect.height;\n        height = (segRect.to - segRect.from) * segmentAxis.rect.height;\n      } else {\n        x = segRect.from * segmentAxis.rect.width + segmentAxis.rect.x;\n        width = (segRect.to - segRect.from) * segmentAxis.rect.width;\n      }\n    }\n    if (height !== 0 && width !== 0 || stripline.sizeType === 'Pixel' && (stripline.start !== null || stripline.startFromAxis)) {\n      return new Rect(x, y, width, height);\n    }\n    return new Rect(0, 0, 0, 0);\n  };\n  /**\n   * Retrieves the 'from' and 'to' values from start, end, size, starting from the axis.\n   *\n   * @param {number} start - The start value.\n   * @param {number} end - The end value.\n   * @param {number} size - The size value.\n   * @param {boolean} startFromAxis - Indicates whether to start from the axis.\n   * @param {Axis} axis - The axis.\n   * @param {StripLineSettingsModel} stripline - The strip line settings.\n   * @returns {{ from: number, to: number }} - The 'from' and 'to' values.\n   * @private\n   */\n  StripLine.prototype.getFromTovalue = function (start, end, size, startFromAxis, axis, stripline) {\n    var from = !stripline.isRepeat && startFromAxis ? axis.visibleRange.min : start;\n    if (axis.valueType === 'Double' && size !== null && !startFromAxis && stripline.start == null) {\n      from += size;\n    }\n    var to = this.getToValue(Math.max(start, isNullOrUndefined(end) ? start : end), from, size, axis, end, stripline);\n    from = this.findValue(from, axis);\n    to = this.findValue(to, axis);\n    return {\n      from: valueToCoefficient(axis.isAxisInverse ? to : from, axis),\n      to: valueToCoefficient(axis.isAxisInverse ? from : to, axis)\n    };\n  };\n  /**\n   * Finding end value of the strip line\n   *\n   * @param {number} to to\n   * @param {number} from from\n   * @param {number} size size\n   * @param {Axis} axis axis\n   * @param {number} end end\n   * @param {StripLineSettingsModel} stripline stripline\n   * @returns {number} number\n   */\n  StripLine.prototype.getToValue = function (to, from, size, axis, end, stripline) {\n    var sizeType = stripline.sizeType;\n    var isEnd = end === null;\n    if (axis.valueType === 'DateTime') {\n      var fromValue = new Date(from);\n      if (sizeType === 'Auto') {\n        sizeType = axis.actualIntervalType;\n        size *= axis.visibleRange.interval;\n      }\n      switch (sizeType) {\n        case 'Years':\n          return isEnd ? new Date(fromValue.setFullYear(fromValue.getFullYear() + size)) : to;\n        case 'Months':\n          return isEnd ? new Date(fromValue.setMonth(fromValue.getMonth() + size)) : to;\n        case 'Days':\n          return isEnd ? new Date(fromValue.setDate(fromValue.getDate() + size)) : to;\n        case 'Hours':\n          return isEnd ? new Date(fromValue.setHours(fromValue.getHours() + size)) : to;\n        case 'Minutes':\n          return isEnd ? new Date(fromValue.setMinutes(fromValue.getMinutes() + size)) : to;\n        case 'Seconds':\n          return isEnd ? new Date(fromValue.setSeconds(fromValue.getSeconds() + size)) : to;\n        default:\n          return from;\n      }\n    } else {\n      return stripline.sizeType === 'Pixel' ? from : isEnd ? from + size : to;\n    }\n  };\n  /**\n   * To check the strip line values within range\n   *\n   * @param {number} value value\n   * @param {Axis} axis axis\n   * @returns {number} - To returns a strip line value.\n   */\n  StripLine.prototype.findValue = function (value, axis) {\n    if (value < axis.visibleRange.min) {\n      value = axis.visibleRange.min;\n    } else if (value > axis.visibleRange.max) {\n      value = axis.visibleRange.max;\n    }\n    return value;\n  };\n  /**\n   * Date parse\n   *\n   * @param {Date} value date\n   * @param {Chart} chart chart instance\n   * @returns {Date} parsed date\n   */\n  StripLine.prototype.dateParse = function (value, chart) {\n    var dateParser = chart.intl.getDateParser({\n      skeleton: 'full',\n      type: 'dateTime'\n    });\n    var dateFormatter = chart.intl.getDateFormat({\n      skeleton: 'full',\n      type: 'dateTime'\n    });\n    return new Date(Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({\n      val: value\n    }).val)))));\n  };\n  /**\n   * To render strip lines based start and end.\n   *\n   * @param {Chart} chart chart\n   * @param {ZIndex} position position\n   * @param {Axis[]} axes axes\n   * @returns {void}\n   * @private\n   */\n  StripLine.prototype.renderStripLine = function (chart, position, axes) {\n    var id = chart.element.id + '_stripline_' + position + '_';\n    var seriesClipRect = chart.chartAxisLayoutPanel.seriesClipRect;\n    var end = 0;\n    var limit = 0;\n    var startValue = 0;\n    var segmentAxis = null;\n    var range;\n    var options = new RectOption(id + 'ClipRect', 'transparent', {\n      width: 1,\n      color: 'Gray'\n    }, 1, {\n      x: seriesClipRect.x,\n      y: seriesClipRect.y,\n      width: seriesClipRect.width,\n      height: seriesClipRect.height\n    });\n    var striplineGroup = chart.renderer.createGroup({\n      id: id + 'collections',\n      'clip-path': 'url(#' + id + 'ClipRect' + ')'\n    });\n    if (!chart.enableCanvas) {\n      striplineGroup.appendChild(appendClipElement(chart.redraw, options, chart.renderer));\n    }\n    for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {\n      var axis = axes_1[_i];\n      var count = 0;\n      for (var _a = 0, _b = axis.stripLines; _a < _b.length; _a++) {\n        var stripline = _b[_a];\n        if (stripline.visible && stripline.zIndex === position) {\n          if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\n            segmentAxis = this.getSegmentAxis(axes, axis, stripline);\n          }\n          if (stripline.isRepeat && stripline.repeatEvery != null && stripline.size !== null && stripline.sizeType !== 'Pixel') {\n            limit = stripline.repeatUntil != null ? axis.valueType === 'DateTime' ? this.dateToMilliSeconds(stripline.repeatUntil, chart) : +stripline.repeatUntil : axis.actualRange.max;\n            startValue = axis.valueType === 'DateTime' && this.isCoreDate(stripline.start) ? this.dateToMilliSeconds(stripline.start, chart) : stripline.start;\n            if (stripline.startFromAxis && axis.valueType === 'DateTime' && stripline.sizeType === 'Auto' || stripline.start < axis.visibleRange.min) {\n              startValue = axis.visibleLabels[0] && axis.visibleLabels[0].value === axis.visibleRange.min ? axis.visibleRange.min : axis.visibleLabels[0] && axis.visibleLabels[0].value - (axis.valueType === 'DateTime' ? axis.dateTimeInterval : axis.visibleRange.interval);\n            }\n            startValue = stripline.startFromAxis && axis.valueType !== 'DateTime' ? axis.visibleRange.min : startValue;\n            while (startValue < limit) {\n              end = startValue + (axis.valueType === 'DateTime' ? axis.dateTimeInterval * +stripline.size : stripline.size);\n              range = withIn(end, axis.visibleRange);\n              if (startValue >= axis.visibleRange.min && startValue < axis.visibleRange.max || range) {\n                this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count);\n              }\n              count++;\n              startValue = this.getStartValue(axis, stripline, startValue);\n            }\n          } else {\n            this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, null, segmentAxis, count);\n            count++;\n          }\n        }\n      }\n    }\n    appendChildElement(chart.enableCanvas, chart.svgObject, striplineGroup, chart.redraw);\n  };\n  /**\n   * To convert the C# date to js date\n   *\n   * @param {string | number | Object} value date value\n   * @returns {boolean} returns true if datetime value type is string(for asp platform)\n   */\n  StripLine.prototype.isCoreDate = function (value) {\n    return typeof value === 'string' ? true : false;\n  };\n  /**\n   * To get the total milli seconds\n   *\n   * @param {Date | number | Object} value date value\n   * @param {Chart} chart chart instance\n   * @returns {number} returns milliseconds\n   */\n  StripLine.prototype.dateToMilliSeconds = function (value, chart) {\n    return this.dateParse(value, chart).getTime();\n  };\n  /**\n   * To draw the single line strip line\n   *\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} rect rect\n   * @param {string} id id\n   * @param {Element} parent parent\n   * @param {Chart} chart chart\n   * @param {Axis} axis axis\n   * @returns {void}\n   */\n  StripLine.prototype.renderPath = function (stripline, rect, id, parent, chart, axis) {\n    var element = getElement(id);\n    var direction = element ? element.getAttribute('d') : '';\n    var strokeWidth = stripline.size;\n    var d = axis.orientation === 'Vertical' ? 'M ' + rect.x + ' ' + rect.y + ' ' + 'L ' + (rect.x + rect.width) + ' ' + rect.y : 'M ' + rect.x + ' ' + rect.y + ' ' + 'L ' + rect.x + ' ' + (rect.y + rect.height);\n    if (stripline.sizeType !== 'Pixel') {\n      d = axis.orientation === 'Vertical' ? 'M ' + rect.x + ' ' + (rect.y + rect.height / 2) + ' ' + 'L ' + (rect.x + rect.width) + ' ' + (rect.y + rect.height / 2) : 'M ' + (rect.x + rect.width / 2) + ' ' + rect.y + ' ' + 'L ' + (rect.x + rect.width / 2) + ' ' + (rect.y + rect.height);\n      strokeWidth = axis.orientation === 'Vertical' ? rect.height : rect.width;\n    }\n    appendChildElement(chart.enableCanvas, parent, chart.renderer.drawPath(new PathOption(id, 'none', strokeWidth, stripline.color, stripline.opacity, stripline.dashArray, d)), chart.redraw, true, 'x', 'y', null, direction, true, null, null, chart.duration);\n  };\n  /**\n   * To draw the rectangle\n   *\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} rect rect\n   * @param {string} id id\n   * @param {Element} parent parent\n   * @param {Chart} chart chart\n   * @returns {void}\n   */\n  StripLine.prototype.renderRectangle = function (stripline, rect, id, parent, chart) {\n    var element = getElement(id);\n    var previousRect = element ? new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;\n    appendChildElement(chart.enableCanvas, parent, chart.renderer.drawRectangle(new RectOption(id, 'none', stripline.border, stripline.opacity, rect, 0, 0, '', stripline.border.dashArray)), chart.redraw, true, 'x', 'y', null, null, true, true, previousRect, chart.duration);\n  };\n  /**\n   * To draw the Image\n   *\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} rect rect\n   * @param {string} id id\n   * @param {Element} parent parent\n   * @param {Chart} chart chart\n   * @returns {void}\n   */\n  StripLine.prototype.drawImage = function (stripline, rect, id, parent, chart) {\n    if (stripline.sizeType === 'Pixel') {\n      rect.width = rect.width ? rect.width : stripline.size;\n      rect.height = rect.height ? rect.height : stripline.size;\n    }\n    var image = new ImageOption(rect.height, rect.width, stripline.imageUrl, rect.x, rect.y, id, 'visible', 'none');\n    var htmlObject = chart.renderer.drawImage(image);\n    appendChildElement(chart.enableCanvas, parent, htmlObject, chart.redraw, true, 'x', 'y', null, null, true, true);\n  };\n  /**\n   * To create the text on strip line\n   *\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} rect rect\n   * @param {string} id id\n   * @param {Element} parent parent\n   * @param {Chart} chart chart\n   * @param {Axis} axis axis\n   * @returns {void}\n   */\n  StripLine.prototype.renderText = function (stripline, rect, id, parent, chart, axis) {\n    var textSize = measureText(stripline.text, stripline.textStyle, chart.themeStyle.stripLineLabelFont);\n    var isRotationNull = stripline.rotation === null;\n    var textMid = isRotationNull ? 3 * (textSize.height / 8) : 0;\n    var ty = rect.y + rect.height / 2 + textMid;\n    var rotation = isRotationNull ? axis.orientation === 'Vertical' ? 0 : -90 : stripline.rotation;\n    var tx = rect.x + rect.width / 2;\n    var anchor;\n    var padding = 5;\n    if (axis.orientation === 'Horizontal') {\n      tx = this.getTextStart(tx + textMid * this.factor(stripline.horizontalAlignment), rect.width, stripline.horizontalAlignment);\n      ty = this.getTextStart(ty - textMid, rect.height, stripline.verticalAlignment) + (stripline.verticalAlignment === 'Start' && !isRotationNull ? textSize.height / 4 : 0);\n      anchor = isRotationNull ? this.invertAlignment(stripline.verticalAlignment) : stripline.horizontalAlignment;\n      anchor = tx - textSize.width / 2 < axis.rect.x ? 'Start' : tx + textSize.width / 2 > axis.rect.width ? 'End' : anchor;\n    } else {\n      tx = this.getTextStart(tx, rect.width, stripline.horizontalAlignment);\n      ty = this.getTextStart(ty + textMid * this.factor(stripline.verticalAlignment) - padding, rect.height, stripline.verticalAlignment);\n      anchor = stripline.horizontalAlignment;\n      anchor = chart.enableRtl ? anchor === 'End' ? 'Start' : anchor === 'Start' ? 'End' : anchor : anchor;\n    }\n    textElement(chart.renderer, new TextOption(id, tx, ty, anchor, stripline.text, 'rotate(' + rotation + ' ' + tx + ',' + ty + ')', 'middle'), stripline.textStyle, stripline.textStyle.color || chart.themeStyle.stripLineLabelFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.stripLineLabelFont);\n  };\n  StripLine.prototype.invertAlignment = function (anchor) {\n    switch (anchor) {\n      case 'Start':\n        anchor = 'End';\n        break;\n      case 'End':\n        anchor = 'Start';\n        break;\n    }\n    return anchor;\n  };\n  /**\n   * To find the next value of the recurrence strip line\n   *\n   * @param {Axis} axis axis\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {number} startValue startValue\n   * @returns {number} next start value of the recurrence strip line\n   */\n  StripLine.prototype.getStartValue = function (axis, stripline, startValue) {\n    if (axis.valueType === 'DateTime') {\n      return this.getToValue(null, startValue, +stripline.repeatEvery, axis, null, stripline);\n    } else {\n      return startValue + +stripline.repeatEvery;\n    }\n  };\n  /**\n   * Finds the segment axis for a segmented strip line.\n   *\n   * @param {Axis[]} axes - The collection of axes.\n   * @param {Axis} axis - The axis.\n   * @param {StripLineSettingsModel} stripline - The strip line settings.\n   * @returns {Axis} - The segment axis.\n   * @private\n   */\n  StripLine.prototype.getSegmentAxis = function (axes, axis, stripline) {\n    var segment;\n    if (stripline.segmentAxisName == null) {\n      return axis.orientation === 'Horizontal' ? axes[1] : axes[0];\n    } else {\n      for (var i = 0; i < axes.length; i++) {\n        if (stripline.segmentAxisName === axes[i].name) {\n          segment = axes[i];\n        }\n      }\n      return segment;\n    }\n  };\n  /**\n   * To render strip line on chart\n   *\n   * @param {Axis} axis axis\n   * @param {StripLineSettingsModel} stripline stripline\n   * @param {Rect} seriesClipRect seriesClipRect\n   * @param {string} id id\n   * @param {Element} striplineGroup striplineGroup\n   * @param {Chart} chart chart\n   * @param {number} startValue startValue\n   * @param {Axis} segmentAxis segmentAxis\n   * @param {number} count count\n   * @returns {void}\n   */\n  StripLine.prototype.renderStripLineElement = function (axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count) {\n    var rect = this.measureStripLine(axis, stripline, seriesClipRect, startValue, segmentAxis, chart);\n    if (stripline.imageUrl) {\n      this.drawImage(stripline, rect, id + 'rect_' + axis.name + '_' + count, striplineGroup, chart);\n    } else {\n      this.renderPath(stripline, rect, id + (stripline.sizeType === 'Pixel' ? 'path_' : 'rect_') + axis.name + '_' + count, striplineGroup, chart, axis);\n      var pixelRect = new Rect(axis.orientation === 'Horizontal' ? rect.x - stripline.size / 2 : rect.x, axis.orientation === 'Vertical' ? rect.y - stripline.size / 2 : rect.y, rect.width ? rect.width : stripline.size, rect.height ? rect.height : stripline.size);\n      this.renderRectangle(stripline, stripline.sizeType === 'Pixel' ? pixelRect : rect, id + 'border_' + axis.name + '_' + count, striplineGroup, chart);\n    }\n    if (stripline.text !== '') {\n      this.renderText(stripline, rect, id + 'text_' + axis.name + '_' + count, striplineGroup, chart, axis);\n    }\n  };\n  /**\n   * Finds the factor of the text based on its anchor position.\n   *\n   * @param {Anchor} anchor - The text anchor position.\n   * @returns {number} - The factor.\n   * @private\n   */\n  StripLine.prototype.factor = function (anchor) {\n    var factor = 0;\n    switch (anchor) {\n      case 'Start':\n        factor = 1;\n        break;\n      case 'End':\n        factor = -1;\n        break;\n    }\n    return factor;\n  };\n  /**\n   * Finds the start value of the text based on its alignment.\n   *\n   * @param {number} xy - The coordinate value.\n   * @param {number} size - The size of the text.\n   * @param {Anchor} textAlignment - The text alignment.\n   * @returns {number} - The start value.\n   * @private\n   */\n  StripLine.prototype.getTextStart = function (xy, size, textAlignment) {\n    var padding = 5;\n    switch (textAlignment) {\n      case 'Start':\n        xy = xy - size / 2 + padding;\n        break;\n      case 'End':\n        xy = xy + size / 2 - padding;\n        break;\n    }\n    return xy;\n  };\n  /**\n   * To get the module name for `StripLine`.\n   *\n   * @private\n   * @returns {string} - Returns the module name.\n   */\n  StripLine.prototype.getModuleName = function () {\n    return 'StripLine';\n  };\n  /**\n   * To destroy the `StripLine` module.\n   *\n   * @private\n   * @returns {void}\n   */\n  StripLine.prototype.destroy = function () {\n    // destroy peform here\n  };\n  return StripLine;\n}();\nexport { StripLine };","map":{"version":3,"names":["isNullOrUndefined","valueToCoefficient","textElement","RectOption","appendChildElement","appendClipElement","withIn","getElement","ImageOption","logBase","measureText","TextOption","PathOption","Rect","DataUtil","StripLine","prototype","measureStripLine","axis","stripline","seriesClipRect","startValue","segmentAxis","chart","actualStart","actualEnd","orientation","isDateTimeAxis","valueType","isRepeat","size","start","end","labels","indexOf","dateToMilliSeconds","toString","isCoreDate","rect","getFromTovalue","startFromAxis","height","to","from","width","x","y","sizeType","isSegmented","segmentStart","segmentEnd","segRect","visibleRange","min","getToValue","Math","max","findValue","isAxisInverse","isEnd","fromValue","Date","actualIntervalType","interval","setFullYear","getFullYear","setMonth","getMonth","setDate","getDate","setHours","getHours","setMinutes","getMinutes","setSeconds","getSeconds","value","dateParse","dateParser","intl","getDateParser","skeleton","type","dateFormatter","getDateFormat","parse","parseJson","val","renderStripLine","position","axes","id","element","chartAxisLayoutPanel","limit","range","options","color","striplineGroup","renderer","createGroup","enableCanvas","appendChild","redraw","_i","axes_1","length","count","_a","_b","stripLines","visible","zIndex","getSegmentAxis","repeatEvery","repeatUntil","actualRange","visibleLabels","dateTimeInterval","renderStripLineElement","getStartValue","svgObject","getTime","renderPath","parent","direction","getAttribute","strokeWidth","d","drawPath","opacity","dashArray","duration","renderRectangle","previousRect","drawRectangle","border","drawImage","image","imageUrl","htmlObject","renderText","textSize","text","textStyle","themeStyle","stripLineLabelFont","isRotationNull","rotation","textMid","ty","tx","anchor","padding","getTextStart","factor","horizontalAlignment","verticalAlignment","invertAlignment","enableRtl","segment","segmentAxisName","i","name","pixelRect","xy","textAlignment","getModuleName","destroy"],"sources":["C:/Users/gabby/trax-x/node_modules/@syncfusion/ej2-charts/src/chart/axis/strip-line.js"],"sourcesContent":["/**\n * StripLine src\n */\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { valueToCoefficient, textElement, RectOption, appendChildElement, appendClipElement, withIn, getElement, ImageOption, logBase } from '../../common/utils/helper';\nimport { measureText, TextOption, PathOption, Rect } from '@syncfusion/ej2-svg-base';\nimport { DataUtil } from '@syncfusion/ej2-data';\n/**\n * The `StripLine` module is used to render strip lines in charts.\n */\nvar StripLine = /** @class */ (function () {\n    function StripLine() {\n    }\n    /**\n     * Finding x, y, width and height of the strip line\n     *\n     * @param {Axis} axis axis\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} seriesClipRect seriesClipRect\n     * @param {number} startValue startValue\n     * @param {Axis} segmentAxis segmentAxis\n     * @param {Chart} chart chart instance\n     * @returns {Rect} rect\n     */\n    StripLine.prototype.measureStripLine = function (axis, stripline, seriesClipRect, startValue, segmentAxis, chart) {\n        var actualStart;\n        var actualEnd;\n        var orientation = axis.orientation;\n        var isDateTimeAxis = axis.valueType === 'DateTime';\n        if (stripline.isRepeat && stripline.size !== null) {\n            actualStart = startValue;\n            actualEnd = null;\n        }\n        else {\n            if (axis.valueType === 'DateTimeCategory') {\n                var start = stripline.start;\n                var end = stripline.end;\n                actualStart = (start != null && typeof start !== 'number') ?\n                    axis.labels.indexOf(this.dateToMilliSeconds(start, chart).toString()) : start;\n                actualEnd = (end != null && typeof end !== 'number') ?\n                    axis.labels.indexOf(this.dateToMilliSeconds(end, chart).toString()) : end;\n            }\n            else {\n                actualStart = stripline.start === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ?\n                    this.dateToMilliSeconds(stripline.start, chart) : +(axis.valueType === 'Logarithmic' ? logBase(stripline.start, axis.logBase) : stripline.start);\n                actualEnd = stripline.end === null ? null : isDateTimeAxis && this.isCoreDate(stripline.start) ?\n                    this.dateToMilliSeconds(stripline.end, chart) : +(axis.valueType === 'Logarithmic' ? logBase(stripline.end, axis.logBase) : stripline.end);\n            }\n        }\n        var rect = this.getFromTovalue(actualStart, actualEnd, stripline.size, stripline.startFromAxis, axis, stripline);\n        var height = (orientation === 'Vertical') ? (rect.to - rect.from) * axis.rect.height : seriesClipRect.height;\n        var width = (orientation === 'Horizontal') ? (rect.to - rect.from) * axis.rect.width : seriesClipRect.width;\n        var x = (orientation === 'Vertical') ? seriesClipRect.x : ((rect.from * axis.rect.width) + axis.rect.x);\n        var y = (orientation === 'Horizontal') ? seriesClipRect.y : (axis.rect.y + axis.rect.height -\n            ((stripline.sizeType === 'Pixel' ? rect.from : rect.to) * axis.rect.height));\n        if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null && stripline.sizeType !== 'Pixel') {\n            var start = isDateTimeAxis && this.isCoreDate(stripline.segmentStart) ?\n                this.dateToMilliSeconds(stripline.segmentStart, chart) : +stripline.segmentStart;\n            var end = isDateTimeAxis && this.isCoreDate(stripline.segmentEnd) ?\n                this.dateToMilliSeconds(stripline.segmentEnd, chart) : +stripline.segmentEnd;\n            var segRect = this.getFromTovalue(start, end, null, null, segmentAxis, stripline);\n            if (segmentAxis.orientation === 'Vertical') {\n                y = (segmentAxis.rect.y + segmentAxis.rect.height -\n                    (segRect.to * segmentAxis.rect.height));\n                height = (segRect.to - segRect.from) * segmentAxis.rect.height;\n            }\n            else {\n                x = ((segRect.from * segmentAxis.rect.width) + segmentAxis.rect.x);\n                width = (segRect.to - segRect.from) * segmentAxis.rect.width;\n            }\n        }\n        if ((height !== 0 && width !== 0) || (stripline.sizeType === 'Pixel' && (stripline.start !== null || stripline.startFromAxis))) {\n            return new Rect(x, y, width, height);\n        }\n        return new Rect(0, 0, 0, 0);\n    };\n    /**\n     * Retrieves the 'from' and 'to' values from start, end, size, starting from the axis.\n     *\n     * @param {number} start - The start value.\n     * @param {number} end - The end value.\n     * @param {number} size - The size value.\n     * @param {boolean} startFromAxis - Indicates whether to start from the axis.\n     * @param {Axis} axis - The axis.\n     * @param {StripLineSettingsModel} stripline - The strip line settings.\n     * @returns {{ from: number, to: number }} - The 'from' and 'to' values.\n     * @private\n     */\n    StripLine.prototype.getFromTovalue = function (start, end, size, startFromAxis, axis, stripline) {\n        var from = (!stripline.isRepeat && startFromAxis) ? axis.visibleRange.min : start;\n        if (axis.valueType === 'Double' && size !== null && !startFromAxis && stripline.start == null) {\n            from += size;\n        }\n        var to = this.getToValue(Math.max(start, isNullOrUndefined(end) ? start : end), from, size, axis, end, stripline);\n        from = this.findValue(from, axis);\n        to = this.findValue(to, axis);\n        return { from: valueToCoefficient(axis.isAxisInverse ? to : from, axis),\n            to: valueToCoefficient(axis.isAxisInverse ? from : to, axis) };\n    };\n    /**\n     * Finding end value of the strip line\n     *\n     * @param {number} to to\n     * @param {number} from from\n     * @param {number} size size\n     * @param {Axis} axis axis\n     * @param {number} end end\n     * @param {StripLineSettingsModel} stripline stripline\n     * @returns {number} number\n     */\n    StripLine.prototype.getToValue = function (to, from, size, axis, end, stripline) {\n        var sizeType = stripline.sizeType;\n        var isEnd = (end === null);\n        if (axis.valueType === 'DateTime') {\n            var fromValue = new Date(from);\n            if (sizeType === 'Auto') {\n                sizeType = axis.actualIntervalType;\n                size *= axis.visibleRange.interval;\n            }\n            switch (sizeType) {\n                case 'Years':\n                    return (isEnd ? new Date(fromValue.setFullYear(fromValue.getFullYear() + size)) : to);\n                case 'Months':\n                    return (isEnd ? new Date(fromValue.setMonth(fromValue.getMonth() + size)) : to);\n                case 'Days':\n                    return (isEnd ? new Date(fromValue.setDate(fromValue.getDate() + size)) : to);\n                case 'Hours':\n                    return (isEnd ? new Date(fromValue.setHours(fromValue.getHours() + size)) : to);\n                case 'Minutes':\n                    return (isEnd ? new Date(fromValue.setMinutes(fromValue.getMinutes() + size)) : to);\n                case 'Seconds':\n                    return (isEnd ? new Date(fromValue.setSeconds(fromValue.getSeconds() + size)) : to);\n                default:\n                    return from;\n            }\n        }\n        else {\n            return stripline.sizeType === 'Pixel' ? from : (isEnd ? (from + size) : to);\n        }\n    };\n    /**\n     * To check the strip line values within range\n     *\n     * @param {number} value value\n     * @param {Axis} axis axis\n     * @returns {number} - To returns a strip line value.\n     */\n    StripLine.prototype.findValue = function (value, axis) {\n        if (value < axis.visibleRange.min) {\n            value = axis.visibleRange.min;\n        }\n        else if (value > axis.visibleRange.max) {\n            value = axis.visibleRange.max;\n        }\n        return value;\n    };\n    /**\n     * Date parse\n     *\n     * @param {Date} value date\n     * @param {Chart} chart chart instance\n     * @returns {Date} parsed date\n     */\n    StripLine.prototype.dateParse = function (value, chart) {\n        var dateParser = chart.intl.getDateParser({ skeleton: 'full', type: 'dateTime' });\n        var dateFormatter = chart.intl.getDateFormat({ skeleton: 'full', type: 'dateTime' });\n        return new Date((Date.parse(dateParser(dateFormatter(new Date(DataUtil.parse.parseJson({ val: value }).val))))));\n    };\n    /**\n     * To render strip lines based start and end.\n     *\n     * @param {Chart} chart chart\n     * @param {ZIndex} position position\n     * @param {Axis[]} axes axes\n     * @returns {void}\n     * @private\n     */\n    StripLine.prototype.renderStripLine = function (chart, position, axes) {\n        var id = chart.element.id + '_stripline_' + position + '_';\n        var seriesClipRect = chart.chartAxisLayoutPanel.seriesClipRect;\n        var end = 0;\n        var limit = 0;\n        var startValue = 0;\n        var segmentAxis = null;\n        var range;\n        var options = new RectOption(id + 'ClipRect', 'transparent', { width: 1, color: 'Gray' }, 1, {\n            x: seriesClipRect.x, y: seriesClipRect.y,\n            width: seriesClipRect.width,\n            height: seriesClipRect.height\n        });\n        var striplineGroup = chart.renderer.createGroup({\n            id: id + 'collections',\n            'clip-path': 'url(#' + id + 'ClipRect' + ')'\n        });\n        if (!chart.enableCanvas) {\n            striplineGroup.appendChild(appendClipElement(chart.redraw, options, chart.renderer));\n        }\n        for (var _i = 0, axes_1 = axes; _i < axes_1.length; _i++) {\n            var axis = axes_1[_i];\n            var count = 0;\n            for (var _a = 0, _b = axis.stripLines; _a < _b.length; _a++) {\n                var stripline = _b[_a];\n                if (stripline.visible && stripline.zIndex === position) {\n                    if (stripline.isSegmented && stripline.segmentStart != null && stripline.segmentEnd != null &&\n                        stripline.sizeType !== 'Pixel') {\n                        segmentAxis = this.getSegmentAxis(axes, axis, stripline);\n                    }\n                    if (stripline.isRepeat && stripline.repeatEvery != null && stripline.size !== null && stripline.sizeType !== 'Pixel') {\n                        limit = (stripline.repeatUntil != null) ? ((axis.valueType === 'DateTime') ?\n                            this.dateToMilliSeconds(stripline.repeatUntil, chart) : +stripline.repeatUntil) : axis.actualRange.max;\n                        startValue = axis.valueType === 'DateTime' && this.isCoreDate(stripline.start) ?\n                            this.dateToMilliSeconds(stripline.start, chart) : stripline.start;\n                        if ((stripline.startFromAxis && axis.valueType === 'DateTime' && stripline.sizeType === 'Auto') ||\n                            (stripline.start < axis.visibleRange.min)) {\n                            startValue = axis.visibleLabels[0] &&\n                                axis.visibleLabels[0].value === axis.visibleRange.min ? axis.visibleRange.min :\n                                axis.visibleLabels[0] && axis.visibleLabels[0].value - (axis.valueType === 'DateTime' ? axis.dateTimeInterval :\n                                    axis.visibleRange.interval);\n                        }\n                        startValue = stripline.startFromAxis && axis.valueType !== 'DateTime' ? axis.visibleRange.min : startValue;\n                        while (startValue < limit) {\n                            end = (startValue + (axis.valueType === 'DateTime' ? axis.dateTimeInterval * +stripline.size : stripline.size));\n                            range = withIn(end, axis.visibleRange);\n                            if ((startValue >= axis.visibleRange.min && startValue < axis.visibleRange.max) || range) {\n                                this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count);\n                            }\n                            count++;\n                            startValue = this.getStartValue(axis, stripline, startValue);\n                        }\n                    }\n                    else {\n                        this.renderStripLineElement(axis, stripline, seriesClipRect, id, striplineGroup, chart, null, segmentAxis, count);\n                        count++;\n                    }\n                }\n            }\n        }\n        appendChildElement(chart.enableCanvas, chart.svgObject, striplineGroup, chart.redraw);\n    };\n    /**\n     * To convert the C# date to js date\n     *\n     * @param {string | number | Object} value date value\n     * @returns {boolean} returns true if datetime value type is string(for asp platform)\n     */\n    StripLine.prototype.isCoreDate = function (value) {\n        return typeof value === 'string' ? true : false;\n    };\n    /**\n     * To get the total milli seconds\n     *\n     * @param {Date | number | Object} value date value\n     * @param {Chart} chart chart instance\n     * @returns {number} returns milliseconds\n     */\n    StripLine.prototype.dateToMilliSeconds = function (value, chart) {\n        return this.dateParse(value, chart).getTime();\n    };\n    /**\n     * To draw the single line strip line\n     *\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} rect rect\n     * @param {string} id id\n     * @param {Element} parent parent\n     * @param {Chart} chart chart\n     * @param {Axis} axis axis\n     * @returns {void}\n     */\n    StripLine.prototype.renderPath = function (stripline, rect, id, parent, chart, axis) {\n        var element = getElement(id);\n        var direction = element ? element.getAttribute('d') : '';\n        var strokeWidth = stripline.size;\n        var d = (axis.orientation === 'Vertical') ? ('M ' + rect.x + ' ' + rect.y + ' ' + 'L ' + (rect.x + rect.width)\n            + ' ' + rect.y) :\n            ('M ' + rect.x + ' ' + rect.y + ' ' + 'L ' + rect.x + ' ' + (rect.y + rect.height));\n        if (stripline.sizeType !== 'Pixel') {\n            d = (axis.orientation === 'Vertical') ? ('M ' + rect.x + ' ' + (rect.y + (rect.height / 2)) + ' ' + 'L ' + (rect.x + rect.width)\n                + ' ' + (rect.y + (rect.height / 2))) :\n                ('M ' + (rect.x + (rect.width / 2)) + ' ' + rect.y + ' ' + 'L ' + (rect.x + (rect.width / 2)) + ' ' + (rect.y + rect.height));\n            strokeWidth = axis.orientation === 'Vertical' ? rect.height : rect.width;\n        }\n        appendChildElement(chart.enableCanvas, parent, chart.renderer.drawPath(new PathOption(id, 'none', strokeWidth, stripline.color, stripline.opacity, stripline.dashArray, d)), chart.redraw, true, 'x', 'y', null, direction, true, null, null, chart.duration);\n    };\n    /**\n     * To draw the rectangle\n     *\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} rect rect\n     * @param {string} id id\n     * @param {Element} parent parent\n     * @param {Chart} chart chart\n     * @returns {void}\n     */\n    StripLine.prototype.renderRectangle = function (stripline, rect, id, parent, chart) {\n        var element = getElement(id);\n        var previousRect = element ? new Rect(+element.getAttribute('x'), +element.getAttribute('y'), +element.getAttribute('width'), +element.getAttribute('height')) : null;\n        appendChildElement(chart.enableCanvas, parent, chart.renderer.drawRectangle(new RectOption(id, 'none', stripline.border, stripline.opacity, rect, 0, 0, '', stripline.border.dashArray)), chart.redraw, true, 'x', 'y', null, null, true, true, previousRect, chart.duration);\n    };\n    /**\n     * To draw the Image\n     *\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} rect rect\n     * @param {string} id id\n     * @param {Element} parent parent\n     * @param {Chart} chart chart\n     * @returns {void}\n     */\n    StripLine.prototype.drawImage = function (stripline, rect, id, parent, chart) {\n        if (stripline.sizeType === 'Pixel') {\n            rect.width = rect.width ? rect.width : stripline.size;\n            rect.height = rect.height ? rect.height : stripline.size;\n        }\n        var image = new ImageOption(rect.height, rect.width, stripline.imageUrl, rect.x, rect.y, id, 'visible', 'none');\n        var htmlObject = chart.renderer.drawImage(image);\n        appendChildElement(chart.enableCanvas, parent, htmlObject, chart.redraw, true, 'x', 'y', null, null, true, true);\n    };\n    /**\n     * To create the text on strip line\n     *\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} rect rect\n     * @param {string} id id\n     * @param {Element} parent parent\n     * @param {Chart} chart chart\n     * @param {Axis} axis axis\n     * @returns {void}\n     */\n    StripLine.prototype.renderText = function (stripline, rect, id, parent, chart, axis) {\n        var textSize = measureText(stripline.text, stripline.textStyle, chart.themeStyle.stripLineLabelFont);\n        var isRotationNull = (stripline.rotation === null);\n        var textMid = isRotationNull ? 3 * (textSize.height / 8) : 0;\n        var ty = rect.y + (rect.height / 2) + textMid;\n        var rotation = isRotationNull ? ((axis.orientation === 'Vertical') ? 0 : -90) : stripline.rotation;\n        var tx = rect.x + (rect.width / 2);\n        var anchor;\n        var padding = 5;\n        if (axis.orientation === 'Horizontal') {\n            tx = this.getTextStart(tx + (textMid * this.factor(stripline.horizontalAlignment)), rect.width, stripline.horizontalAlignment);\n            ty = this.getTextStart(ty - textMid, rect.height, stripline.verticalAlignment) +\n                (stripline.verticalAlignment === 'Start' && !isRotationNull ? (textSize.height / 4) : 0);\n            anchor = isRotationNull ? this.invertAlignment(stripline.verticalAlignment) : stripline.horizontalAlignment;\n            anchor = tx - textSize.width / 2 < axis.rect.x ? 'Start' : tx + textSize.width / 2 > axis.rect.width ? 'End' : anchor;\n        }\n        else {\n            tx = this.getTextStart(tx, rect.width, stripline.horizontalAlignment);\n            ty = this.getTextStart(ty + (textMid * this.factor(stripline.verticalAlignment)) - padding, rect.height, stripline.verticalAlignment);\n            anchor = stripline.horizontalAlignment;\n            anchor = chart.enableRtl ? (anchor === 'End' ? 'Start' : anchor === 'Start' ? 'End' : anchor) : anchor;\n        }\n        textElement(chart.renderer, new TextOption(id, tx, ty, anchor, stripline.text, 'rotate(' + rotation + ' ' + tx + ',' + ty + ')', 'middle'), stripline.textStyle, stripline.textStyle.color || chart.themeStyle.stripLineLabelFont.color, parent, null, null, null, null, null, null, null, null, chart.enableCanvas, null, chart.themeStyle.stripLineLabelFont);\n    };\n    StripLine.prototype.invertAlignment = function (anchor) {\n        switch (anchor) {\n            case 'Start':\n                anchor = 'End';\n                break;\n            case 'End':\n                anchor = 'Start';\n                break;\n        }\n        return anchor;\n    };\n    /**\n     * To find the next value of the recurrence strip line\n     *\n     * @param {Axis} axis axis\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {number} startValue startValue\n     * @returns {number} next start value of the recurrence strip line\n     */\n    StripLine.prototype.getStartValue = function (axis, stripline, startValue) {\n        if (axis.valueType === 'DateTime') {\n            return (this.getToValue(null, startValue, +stripline.repeatEvery, axis, null, stripline));\n        }\n        else {\n            return startValue + (+stripline.repeatEvery);\n        }\n    };\n    /**\n     * Finds the segment axis for a segmented strip line.\n     *\n     * @param {Axis[]} axes - The collection of axes.\n     * @param {Axis} axis - The axis.\n     * @param {StripLineSettingsModel} stripline - The strip line settings.\n     * @returns {Axis} - The segment axis.\n     * @private\n     */\n    StripLine.prototype.getSegmentAxis = function (axes, axis, stripline) {\n        var segment;\n        if (stripline.segmentAxisName == null) {\n            return (axis.orientation === 'Horizontal') ? axes[1] : axes[0];\n        }\n        else {\n            for (var i = 0; i < axes.length; i++) {\n                if (stripline.segmentAxisName === axes[i].name) {\n                    segment = axes[i];\n                }\n            }\n            return segment;\n        }\n    };\n    /**\n     * To render strip line on chart\n     *\n     * @param {Axis} axis axis\n     * @param {StripLineSettingsModel} stripline stripline\n     * @param {Rect} seriesClipRect seriesClipRect\n     * @param {string} id id\n     * @param {Element} striplineGroup striplineGroup\n     * @param {Chart} chart chart\n     * @param {number} startValue startValue\n     * @param {Axis} segmentAxis segmentAxis\n     * @param {number} count count\n     * @returns {void}\n     */\n    StripLine.prototype.renderStripLineElement = function (axis, stripline, seriesClipRect, id, striplineGroup, chart, startValue, segmentAxis, count) {\n        var rect = this.measureStripLine(axis, stripline, seriesClipRect, startValue, segmentAxis, chart);\n        if (stripline.imageUrl) {\n            this.drawImage(stripline, rect, id + 'rect_' + axis.name + '_' + count, striplineGroup, chart);\n        }\n        else {\n            this.renderPath(stripline, rect, id + (stripline.sizeType === 'Pixel' ? 'path_' : 'rect_') + axis.name + '_' + count, striplineGroup, chart, axis);\n            var pixelRect = new Rect(axis.orientation === 'Horizontal' ? (rect.x - stripline.size / 2) : rect.x, axis.orientation === 'Vertical' ? (rect.y - stripline.size / 2) : rect.y, rect.width ? rect.width : stripline.size, rect.height ? rect.height : stripline.size);\n            this.renderRectangle(stripline, stripline.sizeType === 'Pixel' ? pixelRect : rect, id + 'border_' + axis.name + '_' + count, striplineGroup, chart);\n        }\n        if (stripline.text !== '') {\n            this.renderText(stripline, rect, id + 'text_' + axis.name + '_' + count, striplineGroup, chart, axis);\n        }\n    };\n    /**\n     * Finds the factor of the text based on its anchor position.\n     *\n     * @param {Anchor} anchor - The text anchor position.\n     * @returns {number} - The factor.\n     * @private\n     */\n    StripLine.prototype.factor = function (anchor) {\n        var factor = 0;\n        switch (anchor) {\n            case 'Start':\n                factor = 1;\n                break;\n            case 'End':\n                factor = -1;\n                break;\n        }\n        return factor;\n    };\n    /**\n     * Finds the start value of the text based on its alignment.\n     *\n     * @param {number} xy - The coordinate value.\n     * @param {number} size - The size of the text.\n     * @param {Anchor} textAlignment - The text alignment.\n     * @returns {number} - The start value.\n     * @private\n     */\n    StripLine.prototype.getTextStart = function (xy, size, textAlignment) {\n        var padding = 5;\n        switch (textAlignment) {\n            case 'Start':\n                xy = xy - (size / 2) + padding;\n                break;\n            case 'End':\n                xy = xy + (size / 2) - padding;\n                break;\n        }\n        return xy;\n    };\n    /**\n     * To get the module name for `StripLine`.\n     *\n     * @private\n     * @returns {string} - Returns the module name.\n     */\n    StripLine.prototype.getModuleName = function () {\n        return 'StripLine';\n    };\n    /**\n     * To destroy the `StripLine` module.\n     *\n     * @private\n     * @returns {void}\n     */\n    StripLine.prototype.destroy = function () {\n        // destroy peform here\n    };\n    return StripLine;\n}());\nexport { StripLine };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}