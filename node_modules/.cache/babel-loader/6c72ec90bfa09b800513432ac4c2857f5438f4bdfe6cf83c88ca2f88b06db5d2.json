{"ast":null,"code":"import * as React from \"react\";\nimport { isDefined, isNotDefined, getAxisCanvas, GenericChartComponent } from \"@react-financial-charts/core\";\n/**\n * `KagiSeries` tracks price movement mostly independantly of time.\n */\nexport class KagiSeries extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.drawOnCanvas = (ctx, moreProps) => {\n      const {\n        stroke,\n        strokeWidth,\n        currentValueStroke\n      } = this.props;\n      const {\n        xAccessor,\n        xScale,\n        chartConfig: {\n          yScale\n        },\n        plotData\n      } = moreProps;\n      const paths = this.helper(plotData, xAccessor);\n      let begin = true;\n      paths.forEach(each => {\n        // @ts-ignore\n        ctx.strokeStyle = stroke[each.type];\n        if (strokeWidth !== undefined) {\n          ctx.lineWidth = strokeWidth;\n        }\n        ctx.beginPath();\n        let prevX;\n        each.plot.forEach(d => {\n          const [x1, y] = [xScale(d[0]), yScale(d[1])];\n          if (begin) {\n            ctx.moveTo(x1, y);\n            begin = false;\n          } else {\n            if (isDefined(prevX)) {\n              ctx.lineTo(prevX, y);\n            }\n            ctx.lineTo(x1, y);\n          }\n          prevX = x1;\n        });\n        ctx.stroke();\n      });\n      const lastPlot = paths[paths.length - 1].plot;\n      const last = lastPlot[lastPlot.length - 1];\n      ctx.beginPath();\n      ctx.lineWidth = 1;\n      const [x, y1, y2] = [xScale(last[0]), yScale(last[2]), yScale(last[3])];\n      ctx.moveTo(x, y1);\n      ctx.lineTo(x + 10, y1);\n      ctx.stroke();\n      ctx.beginPath();\n      if (currentValueStroke !== undefined) {\n        ctx.strokeStyle = currentValueStroke;\n      }\n      ctx.moveTo(x - 10, y2);\n      ctx.lineTo(x, y2);\n      ctx.stroke();\n    };\n    this.helper = (plotData, xAccessor) => {\n      const kagiLine = [];\n      let kagi = {};\n      let d = plotData[0];\n      let idx = xAccessor(d);\n      // tslint:disable-next-line: prefer-for-of\n      for (let i = 0; i < plotData.length; i++) {\n        d = plotData[i];\n        if (isNotDefined(d.close)) {\n          continue;\n        }\n        if (isNotDefined(kagi.type)) {\n          kagi.type = d.startAs;\n        }\n        if (isNotDefined(kagi.plot)) {\n          kagi.plot = [];\n        }\n        idx = xAccessor(d);\n        kagi.plot.push([idx, d.open]);\n        if (isDefined(d.changeTo)) {\n          kagi.plot.push([idx, d.changePoint]);\n          kagi.added = true;\n          kagiLine.push(kagi);\n          kagi = {\n            type: d.changeTo,\n            plot: [],\n            added: false\n          };\n          kagi.plot.push([idx, d.changePoint]);\n        }\n      }\n      if (!kagi.added) {\n        kagi.plot.push([idx, d.close, d.current, d.reverseAt]);\n        kagiLine.push(kagi);\n      }\n      return kagiLine;\n    };\n  }\n  render() {\n    return React.createElement(GenericChartComponent, {\n      canvasToDraw: getAxisCanvas,\n      canvasDraw: this.drawOnCanvas,\n      drawOn: [\"pan\"]\n    });\n  }\n}\nKagiSeries.defaultProps = {\n  currentValueStroke: \"#000000\",\n  fill: {\n    yang: \"none\",\n    yin: \"none\"\n  },\n  stroke: {\n    yang: \"#26a69a\",\n    yin: \"#ef5350\"\n  },\n  strokeWidth: 2\n};","map":{"version":3,"names":["React","isDefined","isNotDefined","getAxisCanvas","GenericChartComponent","KagiSeries","Component","constructor","drawOnCanvas","ctx","moreProps","stroke","strokeWidth","currentValueStroke","props","xAccessor","xScale","chartConfig","yScale","plotData","paths","helper","begin","forEach","each","strokeStyle","type","undefined","lineWidth","beginPath","prevX","plot","d","x1","y","moveTo","lineTo","lastPlot","length","last","x","y1","y2","kagiLine","kagi","idx","i","close","startAs","push","open","changeTo","changePoint","added","current","reverseAt","render","createElement","canvasToDraw","canvasDraw","drawOn","defaultProps","fill","yang","yin"],"sources":["C:\\Users\\gabby\\trax-x\\node_modules\\@react-financial-charts\\series\\src\\KagiSeries.tsx"],"sourcesContent":["import * as React from \"react\";\nimport { isDefined, isNotDefined, getAxisCanvas, GenericChartComponent } from \"@react-financial-charts/core\";\n\nexport interface KagiSeriesProps {\n    /**\n     * Current value stroke\n     */\n    readonly currentValueStroke?: string;\n    /**\n     * Fill values.\n     */\n    readonly fill: {\n        yang: string;\n        yin: string;\n    };\n    /**\n     * Stroke values.\n     */\n    readonly stroke: {\n        yang: string;\n        yin: string;\n    };\n    /**\n     * Stroke width.\n     */\n    readonly strokeWidth?: number;\n}\n\n/**\n * `KagiSeries` tracks price movement mostly independantly of time.\n */\nexport class KagiSeries extends React.Component<KagiSeriesProps> {\n    public static defaultProps = {\n        currentValueStroke: \"#000000\",\n        fill: {\n            yang: \"none\",\n            yin: \"none\",\n        },\n        stroke: {\n            yang: \"#26a69a\",\n            yin: \"#ef5350\",\n        },\n        strokeWidth: 2,\n    };\n\n    public render() {\n        return <GenericChartComponent canvasToDraw={getAxisCanvas} canvasDraw={this.drawOnCanvas} drawOn={[\"pan\"]} />;\n    }\n\n    private readonly drawOnCanvas = (ctx: CanvasRenderingContext2D, moreProps: any) => {\n        const { stroke, strokeWidth, currentValueStroke } = this.props;\n        const {\n            xAccessor,\n            xScale,\n            chartConfig: { yScale },\n            plotData,\n        } = moreProps;\n\n        const paths = this.helper(plotData, xAccessor);\n\n        let begin = true;\n\n        paths.forEach((each) => {\n            // @ts-ignore\n            ctx.strokeStyle = stroke[each.type];\n            if (strokeWidth !== undefined) {\n                ctx.lineWidth = strokeWidth;\n            }\n\n            ctx.beginPath();\n            let prevX: any;\n            each.plot.forEach((d: any) => {\n                const [x1, y] = [xScale(d[0]), yScale(d[1])];\n                if (begin) {\n                    ctx.moveTo(x1, y);\n                    begin = false;\n                } else {\n                    if (isDefined(prevX)) {\n                        ctx.lineTo(prevX, y);\n                    }\n                    ctx.lineTo(x1, y);\n                }\n                prevX = x1;\n            });\n            ctx.stroke();\n        });\n\n        const lastPlot = paths[paths.length - 1].plot;\n        const last = lastPlot[lastPlot.length - 1];\n        ctx.beginPath();\n        ctx.lineWidth = 1;\n\n        const [x, y1, y2] = [xScale(last[0]), yScale(last[2]), yScale(last[3])];\n        ctx.moveTo(x, y1);\n        ctx.lineTo(x + 10, y1);\n        ctx.stroke();\n\n        ctx.beginPath();\n        if (currentValueStroke !== undefined) {\n            ctx.strokeStyle = currentValueStroke;\n        }\n        ctx.moveTo(x - 10, y2);\n        ctx.lineTo(x, y2);\n        ctx.stroke();\n    };\n\n    private readonly helper = (plotData: any[], xAccessor: any) => {\n        const kagiLine: any[] = [];\n        let kagi: {\n            added?: boolean;\n            plot?: any;\n            type?: any;\n        } = {};\n        let d = plotData[0];\n        let idx = xAccessor(d);\n\n        // tslint:disable-next-line: prefer-for-of\n        for (let i = 0; i < plotData.length; i++) {\n            d = plotData[i];\n\n            if (isNotDefined(d.close)) {\n                continue;\n            }\n            if (isNotDefined(kagi.type)) {\n                kagi.type = d.startAs;\n            }\n            if (isNotDefined(kagi.plot)) {\n                kagi.plot = [];\n            }\n\n            idx = xAccessor(d);\n            kagi.plot.push([idx, d.open]);\n\n            if (isDefined(d.changeTo)) {\n                kagi.plot.push([idx, d.changePoint]);\n                kagi.added = true;\n                kagiLine.push(kagi);\n\n                kagi = {\n                    type: d.changeTo,\n                    plot: [],\n                    added: false,\n                };\n                kagi.plot.push([idx, d.changePoint]);\n            }\n        }\n\n        if (!kagi.added) {\n            kagi.plot.push([idx, d.close, d.current, d.reverseAt]);\n            kagiLine.push(kagi);\n        }\n\n        return kagiLine;\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}