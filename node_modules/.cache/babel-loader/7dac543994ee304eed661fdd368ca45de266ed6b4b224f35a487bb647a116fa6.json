{"ast":null,"code":"import { max, min } from \"d3-array\";\nimport { getClosestItemIndexes, head, isDefined, isNotDefined, last } from \"../utils\";\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n  const {\n    lastItem,\n    lastItemX\n  } = fallbackEnd;\n  const lastItemXValue = xAccessor(lastItem);\n  const [rangeStart, rangeEnd] = initialXScale.range();\n  const newEnd = (rangeEnd - rangeStart) / (lastItemX.valueOf() - rangeStart) * (lastItemXValue.valueOf() - start.valueOf()) + start.valueOf();\n  return newEnd;\n}\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n  function filterData(data, inputDomain, xAccessor, initialXScale, {\n    currentPlotData,\n    currentDomain,\n    fallbackStart,\n    fallbackEnd,\n    ignoreThresholds = false\n  } = {}) {\n    if (useWholeData) {\n      return {\n        plotData: data,\n        domain: inputDomain\n      };\n    }\n    let left = head(inputDomain);\n    let right = last(inputDomain);\n    let clampedDomain = inputDomain;\n    let filteredData = getFilteredResponse(data, left, right, xAccessor);\n    if (filteredData.length === 1 && fallbackStart !== undefined) {\n      left = fallbackStart;\n      right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n      clampedDomain = [left, right];\n      filteredData = getFilteredResponse(data, left, right, xAccessor);\n    }\n    if (typeof clamp === \"function\") {\n      clampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n    } else {\n      if (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [max([left, xAccessor(head(data))]), clampedDomain[1]];\n      }\n      if (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [clampedDomain[0], min([right, xAccessor(last(data))])];\n      }\n    }\n    if (clampedDomain !== inputDomain) {\n      filteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n    }\n    const realInputDomain = clampedDomain;\n    const xScale = initialXScale.copy().domain(realInputDomain);\n    let width = Math.floor(xScale(xAccessor(last(filteredData))) - xScale(xAccessor(head(filteredData))));\n    // prevent negative width when flipXScale\n    if (flipXScale && width < 0) {\n      width = width * -1;\n    }\n    let plotData;\n    let domain;\n    const chartWidth = last(xScale.range()) - head(xScale.range());\n    if (ignoreThresholds && filteredData.length > 1 || canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n      plotData = filteredData;\n      domain = realInputDomain;\n    } else {\n      if (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n        plotData = filteredData;\n        const newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n        domain = [head(realInputDomain), newEnd];\n      } else {\n        plotData = currentPlotData !== null && currentPlotData !== void 0 ? currentPlotData : filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        domain = currentDomain !== null && currentDomain !== void 0 ? currentDomain : [xAccessor(head(plotData)), xAccessor(last(plotData))];\n      }\n    }\n    return {\n      plotData,\n      domain\n    };\n  }\n  return {\n    filterData\n  };\n}\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n  const widthAdjustedMinThreshold = showMinThreshold(width, minThreshold);\n  const widthAdjustedMaxTheshold = showMaxThreshold(width, maxThreshold);\n  return arrayLength >= widthAdjustedMinThreshold && arrayLength < widthAdjustedMaxTheshold;\n}\nfunction showMinThreshold(width, threshold) {\n  return Math.max(1, Math.ceil(width * threshold));\n}\nfunction showMaxThreshold(width, threshold) {\n  return Math.floor(width * threshold);\n}\nfunction showMax(width, threshold) {\n  return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\nfunction getFilteredResponse(data, left, right, xAccessor) {\n  const newLeftIndex = getClosestItemIndexes(data, left, xAccessor).left;\n  const newRightIndex = getClosestItemIndexes(data, right, xAccessor).right;\n  const filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n  return filteredData;\n}\nexport default function ({\n  xScale,\n  useWholeData,\n  clamp,\n  pointsPerPxThreshold,\n  minPointsPerPxThreshold,\n  flipXScale\n}) {\n  return extentsWrapper(useWholeData || isNotDefined(xScale.invert), clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale);\n}","map":{"version":3,"names":["max","min","getClosestItemIndexes","head","isDefined","isNotDefined","last","getNewEnd","fallbackEnd","xAccessor","initialXScale","start","lastItem","lastItemX","lastItemXValue","rangeStart","rangeEnd","range","newEnd","valueOf","extentsWrapper","useWholeData","clamp","pointsPerPxThreshold","minPointsPerPxThreshold","flipXScale","filterData","data","inputDomain","currentPlotData","currentDomain","fallbackStart","ignoreThresholds","plotData","domain","left","right","clampedDomain","filteredData","getFilteredResponse","length","undefined","realInputDomain","xScale","copy","width","Math","floor","chartWidth","canShowTheseManyPeriods","showMaxThreshold","slice","showMax","arrayLength","maxThreshold","minThreshold","widthAdjustedMinThreshold","showMinThreshold","widthAdjustedMaxTheshold","threshold","ceil","newLeftIndex","newRightIndex","invert"],"sources":["C:\\Users\\gabby\\trax-x\\node_modules\\@react-financial-charts\\core\\src\\utils\\evaluator.ts"],"sourcesContent":["import { max, min } from \"d3-array\";\nimport { ScaleContinuousNumeric, ScaleTime } from \"d3-scale\";\nimport { getClosestItemIndexes, head, isDefined, isNotDefined, last } from \"../utils\";\n\nfunction getNewEnd<T, TAccessor extends number | Date>(\n    fallbackEnd: { lastItem: T; lastItemX: TAccessor },\n    xAccessor: (item: T) => TAccessor,\n    initialXScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>,\n    start: any,\n) {\n    const { lastItem, lastItemX } = fallbackEnd;\n\n    const lastItemXValue = xAccessor(lastItem);\n\n    const [rangeStart, rangeEnd] = initialXScale.range();\n\n    const newEnd =\n        ((rangeEnd - rangeStart) / (lastItemX.valueOf() - rangeStart)) * (lastItemXValue.valueOf() - start.valueOf()) +\n        start.valueOf();\n\n    return newEnd;\n}\n\nfunction extentsWrapper<TDomain extends number | Date>(\n    useWholeData: boolean,\n    clamp:\n        | boolean\n        | \"left\"\n        | \"right\"\n        | \"both\"\n        | ((domain: [TDomain, TDomain], headTail: [TDomain, TDomain]) => [TDomain, TDomain]),\n    pointsPerPxThreshold: number,\n    minPointsPerPxThreshold: number,\n    flipXScale: boolean,\n) {\n    function filterData<T>(\n        data: T[],\n        inputDomain: [TDomain, TDomain],\n        xAccessor: (item: T) => TDomain,\n        initialXScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>,\n        { currentPlotData, currentDomain, fallbackStart, fallbackEnd, ignoreThresholds = false }: any = {},\n    ) {\n        if (useWholeData) {\n            return { plotData: data, domain: inputDomain };\n        }\n\n        let left: TDomain = head(inputDomain);\n        let right: TDomain = last(inputDomain);\n        let clampedDomain = inputDomain;\n\n        let filteredData = getFilteredResponse(data, left, right, xAccessor);\n        if (filteredData.length === 1 && fallbackStart !== undefined) {\n            left = fallbackStart;\n            right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n\n            clampedDomain = [left, right];\n            filteredData = getFilteredResponse(data, left, right, xAccessor);\n        }\n\n        if (typeof clamp === \"function\") {\n            clampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n        } else {\n            if (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n                clampedDomain = [max([left, xAccessor(head(data))])!, clampedDomain[1]];\n            }\n\n            if (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n                clampedDomain = [clampedDomain[0], min([right, xAccessor(last(data))])!];\n            }\n        }\n\n        if (clampedDomain !== inputDomain) {\n            filteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n        }\n\n        const realInputDomain = clampedDomain;\n\n        const xScale = initialXScale.copy().domain(realInputDomain) as\n            | ScaleContinuousNumeric<number, number>\n            | ScaleTime<number, number>;\n\n        let width = Math.floor(xScale(xAccessor(last(filteredData))) - xScale(xAccessor(head(filteredData))));\n\n        // prevent negative width when flipXScale\n        if (flipXScale && width < 0) {\n            width = width * -1;\n        }\n\n        let plotData: T[];\n        let domain: [number | Date, number | Date];\n\n        const chartWidth = last(xScale.range()) - head(xScale.range());\n\n        if (\n            (ignoreThresholds && filteredData.length > 1) ||\n            canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)\n        ) {\n            plotData = filteredData;\n            domain = realInputDomain;\n        } else {\n            if (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n                plotData = filteredData;\n                const newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n                domain = [head(realInputDomain), newEnd];\n            } else {\n                plotData =\n                    currentPlotData ?? filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n                domain = currentDomain ?? [xAccessor(head(plotData)), xAccessor(last(plotData))];\n            }\n        }\n        return { plotData, domain };\n    }\n    return { filterData };\n}\n\nfunction canShowTheseManyPeriods(width: number, arrayLength: number, maxThreshold: number, minThreshold: number) {\n    const widthAdjustedMinThreshold = showMinThreshold(width, minThreshold);\n    const widthAdjustedMaxTheshold = showMaxThreshold(width, maxThreshold);\n    return arrayLength >= widthAdjustedMinThreshold && arrayLength < widthAdjustedMaxTheshold;\n}\n\nfunction showMinThreshold(width: number, threshold: number) {\n    return Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width: number, threshold: number) {\n    return Math.floor(width * threshold);\n}\n\nfunction showMax(width: number, threshold: number) {\n    return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse<T, TAccessor extends number | Date>(\n    data: T[],\n    left: TAccessor,\n    right: TAccessor,\n    xAccessor: (item: T) => TAccessor,\n) {\n    const newLeftIndex = getClosestItemIndexes(data, left, xAccessor).left;\n    const newRightIndex = getClosestItemIndexes(data, right, xAccessor).right;\n\n    const filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n\n    return filteredData;\n}\n\nexport default function ({\n    xScale,\n    useWholeData,\n    clamp,\n    pointsPerPxThreshold,\n    minPointsPerPxThreshold,\n    flipXScale,\n}: any) {\n    return extentsWrapper(\n        useWholeData || isNotDefined(xScale.invert),\n        clamp,\n        pointsPerPxThreshold,\n        minPointsPerPxThreshold,\n        flipXScale,\n    );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}