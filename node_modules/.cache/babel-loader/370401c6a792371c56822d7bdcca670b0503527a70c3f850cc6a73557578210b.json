{"ast":null,"code":"import { group, merge } from \"d3-array\";\nimport { stack as d3Stack } from \"d3-shape\";\nimport * as React from \"react\";\nimport { functor, head, identity, getAxisCanvas, GenericChartComponent, plotDataLengthBarWidth } from \"@react-financial-charts/core\";\nexport class StackedBarSeries extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.drawOnCanvas = (ctx, moreProps) => {\n      const {\n        xAccessor\n      } = moreProps;\n      drawOnCanvasHelper(ctx, this.props, moreProps, xAccessor, d3Stack);\n    };\n  }\n  render() {\n    const {\n      clip\n    } = this.props;\n    return React.createElement(GenericChartComponent, {\n      clip: clip,\n      canvasDraw: this.drawOnCanvas,\n      canvasToDraw: getAxisCanvas,\n      drawOn: [\"pan\"]\n    });\n  }\n}\nStackedBarSeries.defaultProps = {\n  baseAt: (xScale, yScale) => head(yScale.range()),\n  direction: \"up\",\n  stroke: false,\n  fillStyle: \"rgba(70, 130, 180, 0.5)\",\n  width: plotDataLengthBarWidth,\n  widthRatio: 0.8,\n  clip: true,\n  swapScales: false\n};\nexport function identityStack() {\n  let keys = [];\n  function stack(data) {\n    const response = keys.map((key, i) => {\n      const arrays = data.map(d => {\n        const array = [0, d[key]];\n        // @ts-ignore\n        array.data = d;\n        return array;\n      });\n      arrays.key = key;\n      arrays.index = i;\n      return arrays;\n    });\n    return response;\n  }\n  stack.keys = function (x) {\n    if (!arguments.length) {\n      return keys;\n    }\n    keys = x;\n    return stack;\n  };\n  return stack;\n}\nexport function drawOnCanvasHelper(ctx, props, moreProps, xAccessor, stackFn, defaultPostAction = identity, postRotateAction = rotateXY) {\n  const {\n    xScale,\n    chartConfig: {\n      yScale\n    },\n    plotData\n  } = moreProps;\n  const bars = doStuff(props, xAccessor, plotData, xScale, yScale, stackFn, postRotateAction, defaultPostAction);\n  drawOnCanvas2(props, ctx, bars);\n}\nfunction convertToArray(item) {\n  return Array.isArray(item) ? item : [item];\n}\nconst doStuff = (props, xAccessor, plotData, xScale, yScale, stackFn, postRotateAction, defaultPostAction) => {\n  const {\n    yAccessor,\n    swapScales\n  } = props;\n  const modifiedYAccessor = swapScales ? convertToArray(xAccessor) : convertToArray(yAccessor);\n  const modifiedXAccessor = swapScales ? yAccessor : xAccessor;\n  const modifiedXScale = swapScales ? yScale : xScale;\n  const modifiedYScale = swapScales ? xScale : yScale;\n  const postProcessor = swapScales ? postRotateAction : defaultPostAction;\n  const bars = getBars(props, modifiedXAccessor, modifiedYAccessor, modifiedXScale, modifiedYScale, plotData, stackFn, postProcessor);\n  return bars;\n};\nexport const rotateXY = array => array.map(each => {\n  return Object.assign(Object.assign({}, each), {\n    x: each.y,\n    y: each.x,\n    height: each.width,\n    width: each.height\n  });\n});\nexport const drawOnCanvas2 = (props, ctx, bars) => {\n  const {\n    stroke\n  } = props;\n  const nest = group(bars, d => d.fillStyle);\n  nest.forEach((values, key) => {\n    if (head(values).width > 1) {\n      if (key !== undefined) {\n        ctx.strokeStyle = key;\n      }\n    }\n    ctx.fillStyle = key;\n    values.forEach(d => {\n      if (d.width <= 1) {\n        ctx.fillRect(d.x - 0.5, d.y, 1, d.height);\n      } else {\n        ctx.fillRect(d.x + 0.5, d.y + 0.5, d.width, d.height);\n        if (stroke) {\n          ctx.strokeRect(d.x, d.y, d.width, d.height);\n        }\n      }\n    });\n  });\n};\nexport function getBars(props, xAccessor, yAccessor, xScale, yScale, plotData, stack = identityStack, after = identity) {\n  const {\n    baseAt,\n    fillStyle,\n    stroke,\n    spaceBetweenBar = 0\n  } = props;\n  const getFill = functor(fillStyle);\n  const getBase = functor(baseAt);\n  const widthFunctor = functor(props.width);\n  const width = widthFunctor(props, {\n    xScale,\n    xAccessor,\n    plotData\n  });\n  const barWidth = Math.round(width);\n  const eachBarWidth = (barWidth - spaceBetweenBar * (yAccessor.length - 1)) / yAccessor.length;\n  const offset = barWidth === 1 ? 0 : 0.5 * width;\n  const ds = plotData.map(each => {\n    const d = {\n      appearance: {},\n      x: xAccessor(each)\n    };\n    yAccessor.forEach((eachYAccessor, i) => {\n      const key = `y${i}`;\n      // @ts-ignore\n      d[key] = eachYAccessor(each);\n      const appearance = {\n        stroke: stroke ? getFill(each, i) : \"none\",\n        fillStyle: getFill(each, i)\n      };\n      // @ts-ignore\n      d.appearance[key] = appearance;\n    });\n    return d;\n  });\n  const keys = yAccessor.map((_, i) => `y${i}`);\n  // @ts-ignore\n  const data = stack().keys(keys)(ds);\n  const newData = data.map((each, i) => {\n    const key = each.key;\n    return each.map(d => {\n      const array = [d[0], d[1]];\n      // @ts-ignore\n      array.data = {\n        x: d.data.x,\n        i,\n        appearance: d.data.appearance[key]\n      };\n      return array;\n    });\n  });\n  const bars = merge(newData).map(d => {\n    let y = yScale(d[1]);\n    let h = getBase(xScale, yScale, d.data) - yScale(d[1] - d[0]);\n    if (h < 0) {\n      y = y + h;\n      h = -h;\n    }\n    return Object.assign(Object.assign({}, d.data.appearance), {\n      x: Math.round(xScale(d.data.x) - width / 2),\n      y,\n      groupOffset: Math.round(offset - (d.data.i > 0 ? (eachBarWidth + spaceBetweenBar) * d.data.i : 0)),\n      groupWidth: Math.round(eachBarWidth),\n      offset: Math.round(offset),\n      height: h,\n      width: barWidth\n    });\n  }).filter(bar => !isNaN(bar.y));\n  return after(bars);\n}","map":{"version":3,"names":["group","merge","stack","d3Stack","React","functor","head","identity","getAxisCanvas","GenericChartComponent","plotDataLengthBarWidth","StackedBarSeries","Component","constructor","drawOnCanvas","ctx","moreProps","xAccessor","drawOnCanvasHelper","props","render","clip","createElement","canvasDraw","canvasToDraw","drawOn","defaultProps","baseAt","xScale","yScale","range","direction","stroke","fillStyle","width","widthRatio","swapScales","identityStack","keys","data","response","map","key","i","arrays","d","array","index","x","arguments","length","stackFn","defaultPostAction","postRotateAction","rotateXY","chartConfig","plotData","bars","doStuff","drawOnCanvas2","convertToArray","item","Array","isArray","yAccessor","modifiedYAccessor","modifiedXAccessor","modifiedXScale","modifiedYScale","postProcessor","getBars","each","Object","assign","y","height","nest","forEach","values","undefined","strokeStyle","fillRect","strokeRect","after","spaceBetweenBar","getFill","getBase","widthFunctor","barWidth","Math","round","eachBarWidth","offset","ds","appearance","eachYAccessor","_","newData","h","groupOffset","groupWidth","filter","bar","isNaN"],"sources":["C:\\Users\\gabby\\trax-x\\node_modules\\@react-financial-charts\\series\\src\\StackedBarSeries.tsx"],"sourcesContent":["import { group, merge } from \"d3-array\";\nimport { ScaleContinuousNumeric } from \"d3-scale\";\nimport { stack as d3Stack } from \"d3-shape\";\nimport * as React from \"react\";\nimport {\n    functor,\n    head,\n    identity,\n    getAxisCanvas,\n    GenericChartComponent,\n    plotDataLengthBarWidth,\n} from \"@react-financial-charts/core\";\n\nexport interface StackedBarSeriesProps {\n    readonly baseAt?:\n        | number\n        | ((\n              xScale: ScaleContinuousNumeric<number, number>,\n              yScale: ScaleContinuousNumeric<number, number>,\n              d: [number, number],\n              moreProps: any,\n          ) => number);\n    readonly clip?: boolean;\n    readonly direction?: \"up\" | \"down\";\n    readonly fillStyle?: string | ((data: any, y: number) => string);\n    readonly spaceBetweenBar?: number;\n    readonly stroke?: boolean;\n    readonly swapScales?: boolean;\n    readonly yAccessor: ((data: any) => number | undefined) | ((d: any) => number)[];\n    readonly width?: number | ((props: StackedBarSeriesProps, moreProps: any) => number);\n    readonly widthRatio?: number;\n}\n\nexport class StackedBarSeries extends React.Component<StackedBarSeriesProps> {\n    public static defaultProps = {\n        baseAt: (xScale: ScaleContinuousNumeric<number, number>, yScale: ScaleContinuousNumeric<number, number>) =>\n            head(yScale.range()),\n        direction: \"up\",\n        stroke: false,\n        fillStyle: \"rgba(70, 130, 180, 0.5)\",\n        width: plotDataLengthBarWidth,\n        widthRatio: 0.8,\n        clip: true,\n        swapScales: false,\n    };\n\n    public render() {\n        const { clip } = this.props;\n\n        return (\n            <GenericChartComponent\n                clip={clip}\n                canvasDraw={this.drawOnCanvas}\n                canvasToDraw={getAxisCanvas}\n                drawOn={[\"pan\"]}\n            />\n        );\n    }\n\n    private readonly drawOnCanvas = (ctx: CanvasRenderingContext2D, moreProps: any) => {\n        const { xAccessor } = moreProps;\n\n        drawOnCanvasHelper(ctx, this.props, moreProps, xAccessor, d3Stack);\n    };\n}\n\nexport function identityStack() {\n    let keys: any[] = [];\n    function stack(data: any) {\n        const response = keys.map((key, i) => {\n            const arrays = data.map((d: any) => {\n                const array = [0, d[key]];\n\n                // @ts-ignore\n                array.data = d;\n                return array;\n            });\n            arrays.key = key;\n            arrays.index = i;\n            return arrays;\n        });\n        return response;\n    }\n    stack.keys = function (x: any) {\n        if (!arguments.length) {\n            return keys;\n        }\n        keys = x;\n        return stack;\n    };\n    return stack;\n}\n\nexport function drawOnCanvasHelper(\n    ctx: CanvasRenderingContext2D,\n    props: any,\n    moreProps: any,\n    xAccessor: any,\n    stackFn: any,\n    defaultPostAction = identity,\n    postRotateAction = rotateXY,\n) {\n    const {\n        xScale,\n        chartConfig: { yScale },\n        plotData,\n    } = moreProps;\n\n    const bars = doStuff(props, xAccessor, plotData, xScale, yScale, stackFn, postRotateAction, defaultPostAction);\n\n    drawOnCanvas2(props, ctx, bars);\n}\n\nfunction convertToArray(item: any) {\n    return Array.isArray(item) ? item : [item];\n}\n\nconst doStuff = (\n    props: StackedBarSeriesProps,\n    xAccessor: any,\n    plotData: any[],\n    xScale: any,\n    yScale: any,\n    stackFn: any,\n    postRotateAction: any,\n    defaultPostAction: any,\n) => {\n    const { yAccessor, swapScales } = props;\n\n    const modifiedYAccessor = swapScales ? convertToArray(xAccessor) : convertToArray(yAccessor);\n    const modifiedXAccessor = swapScales ? yAccessor : xAccessor;\n\n    const modifiedXScale = swapScales ? yScale : xScale;\n    const modifiedYScale = swapScales ? xScale : yScale;\n\n    const postProcessor = swapScales ? postRotateAction : defaultPostAction;\n\n    const bars = getBars(\n        props,\n        modifiedXAccessor,\n        modifiedYAccessor,\n        modifiedXScale,\n        modifiedYScale,\n        plotData,\n        stackFn,\n        postProcessor,\n    );\n\n    return bars;\n};\n\nexport const rotateXY = (array: any[]) =>\n    array.map((each) => {\n        return {\n            ...each,\n            x: each.y,\n            y: each.x,\n            height: each.width,\n            width: each.height,\n        };\n    });\n\nexport const drawOnCanvas2 = (props: { stroke?: boolean }, ctx: CanvasRenderingContext2D, bars: any) => {\n    const { stroke } = props;\n\n    const nest = group(bars, (d: any) => d.fillStyle);\n\n    nest.forEach((values, key) => {\n        if (head(values).width > 1) {\n            if (key !== undefined) {\n                ctx.strokeStyle = key;\n            }\n        }\n        ctx.fillStyle = key;\n\n        values.forEach((d) => {\n            if (d.width <= 1) {\n                ctx.fillRect(d.x - 0.5, d.y, 1, d.height);\n            } else {\n                ctx.fillRect(d.x + 0.5, d.y + 0.5, d.width, d.height);\n                if (stroke) {\n                    ctx.strokeRect(d.x, d.y, d.width, d.height);\n                }\n            }\n        });\n    });\n};\n\nexport function getBars(\n    props: StackedBarSeriesProps,\n    xAccessor: any,\n    yAccessor: any,\n    xScale: any,\n    yScale: any,\n    plotData: any[],\n    stack = identityStack,\n    after = identity,\n) {\n    const { baseAt, fillStyle, stroke, spaceBetweenBar = 0 } = props;\n\n    const getFill = functor(fillStyle);\n    const getBase = functor(baseAt);\n\n    const widthFunctor = functor(props.width);\n    const width = widthFunctor(props, {\n        xScale,\n        xAccessor,\n        plotData,\n    });\n\n    const barWidth = Math.round(width);\n\n    const eachBarWidth = (barWidth - spaceBetweenBar * (yAccessor.length - 1)) / yAccessor.length;\n\n    const offset = barWidth === 1 ? 0 : 0.5 * width;\n\n    const ds = plotData.map((each) => {\n        const d = {\n            appearance: {},\n            x: xAccessor(each),\n        };\n        yAccessor.forEach((eachYAccessor: any, i: number) => {\n            const key = `y${i}`;\n            // @ts-ignore\n            d[key] = eachYAccessor(each);\n            const appearance = {\n                stroke: stroke ? getFill(each, i) : \"none\",\n                fillStyle: getFill(each, i),\n            };\n            // @ts-ignore\n            d.appearance[key] = appearance;\n        });\n        return d;\n    });\n\n    const keys = yAccessor.map((_: any, i: number) => `y${i}`);\n\n    // @ts-ignore\n    const data = stack().keys(keys)(ds);\n\n    const newData = data.map((each: any, i: number) => {\n        const key = each.key;\n        return each.map((d: any) => {\n            const array = [d[0], d[1]];\n\n            // @ts-ignore\n            array.data = {\n                x: d.data.x,\n                i,\n                appearance: d.data.appearance[key],\n            };\n            return array;\n        });\n    });\n\n    const bars = merge<any>(newData)\n        .map((d) => {\n            let y = yScale(d[1]);\n            let h = getBase(xScale, yScale, d.data) - yScale(d[1] - d[0]);\n            if (h < 0) {\n                y = y + h;\n                h = -h;\n            }\n\n            return {\n                ...d.data.appearance,\n                x: Math.round(xScale(d.data.x) - width / 2),\n                y,\n                groupOffset: Math.round(offset - (d.data.i > 0 ? (eachBarWidth + spaceBetweenBar) * d.data.i : 0)),\n                groupWidth: Math.round(eachBarWidth),\n                offset: Math.round(offset),\n                height: h,\n                width: barWidth,\n            };\n        })\n        .filter((bar) => !isNaN(bar.y));\n\n    return after(bars);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}