{"ast":null,"code":"import { extent as d3Extent, max, min } from \"d3-array\";\nimport * as React from \"react\";\nimport { clearCanvas, functor, head, identity, isDefined, isNotDefined, last, shallowEqual } from \"./utils\";\nimport { mouseBasedZoomAnchor } from \"./zoom\";\nimport { getChartConfigWithUpdatedYScales, getCurrentCharts, getCurrentItem, getNewChartConfig } from \"./utils/ChartDataUtil\";\nimport { EventCapture } from \"./EventCapture\";\nimport { CanvasContainer } from \"./CanvasContainer\";\nimport evaluator from \"./utils/evaluator\";\nconst CANDIDATES_FOR_RESET = [\"seriesName\"];\nconst shouldResetChart = (thisProps, nextProps) => {\n  return !CANDIDATES_FOR_RESET.every(key => {\n    const result = shallowEqual(thisProps[key], nextProps[key]);\n    return result;\n  });\n};\nconst getCursorStyle = () => {\n  const tooltipStyle = `\n\t.react-financial-charts-grabbing-cursor {\n\t\tpointer-events: all;\n\t\tcursor: -moz-grabbing;\n\t\tcursor: -webkit-grabbing;\n\t\tcursor: grabbing;\n\t}\n\t.react-financial-charts-crosshair-cursor {\n\t\tpointer-events: all;\n\t\tcursor: crosshair;\n\t}\n\t.react-financial-charts-tooltip-hover {\n\t\tpointer-events: all;\n\t\tcursor: pointer;\n\t}\n\t.react-financial-charts-avoid-interaction {\n\t\tpointer-events: none;\n\t}\n\t.react-financial-charts-enable-interaction {\n\t\tpointer-events: all;\n\t}\n\t.react-financial-charts-tooltip {\n\t\tpointer-events: all;\n\t\tcursor: pointer;\n\t}\n\t.react-financial-charts-default-cursor {\n\t\tcursor: default;\n\t}\n\t.react-financial-charts-move-cursor {\n\t\tcursor: move;\n\t}\n\t.react-financial-charts-pointer-cursor {\n\t\tcursor: pointer;\n\t}\n\t.react-financial-charts-ns-resize-cursor {\n\t\tcursor: ns-resize;\n\t}\n\t.react-financial-charts-ew-resize-cursor {\n\t\tcursor: ew-resize;\n\t}`;\n  return React.createElement(\"style\", {\n    type: \"text/css\"\n  }, tooltipStyle);\n};\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {};\nexport const chartCanvasContextDefaultValue = {\n  amIOnTop: () => false,\n  chartConfigs: [],\n  chartId: 0,\n  ratio: 0,\n  displayXAccessor: () => 0,\n  fullData: [],\n  getMutableState: () => ({}),\n  height: 0,\n  margin: {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  },\n  plotData: [],\n  setCursorClass: noop,\n  subscribe: noop,\n  unsubscribe: noop,\n  redraw: noop,\n  width: 0,\n  xAccessor: () => 0,\n  xScale: noop\n};\nexport const ChartCanvasContext = React.createContext(chartCanvasContextDefaultValue);\nconst getDimensions = props => {\n  const {\n    margin,\n    height,\n    width\n  } = props;\n  return {\n    height: height - margin.top - margin.bottom,\n    width: width - margin.left - margin.right\n  };\n};\nconst getXScaleDirection = flipXScale => {\n  return flipXScale ? -1 : 1;\n};\nconst calculateFullData = props => {\n  const {\n    data: fullData,\n    plotFull,\n    xScale,\n    clamp,\n    pointsPerPxThreshold,\n    flipXScale,\n    xAccessor,\n    displayXAccessor,\n    minPointsPerPxThreshold\n  } = props;\n  const useWholeData = plotFull !== undefined ? plotFull : xAccessor === identity;\n  const {\n    filterData\n  } = evaluator({\n    xScale,\n    useWholeData,\n    clamp,\n    pointsPerPxThreshold,\n    minPointsPerPxThreshold,\n    flipXScale\n  });\n  return {\n    xAccessor,\n    displayXAccessor: displayXAccessor !== null && displayXAccessor !== void 0 ? displayXAccessor : xAccessor,\n    xScale: xScale.copy(),\n    fullData,\n    filterData\n  };\n};\nconst resetChart = props => {\n  const state = calculateState(props);\n  const {\n    xAccessor,\n    displayXAccessor,\n    fullData,\n    plotData: initialPlotData,\n    xScale\n  } = state;\n  const {\n    postCalculator,\n    children\n  } = props;\n  const plotData = postCalculator !== undefined ? postCalculator(initialPlotData) : initialPlotData;\n  const dimensions = getDimensions(props);\n  const chartConfigs = getChartConfigWithUpdatedYScales(getNewChartConfig(dimensions, children), {\n    plotData,\n    xAccessor,\n    displayXAccessor,\n    fullData\n  }, xScale.domain());\n  return Object.assign(Object.assign({}, state), {\n    xScale,\n    plotData,\n    chartConfigs\n  });\n};\nconst updateChart = (newState, initialXScale, props, lastItemWasVisible, initialChartConfig) => {\n  const {\n    fullData,\n    xScale,\n    xAccessor,\n    displayXAccessor,\n    filterData\n  } = newState;\n  const lastItem = last(fullData);\n  const lastXItem = xAccessor(lastItem);\n  const [start, end] = initialXScale.domain();\n  const {\n    postCalculator,\n    children,\n    padding,\n    flipXScale,\n    maintainPointsPerPixelOnResize\n  } = props;\n  const direction = getXScaleDirection(flipXScale);\n  const dimensions = getDimensions(props);\n  const updatedXScale = setXRange(xScale, dimensions, padding, direction);\n  let initialPlotData;\n  if (!lastItemWasVisible || end >= lastXItem) {\n    // resize comes here...\n    // get plotData between [start, end] and do not change the domain\n    const [rangeStart, rangeEnd] = initialXScale.range();\n    const [newRangeStart, newRangeEnd] = updatedXScale.range();\n    const newDomainExtent = (newRangeEnd - newRangeStart) / (rangeEnd - rangeStart) * (end.valueOf() - start.valueOf());\n    const newStart = maintainPointsPerPixelOnResize ? end.valueOf() - newDomainExtent : start;\n    const lastItemX = initialXScale(lastXItem);\n    const response = filterData(fullData, [newStart, end], xAccessor, updatedXScale, {\n      fallbackStart: start,\n      fallbackEnd: {\n        lastItem,\n        lastItemX\n      }\n    });\n    initialPlotData = response.plotData;\n    updatedXScale.domain(response.domain);\n  } else if (lastItemWasVisible && end < lastXItem) {\n    // this is when a new item is added and last item was visible\n    // so slide over and show the new item also\n    // get plotData between [xAccessor(l) - (end - start), xAccessor(l)] and DO change the domain\n    const dx = initialXScale(lastXItem) - initialXScale.range()[1];\n    const [newStart, newEnd] = initialXScale.range().map(x => x + dx).map(x => initialXScale.invert(x));\n    const response = filterData(fullData, [newStart, newEnd], xAccessor, updatedXScale);\n    initialPlotData = response.plotData;\n    updatedXScale.domain(response.domain); // if last item was visible, then shift\n  }\n  const plotData = postCalculator(initialPlotData);\n  const chartConfigs = getChartConfigWithUpdatedYScales(getNewChartConfig(dimensions, children, initialChartConfig), {\n    plotData,\n    xAccessor,\n    displayXAccessor,\n    fullData\n  }, updatedXScale.domain());\n  return {\n    xScale: updatedXScale,\n    xAccessor,\n    chartConfigs,\n    plotData,\n    fullData,\n    filterData\n  };\n};\nconst calculateState = props => {\n  const {\n    xAccessor: inputXAccessor,\n    xExtents: xExtentsProp,\n    data,\n    padding,\n    flipXScale\n  } = props;\n  const direction = getXScaleDirection(flipXScale);\n  const dimensions = getDimensions(props);\n  const extent = typeof xExtentsProp === \"function\" ? xExtentsProp(data) : d3Extent(xExtentsProp.map(d => functor(d)).map(each => each(data, inputXAccessor)));\n  const {\n    xAccessor,\n    displayXAccessor,\n    xScale,\n    fullData,\n    filterData\n  } = calculateFullData(props);\n  const updatedXScale = setXRange(xScale, dimensions, padding, direction);\n  const {\n    plotData,\n    domain\n  } = filterData(fullData, extent, inputXAccessor, updatedXScale);\n  return {\n    plotData,\n    xScale: updatedXScale.domain(domain),\n    xAccessor,\n    displayXAccessor,\n    fullData,\n    filterData\n  };\n};\nconst setXRange = (xScale, dimensions, padding, direction = 1) => {\n  if (xScale.rangeRoundPoints) {\n    if (isNaN(padding)) {\n      throw new Error(\"padding has to be a number for ordinal scale\");\n    }\n    xScale.rangeRoundPoints([0, dimensions.width], padding);\n  } else if (xScale.padding) {\n    if (isNaN(padding)) {\n      throw new Error(\"padding has to be a number for ordinal scale\");\n    }\n    xScale.range([0, dimensions.width]);\n    xScale.padding(padding / 2);\n  } else {\n    const {\n      left,\n      right\n    } = isNaN(padding) ? padding : {\n      left: padding,\n      right: padding\n    };\n    if (direction > 0) {\n      xScale.range([left, dimensions.width - right]);\n    } else {\n      xScale.range([dimensions.width - right, left]);\n    }\n  }\n  return xScale;\n};\nconst pinchCoordinates = pinch => {\n  const {\n    touch1Pos,\n    touch2Pos\n  } = pinch;\n  return {\n    topLeft: [Math.min(touch1Pos[0], touch2Pos[0]), Math.min(touch1Pos[1], touch2Pos[1])],\n    bottomRight: [Math.max(touch1Pos[0], touch2Pos[0]), Math.max(touch1Pos[1], touch2Pos[1])]\n  };\n};\nconst isInteractionEnabled = (xScale, xAccessor, data) => {\n  const interaction = !isNaN(xScale(xAccessor(head(data)))) && isDefined(xScale.invert);\n  return interaction;\n};\nexport class ChartCanvas extends React.Component {\n  constructor(props) {\n    super(props);\n    this.canvasContainerRef = React.createRef();\n    this.eventCaptureRef = React.createRef();\n    this.lastSubscriptionId = 0;\n    this.mutableState = {\n      mouseXY: [0, 0],\n      currentCharts: [],\n      currentItem: null\n    };\n    this.panInProgress = false;\n    this.subscriptions = [];\n    this.getMutableState = () => {\n      return this.mutableState;\n    };\n    this.getCanvasContexts = () => {\n      var _a;\n      return (_a = this.canvasContainerRef.current) === null || _a === void 0 ? void 0 : _a.getCanvasContexts();\n    };\n    this.generateSubscriptionId = () => {\n      this.lastSubscriptionId++;\n      return this.lastSubscriptionId;\n    };\n    this.subscribe = (id, rest) => {\n      const {\n        getPanConditions = functor({\n          draggable: false,\n          panEnabled: true\n        })\n      } = rest;\n      this.subscriptions = this.subscriptions.concat(Object.assign(Object.assign({\n        id\n      }, rest), {\n        getPanConditions\n      }));\n    };\n    this.unsubscribe = id => {\n      this.subscriptions = this.subscriptions.filter(each => each.id !== id);\n    };\n    this.getAllPanConditions = () => {\n      return this.subscriptions.map(each => each.getPanConditions());\n    };\n    this.setCursorClass = className => {\n      var _a;\n      (_a = this.eventCaptureRef.current) === null || _a === void 0 ? void 0 : _a.setCursorClass(className);\n    };\n    this.amIOnTop = id => {\n      const dragableComponents = this.subscriptions.filter(each => each.getPanConditions().draggable);\n      return dragableComponents.length > 0 && last(dragableComponents).id === id;\n    };\n    this.handleContextMenu = (mouseXY, e) => {\n      const {\n        xAccessor,\n        chartConfigs,\n        plotData,\n        xScale\n      } = this.state;\n      const currentCharts = getCurrentCharts(chartConfigs, mouseXY);\n      const currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n      this.triggerEvent(\"contextmenu\", {\n        mouseXY,\n        currentItem,\n        currentCharts\n      }, e);\n    };\n    this.calculateStateForDomain = newDomain => {\n      const {\n        xAccessor,\n        displayXAccessor,\n        xScale: initialXScale,\n        chartConfigs: initialChartConfig,\n        plotData: initialPlotData\n      } = this.state;\n      const {\n        filterData,\n        fullData\n      } = this.state;\n      const {\n        postCalculator = ChartCanvas.defaultProps.postCalculator\n      } = this.props;\n      const {\n        plotData: beforePlotData,\n        domain\n      } = filterData(fullData, newDomain, xAccessor, initialXScale, {\n        currentPlotData: initialPlotData,\n        currentDomain: initialXScale.domain()\n      });\n      const plotData = postCalculator(beforePlotData);\n      const updatedScale = initialXScale.copy().domain(domain);\n      const chartConfigs = getChartConfigWithUpdatedYScales(initialChartConfig, {\n        plotData,\n        xAccessor,\n        displayXAccessor,\n        fullData\n      }, updatedScale.domain());\n      return {\n        xScale: updatedScale,\n        plotData,\n        chartConfigs\n      };\n    };\n    this.pinchZoomHelper = (initialPinch, finalPinch) => {\n      const {\n        xScale: initialPinchXScale\n      } = initialPinch;\n      const {\n        xScale: initialXScale,\n        chartConfigs: initialChartConfig,\n        plotData: initialPlotData,\n        xAccessor,\n        displayXAccessor,\n        filterData,\n        fullData\n      } = this.state;\n      const {\n        postCalculator = ChartCanvas.defaultProps.postCalculator\n      } = this.props;\n      const {\n        topLeft: iTL,\n        bottomRight: iBR\n      } = pinchCoordinates(initialPinch);\n      const {\n        topLeft: fTL,\n        bottomRight: fBR\n      } = pinchCoordinates(finalPinch);\n      const e = initialPinchXScale.range()[1];\n      const xDash = Math.round(-(iBR[0] * fTL[0] - iTL[0] * fBR[0]) / (iTL[0] - iBR[0]));\n      const yDash = Math.round(e + ((e - iBR[0]) * (e - fTL[0]) - (e - iTL[0]) * (e - fBR[0])) / (e - iTL[0] - (e - iBR[0])));\n      const x = Math.round(-xDash * iTL[0] / (-xDash + fTL[0]));\n      const y = Math.round(e - (yDash - e) * (e - iTL[0]) / (yDash + (e - fTL[0])));\n      const newDomain = [x, y].map(initialPinchXScale.invert);\n      const {\n        plotData: beforePlotData,\n        domain\n      } = filterData(fullData, newDomain, xAccessor, initialPinchXScale, {\n        currentPlotData: initialPlotData,\n        currentDomain: initialXScale.domain()\n      });\n      const plotData = postCalculator(beforePlotData);\n      const updatedScale = initialXScale.copy().domain(domain);\n      const mouseXY = finalPinch.touch1Pos;\n      const chartConfigs = getChartConfigWithUpdatedYScales(initialChartConfig, {\n        plotData,\n        xAccessor,\n        displayXAccessor,\n        fullData\n      }, updatedScale.domain());\n      const currentItem = getCurrentItem(updatedScale, xAccessor, mouseXY, plotData);\n      return {\n        chartConfigs,\n        xScale: updatedScale,\n        plotData,\n        mouseXY,\n        currentItem,\n        xAccessor,\n        fullData\n      };\n    };\n    this.handlePinchZoom = (initialPinch, finalPinch, e) => {\n      if (!this.waitingForPinchZoomAnimationFrame) {\n        this.waitingForPinchZoomAnimationFrame = true;\n        const state = this.pinchZoomHelper(initialPinch, finalPinch);\n        this.triggerEvent(\"pinchzoom\", state, e);\n        this.finalPinch = finalPinch;\n        requestAnimationFrame(() => {\n          this.clearBothCanvas();\n          this.draw({\n            trigger: \"pinchzoom\"\n          });\n          this.waitingForPinchZoomAnimationFrame = false;\n        });\n      }\n    };\n    this.handlePinchZoomEnd = (initialPinch, e) => {\n      const {\n        xAccessor = ChartCanvas.defaultProps.xAccessor\n      } = this.state;\n      if (this.finalPinch) {\n        const state = this.pinchZoomHelper(initialPinch, this.finalPinch);\n        const {\n          xScale,\n          fullData\n        } = state;\n        this.triggerEvent(\"pinchzoom\", state, e);\n        this.finalPinch = undefined;\n        this.clearThreeCanvas();\n        const firstItem = head(fullData);\n        const scale_start = head(xScale.domain());\n        const data_start = xAccessor(firstItem);\n        const lastItem = last(fullData);\n        const scale_end = last(xScale.domain());\n        const data_end = xAccessor(lastItem);\n        const {\n          onLoadAfter,\n          onLoadBefore\n        } = this.props;\n        this.setState(state, () => {\n          if (scale_start < data_start) {\n            if (onLoadBefore !== undefined) {\n              onLoadBefore(scale_start, data_start);\n            }\n          }\n          if (data_end < scale_end) {\n            if (onLoadAfter !== undefined) {\n              onLoadAfter(data_end, scale_end);\n            }\n          }\n        });\n      }\n    };\n    this.handleZoom = (zoomDirection, mouseXY, e) => {\n      if (this.panInProgress) {\n        return;\n      }\n      const {\n        xAccessor,\n        xScale: initialXScale,\n        plotData: initialPlotData,\n        fullData\n      } = this.state;\n      const {\n        zoomMultiplier = ChartCanvas.defaultProps.zoomMultiplier,\n        zoomAnchor = ChartCanvas.defaultProps.zoomAnchor\n      } = this.props;\n      const item = zoomAnchor({\n        xScale: initialXScale,\n        xAccessor: xAccessor,\n        mouseXY,\n        plotData: initialPlotData\n      });\n      const cx = initialXScale(item);\n      const c = zoomDirection > 0 ? 1 * zoomMultiplier : 1 / zoomMultiplier;\n      const newDomain = initialXScale.range().map(x => cx + (x - cx) * c).map(x => initialXScale.invert(x));\n      const {\n        xScale,\n        plotData,\n        chartConfigs\n      } = this.calculateStateForDomain(newDomain);\n      const currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n      const currentCharts = getCurrentCharts(chartConfigs, mouseXY);\n      this.clearThreeCanvas();\n      const firstItem = head(fullData);\n      const scale_start = head(xScale.domain());\n      const data_start = xAccessor(firstItem);\n      const lastItem = last(fullData);\n      const scale_end = last(xScale.domain());\n      const data_end = xAccessor(lastItem);\n      this.mutableState = {\n        mouseXY,\n        currentItem,\n        currentCharts\n      };\n      this.triggerEvent(\"zoom\", {\n        xScale,\n        plotData,\n        chartConfigs,\n        mouseXY,\n        currentCharts,\n        currentItem,\n        show: true\n      }, e);\n      const {\n        onLoadAfter,\n        onLoadBefore\n      } = this.props;\n      this.setState({\n        xScale,\n        plotData,\n        chartConfigs\n      }, () => {\n        if (scale_start < data_start) {\n          if (onLoadBefore !== undefined) {\n            onLoadBefore(scale_start, data_start);\n          }\n        }\n        if (data_end < scale_end) {\n          if (onLoadAfter !== undefined) {\n            onLoadAfter(data_end, scale_end);\n          }\n        }\n      });\n    };\n    this.xAxisZoom = newDomain => {\n      const {\n        xScale,\n        plotData,\n        chartConfigs\n      } = this.calculateStateForDomain(newDomain);\n      this.clearThreeCanvas();\n      const {\n        xAccessor,\n        fullData\n      } = this.state;\n      const firstItem = head(fullData);\n      const scale_start = head(xScale.domain());\n      const data_start = xAccessor(firstItem);\n      const lastItem = last(fullData);\n      const scale_end = last(xScale.domain());\n      const data_end = xAccessor(lastItem);\n      const {\n        onLoadAfter,\n        onLoadBefore\n      } = this.props;\n      this.setState({\n        xScale,\n        plotData,\n        chartConfigs\n      }, () => {\n        if (scale_start < data_start) {\n          if (onLoadBefore !== undefined) {\n            onLoadBefore(scale_start, data_start);\n          }\n        }\n        if (data_end < scale_end) {\n          if (onLoadAfter !== undefined) {\n            onLoadAfter(data_end, scale_end);\n          }\n        }\n      });\n    };\n    this.yAxisZoom = (chartId, newDomain) => {\n      this.clearThreeCanvas();\n      const {\n        chartConfigs: initialChartConfig\n      } = this.state;\n      const chartConfigs = initialChartConfig.map(each => {\n        if (each.id === chartId) {\n          const {\n            yScale\n          } = each;\n          return Object.assign(Object.assign({}, each), {\n            yScale: yScale.copy().domain(newDomain),\n            yPanEnabled: true\n          });\n        } else {\n          return each;\n        }\n      });\n      this.setState({\n        chartConfigs\n      });\n    };\n    this.draw = props => {\n      this.subscriptions.forEach(each => {\n        if (isDefined(each.draw)) {\n          each.draw(props);\n        }\n      });\n    };\n    this.redraw = () => {\n      this.clearThreeCanvas();\n      this.draw({\n        force: true\n      });\n    };\n    this.panHelper = (mouseXY, initialXScale, {\n      dx,\n      dy\n    }, chartsToPan) => {\n      const {\n        xAccessor,\n        displayXAccessor,\n        chartConfigs: initialChartConfig,\n        filterData,\n        fullData\n      } = this.state;\n      const {\n        postCalculator = ChartCanvas.defaultProps.postCalculator\n      } = this.props;\n      const newDomain = initialXScale.range().map(x => x - dx).map(x => initialXScale.invert(x));\n      const {\n        plotData: beforePlotData,\n        domain\n      } = filterData(fullData, newDomain, xAccessor, initialXScale, {\n        currentPlotData: this.hackyWayToStopPanBeyondBounds__plotData,\n        currentDomain: this.hackyWayToStopPanBeyondBounds__domain,\n        ignoreThresholds: true\n      });\n      const updatedScale = initialXScale.copy().domain(domain);\n      const plotData = postCalculator(beforePlotData);\n      const currentItem = getCurrentItem(updatedScale, xAccessor, mouseXY, plotData);\n      const chartConfigs = getChartConfigWithUpdatedYScales(initialChartConfig, {\n        plotData,\n        xAccessor,\n        displayXAccessor,\n        fullData\n      }, updatedScale.domain(), dy, chartsToPan);\n      const currentCharts = getCurrentCharts(chartConfigs, mouseXY);\n      return {\n        xScale: updatedScale,\n        plotData,\n        chartConfigs,\n        mouseXY,\n        currentCharts,\n        currentItem\n      };\n    };\n    this.handlePan = (mousePosition, panStartXScale, dxdy, chartsToPan, e) => {\n      var _a, _b;\n      if (this.waitingForPanAnimationFrame) {\n        return;\n      }\n      this.waitingForPanAnimationFrame = true;\n      this.hackyWayToStopPanBeyondBounds__plotData = (_a = this.hackyWayToStopPanBeyondBounds__plotData) !== null && _a !== void 0 ? _a : this.state.plotData;\n      this.hackyWayToStopPanBeyondBounds__domain = (_b = this.hackyWayToStopPanBeyondBounds__domain) !== null && _b !== void 0 ? _b : this.state.xScale.domain();\n      const newState = this.panHelper(mousePosition, panStartXScale, dxdy, chartsToPan);\n      this.hackyWayToStopPanBeyondBounds__plotData = newState.plotData;\n      this.hackyWayToStopPanBeyondBounds__domain = newState.xScale.domain();\n      this.panInProgress = true;\n      this.triggerEvent(\"pan\", newState, e);\n      this.mutableState = {\n        mouseXY: newState.mouseXY,\n        currentItem: newState.currentItem,\n        currentCharts: newState.currentCharts\n      };\n      requestAnimationFrame(() => {\n        this.waitingForPanAnimationFrame = false;\n        this.clearBothCanvas();\n        this.draw({\n          trigger: \"pan\"\n        });\n      });\n    };\n    this.handlePanEnd = (mousePosition, panStartXScale, dxdy, chartsToPan, e) => {\n      const state = this.panHelper(mousePosition, panStartXScale, dxdy, chartsToPan);\n      this.hackyWayToStopPanBeyondBounds__plotData = null;\n      this.hackyWayToStopPanBeyondBounds__domain = null;\n      this.panInProgress = false;\n      const {\n        xScale,\n        plotData,\n        chartConfigs\n      } = state;\n      this.triggerEvent(\"panend\", state, e);\n      requestAnimationFrame(() => {\n        const {\n          xAccessor,\n          fullData\n        } = this.state;\n        const firstItem = head(fullData);\n        const scale_start = head(xScale.domain());\n        const data_start = xAccessor(firstItem);\n        const lastItem = last(fullData);\n        const scale_end = last(xScale.domain());\n        const data_end = xAccessor(lastItem);\n        const {\n          onLoadAfter,\n          onLoadBefore\n        } = this.props;\n        this.clearThreeCanvas();\n        this.setState({\n          xScale,\n          plotData,\n          chartConfigs\n        }, () => {\n          if (scale_start < data_start) {\n            if (onLoadBefore !== undefined) {\n              onLoadBefore(scale_start, data_start);\n            }\n          }\n          if (data_end < scale_end) {\n            if (onLoadAfter !== undefined) {\n              onLoadAfter(data_end, scale_end);\n            }\n          }\n        });\n      });\n    };\n    this.handleMouseDown = (_, __, e) => {\n      this.triggerEvent(\"mousedown\", this.mutableState, e);\n    };\n    this.handleMouseEnter = e => {\n      this.triggerEvent(\"mouseenter\", {\n        show: true\n      }, e);\n    };\n    this.handleMouseMove = (mouseXY, _, e) => {\n      if (this.waitingForMouseMoveAnimationFrame) {\n        return;\n      }\n      this.waitingForMouseMoveAnimationFrame = true;\n      const {\n        chartConfigs,\n        plotData,\n        xScale,\n        xAccessor\n      } = this.state;\n      const currentCharts = getCurrentCharts(chartConfigs, mouseXY);\n      const currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n      this.triggerEvent(\"mousemove\", {\n        show: true,\n        mouseXY,\n        // prevMouseXY is used in interactive components\n        prevMouseXY: this.prevMouseXY,\n        currentItem,\n        currentCharts\n      }, e);\n      this.prevMouseXY = mouseXY;\n      this.mutableState = {\n        mouseXY,\n        currentItem,\n        currentCharts\n      };\n      requestAnimationFrame(() => {\n        this.clearMouseCanvas();\n        this.draw({\n          trigger: \"mousemove\"\n        });\n        this.waitingForMouseMoveAnimationFrame = false;\n      });\n    };\n    this.handleMouseLeave = e => {\n      this.triggerEvent(\"mouseleave\", {\n        show: false\n      }, e);\n      this.clearMouseCanvas();\n      this.draw({\n        trigger: \"mouseleave\"\n      });\n    };\n    this.handleDragStart = ({\n      startPos\n    }, e) => {\n      this.triggerEvent(\"dragstart\", {\n        startPos\n      }, e);\n    };\n    this.handleDrag = ({\n      startPos,\n      mouseXY\n    }, e) => {\n      const {\n        chartConfigs,\n        plotData,\n        xScale,\n        xAccessor\n      } = this.state;\n      const currentCharts = getCurrentCharts(chartConfigs, mouseXY);\n      const currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n      this.triggerEvent(\"drag\", {\n        startPos,\n        mouseXY,\n        currentItem,\n        currentCharts\n      }, e);\n      this.mutableState = {\n        mouseXY,\n        currentItem,\n        currentCharts\n      };\n      requestAnimationFrame(() => {\n        this.clearMouseCanvas();\n        this.draw({\n          trigger: \"drag\"\n        });\n      });\n    };\n    this.handleDragEnd = ({\n      mouseXY\n    }, e) => {\n      this.triggerEvent(\"dragend\", {\n        mouseXY\n      }, e);\n      requestAnimationFrame(() => {\n        this.clearMouseCanvas();\n        this.draw({\n          trigger: \"dragend\"\n        });\n      });\n    };\n    this.handleClick = (_, e) => {\n      this.triggerEvent(\"click\", this.mutableState, e);\n      requestAnimationFrame(() => {\n        this.clearMouseCanvas();\n        this.draw({\n          trigger: \"click\"\n        });\n      });\n    };\n    this.handleDoubleClick = (_, e) => {\n      this.triggerEvent(\"dblclick\", {}, e);\n    };\n    this.resetYDomain = chartId => {\n      const {\n        chartConfigs\n      } = this.state;\n      let changed = false;\n      const newChartConfig = chartConfigs.map(each => {\n        if ((isNotDefined(chartId) || each.id === chartId) && !shallowEqual(each.yScale.domain(), each.realYDomain)) {\n          changed = true;\n          return Object.assign(Object.assign({}, each), {\n            yScale: each.yScale.domain(each.realYDomain),\n            yPanEnabled: false\n          });\n        }\n        return each;\n      });\n      if (changed) {\n        this.clearThreeCanvas();\n        this.setState({\n          chartConfigs: newChartConfig\n        });\n      }\n    };\n    this.state = resetChart(props);\n  }\n  static getDerivedStateFromProps(props, state) {\n    var _a;\n    const {\n      chartConfigs: initialChartConfig,\n      plotData,\n      xAccessor,\n      xScale\n    } = state;\n    const interaction = isInteractionEnabled(xScale, xAccessor, plotData);\n    const shouldReset = shouldResetChart(state.lastProps || {}, props);\n    let newState;\n    if (!interaction || shouldReset || !shallowEqual((_a = state.lastProps) === null || _a === void 0 ? void 0 : _a.xExtents, props.xExtents)) {\n      // do reset\n      newState = resetChart(props);\n    } else {\n      const [start, end] = xScale.domain();\n      const prevLastItem = last(state.fullData);\n      const calculatedState = calculateFullData(props);\n      const {\n        xAccessor\n      } = calculatedState;\n      const previousX = xAccessor(prevLastItem);\n      const lastItemWasVisible = previousX <= end && previousX >= start;\n      newState = updateChart(calculatedState, xScale, props, lastItemWasVisible, initialChartConfig);\n    }\n    return Object.assign(Object.assign({}, newState), {\n      lastProps: props,\n      propIteration: (state.propIteration || 0) + 1\n    });\n  }\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // propIteration is incremented when the props change to differentiate between state updates\n    // and prop updates\n    if (prevState.propIteration !== this.state.propIteration && !this.panInProgress) {\n      this.clearThreeCanvas();\n    }\n    return null;\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.data !== this.props.data) {\n      this.triggerEvent(\"dataupdated\", {\n        chartConfigs: this.state.chartConfigs,\n        xScale: this.state.xScale,\n        plotData: this.state.plotData\n      });\n    }\n  }\n  clearBothCanvas() {\n    const canvases = this.getCanvasContexts();\n    if (canvases && canvases.axes && canvases.mouseCoord) {\n      clearCanvas([canvases.axes, canvases.mouseCoord], this.props.ratio);\n    }\n  }\n  clearMouseCanvas() {\n    const canvases = this.getCanvasContexts();\n    if (canvases && canvases.mouseCoord) {\n      clearCanvas([canvases.mouseCoord], this.props.ratio);\n    }\n  }\n  clearThreeCanvas() {\n    const canvases = this.getCanvasContexts();\n    if (canvases && canvases.axes && canvases.mouseCoord && canvases.bg) {\n      clearCanvas([canvases.axes, canvases.mouseCoord, canvases.bg], this.props.ratio);\n    }\n  }\n  cancelDrag() {\n    var _a;\n    (_a = this.eventCaptureRef.current) === null || _a === void 0 ? void 0 : _a.cancelDrag();\n    this.triggerEvent(\"dragcancel\");\n  }\n  triggerEvent(type, props, e) {\n    this.subscriptions.forEach(each => {\n      const state = Object.assign(Object.assign({}, this.state), {\n        subscriptions: this.subscriptions\n      });\n      each.listener(type, props, state, e);\n    });\n  }\n  // TODO: Memoize this\n  getContextValues() {\n    const dimensions = getDimensions(this.props);\n    return {\n      chartId: -1,\n      fullData: this.state.fullData,\n      plotData: this.state.plotData,\n      width: dimensions.width,\n      height: dimensions.height,\n      chartConfigs: this.state.chartConfigs,\n      xScale: this.state.xScale,\n      xAccessor: this.state.xAccessor,\n      displayXAccessor: this.state.displayXAccessor,\n      margin: this.props.margin,\n      ratio: this.props.ratio,\n      xAxisZoom: this.xAxisZoom,\n      yAxisZoom: this.yAxisZoom,\n      getCanvasContexts: this.getCanvasContexts,\n      redraw: this.redraw,\n      subscribe: this.subscribe,\n      unsubscribe: this.unsubscribe,\n      generateSubscriptionId: this.generateSubscriptionId,\n      getMutableState: this.getMutableState,\n      amIOnTop: this.amIOnTop,\n      setCursorClass: this.setCursorClass\n    };\n  }\n  shouldComponentUpdate() {\n    return !this.panInProgress;\n  }\n  render() {\n    const {\n      disableInteraction,\n      disablePan,\n      disableZoom,\n      useCrossHairStyleCursor,\n      onClick,\n      onDoubleClick,\n      height,\n      width,\n      margin = ChartCanvas.defaultProps.margin,\n      className,\n      zIndex = ChartCanvas.defaultProps.zIndex,\n      defaultFocus,\n      ratio,\n      mouseMoveEvent\n    } = this.props;\n    const {\n      plotData,\n      xScale,\n      xAccessor,\n      chartConfigs\n    } = this.state;\n    const dimensions = getDimensions(this.props);\n    const interaction = isInteractionEnabled(xScale, xAccessor, plotData);\n    const cursorStyle = useCrossHairStyleCursor && interaction;\n    const cursor = getCursorStyle();\n    return React.createElement(ChartCanvasContext.Provider, {\n      value: this.getContextValues()\n    }, React.createElement(\"div\", {\n      style: {\n        position: \"relative\",\n        width,\n        height\n      },\n      className: className,\n      onClick: onClick,\n      onDoubleClick: onDoubleClick\n    }, React.createElement(CanvasContainer, {\n      ref: this.canvasContainerRef,\n      ratio: ratio,\n      width: width,\n      height: height,\n      style: {\n        height,\n        zIndex,\n        width\n      }\n    }), React.createElement(\"svg\", {\n      className: className,\n      width: width,\n      height: height,\n      style: {\n        position: \"absolute\",\n        zIndex: zIndex + 5\n      }\n    }, cursor, React.createElement(\"defs\", null, React.createElement(\"clipPath\", {\n      id: \"chart-area-clip\"\n    }, React.createElement(\"rect\", {\n      x: \"0\",\n      y: \"0\",\n      width: dimensions.width,\n      height: dimensions.height\n    })), chartConfigs.map((each, idx) => React.createElement(\"clipPath\", {\n      key: idx,\n      id: `chart-area-clip-${each.id}`\n    }, React.createElement(\"rect\", {\n      x: \"0\",\n      y: \"0\",\n      width: each.width,\n      height: each.height\n    })))), React.createElement(\"g\", {\n      transform: `translate(${margin.left + 0.5}, ${margin.top + 0.5})`\n    }, React.createElement(EventCapture, {\n      ref: this.eventCaptureRef,\n      useCrossHairStyleCursor: cursorStyle,\n      mouseMove: mouseMoveEvent && interaction,\n      zoom: !disableZoom && interaction,\n      pan: !disablePan && interaction,\n      width: dimensions.width,\n      height: dimensions.height,\n      chartConfig: chartConfigs,\n      xScale: xScale,\n      xAccessor: xAccessor,\n      focus: defaultFocus,\n      disableInteraction: disableInteraction,\n      getAllPanConditions: this.getAllPanConditions,\n      onContextMenu: this.handleContextMenu,\n      onClick: this.handleClick,\n      onDoubleClick: this.handleDoubleClick,\n      onMouseDown: this.handleMouseDown,\n      onMouseMove: this.handleMouseMove,\n      onMouseEnter: this.handleMouseEnter,\n      onMouseLeave: this.handleMouseLeave,\n      onDragStart: this.handleDragStart,\n      onDrag: this.handleDrag,\n      onDragComplete: this.handleDragEnd,\n      onZoom: this.handleZoom,\n      onPinchZoom: this.handlePinchZoom,\n      onPinchZoomEnd: this.handlePinchZoomEnd,\n      onPan: this.handlePan,\n      onPanEnd: this.handlePanEnd\n    }), React.createElement(\"g\", {\n      className: \"react-financial-charts-avoid-interaction\"\n    }, this.props.children)))));\n  }\n}\nChartCanvas.defaultProps = {\n  clamp: false,\n  className: \"react-financial-charts\",\n  defaultFocus: true,\n  disablePan: false,\n  disableInteraction: false,\n  disableZoom: false,\n  flipXScale: false,\n  maintainPointsPerPixelOnResize: true,\n  margin: {\n    top: 0,\n    right: 40,\n    bottom: 40,\n    left: 0\n  },\n  minPointsPerPxThreshold: 1 / 100,\n  mouseMoveEvent: true,\n  postCalculator: identity,\n  padding: 0,\n  pointsPerPxThreshold: 2,\n  useCrossHairStyleCursor: true,\n  xAccessor: identity,\n  xExtents: [min, max],\n  zIndex: 1,\n  zoomAnchor: mouseBasedZoomAnchor,\n  zoomMultiplier: 1.1\n};","map":{"version":3,"names":["extent","d3Extent","max","min","React","clearCanvas","functor","head","identity","isDefined","isNotDefined","last","shallowEqual","mouseBasedZoomAnchor","getChartConfigWithUpdatedYScales","getCurrentCharts","getCurrentItem","getNewChartConfig","EventCapture","CanvasContainer","evaluator","CANDIDATES_FOR_RESET","shouldResetChart","thisProps","nextProps","every","key","result","getCursorStyle","tooltipStyle","createElement","type","noop","chartCanvasContextDefaultValue","amIOnTop","chartConfigs","chartId","ratio","displayXAccessor","fullData","getMutableState","height","margin","top","right","bottom","left","plotData","setCursorClass","subscribe","unsubscribe","redraw","width","xAccessor","xScale","ChartCanvasContext","createContext","getDimensions","props","getXScaleDirection","flipXScale","calculateFullData","data","plotFull","clamp","pointsPerPxThreshold","minPointsPerPxThreshold","useWholeData","undefined","filterData","copy","resetChart","state","calculateState","initialPlotData","postCalculator","children","dimensions","domain","Object","assign","updateChart","newState","initialXScale","lastItemWasVisible","initialChartConfig","lastItem","lastXItem","start","end","padding","maintainPointsPerPixelOnResize","direction","updatedXScale","setXRange","rangeStart","rangeEnd","range","newRangeStart","newRangeEnd","newDomainExtent","valueOf","newStart","lastItemX","response","fallbackStart","fallbackEnd","dx","newEnd","map","x","invert","inputXAccessor","xExtents","xExtentsProp","d","each","rangeRoundPoints","isNaN","Error","pinchCoordinates","pinch","touch1Pos","touch2Pos","topLeft","Math","bottomRight","isInteractionEnabled","interaction","ChartCanvas","Component","constructor","canvasContainerRef","createRef","eventCaptureRef","lastSubscriptionId","mutableState","mouseXY","currentCharts","currentItem","panInProgress","subscriptions","getCanvasContexts","_a","current","generateSubscriptionId","id","rest","getPanConditions","draggable","panEnabled","concat","filter","getAllPanConditions","className","dragableComponents","length","handleContextMenu","e","triggerEvent","calculateStateForDomain","newDomain","defaultProps","beforePlotData","currentPlotData","currentDomain","updatedScale","pinchZoomHelper","initialPinch","finalPinch","initialPinchXScale","iTL","iBR","fTL","fBR","xDash","round","yDash","y","handlePinchZoom","waitingForPinchZoomAnimationFrame","requestAnimationFrame","clearBothCanvas","draw","trigger","handlePinchZoomEnd","clearThreeCanvas","firstItem","scale_start","data_start","scale_end","data_end","onLoadAfter","onLoadBefore","setState","handleZoom","zoomDirection","zoomMultiplier","zoomAnchor","item","cx","c","show","xAxisZoom","yAxisZoom","yScale","yPanEnabled","forEach","force","panHelper","dy","chartsToPan","hackyWayToStopPanBeyondBounds__plotData","hackyWayToStopPanBeyondBounds__domain","ignoreThresholds","handlePan","mousePosition","panStartXScale","dxdy","waitingForPanAnimationFrame","_b","handlePanEnd","handleMouseDown","_","__","handleMouseEnter","handleMouseMove","waitingForMouseMoveAnimationFrame","prevMouseXY","clearMouseCanvas","handleMouseLeave","handleDragStart","startPos","handleDrag","handleDragEnd","handleClick","handleDoubleClick","resetYDomain","changed","newChartConfig","realYDomain","getDerivedStateFromProps","shouldReset","lastProps","prevLastItem","calculatedState","previousX","propIteration","getSnapshotBeforeUpdate","prevProps","prevState","componentDidUpdate","canvases","axes","mouseCoord","bg","cancelDrag","listener","getContextValues","shouldComponentUpdate","render","disableInteraction","disablePan","disableZoom","useCrossHairStyleCursor","onClick","onDoubleClick","zIndex","defaultFocus","mouseMoveEvent","cursorStyle","cursor","Provider","value","style","position","ref","idx","transform","mouseMove","zoom","pan","chartConfig","focus","onContextMenu","onMouseDown","onMouseMove","onMouseEnter","onMouseLeave","onDragStart","onDrag","onDragComplete","onZoom","onPinchZoom","onPinchZoomEnd","onPan","onPanEnd"],"sources":["C:\\Users\\gabby\\trax-x\\node_modules\\@react-financial-charts\\core\\src\\ChartCanvas.tsx"],"sourcesContent":["import { extent as d3Extent, max, min } from \"d3-array\";\nimport { ScaleContinuousNumeric, ScaleTime } from \"d3-scale\";\nimport * as React from \"react\";\nimport { clearCanvas, functor, head, identity, isDefined, isNotDefined, last, shallowEqual } from \"./utils\";\nimport { IZoomAnchorOptions, mouseBasedZoomAnchor } from \"./zoom\";\nimport {\n    ChartConfig,\n    getChartConfigWithUpdatedYScales,\n    getCurrentCharts,\n    getCurrentItem,\n    getNewChartConfig,\n} from \"./utils/ChartDataUtil\";\nimport { EventCapture } from \"./EventCapture\";\nimport { CanvasContainer, ICanvasContexts } from \"./CanvasContainer\";\nimport evaluator from \"./utils/evaluator\";\nimport type { MoreProps } from \"./MoreProps\";\n\nconst CANDIDATES_FOR_RESET = [\"seriesName\"];\n\nconst shouldResetChart = (thisProps: any, nextProps: any) => {\n    return !CANDIDATES_FOR_RESET.every((key) => {\n        const result = shallowEqual(thisProps[key], nextProps[key]);\n        return result;\n    });\n};\n\nconst getCursorStyle = () => {\n    const tooltipStyle = `\n\t.react-financial-charts-grabbing-cursor {\n\t\tpointer-events: all;\n\t\tcursor: -moz-grabbing;\n\t\tcursor: -webkit-grabbing;\n\t\tcursor: grabbing;\n\t}\n\t.react-financial-charts-crosshair-cursor {\n\t\tpointer-events: all;\n\t\tcursor: crosshair;\n\t}\n\t.react-financial-charts-tooltip-hover {\n\t\tpointer-events: all;\n\t\tcursor: pointer;\n\t}\n\t.react-financial-charts-avoid-interaction {\n\t\tpointer-events: none;\n\t}\n\t.react-financial-charts-enable-interaction {\n\t\tpointer-events: all;\n\t}\n\t.react-financial-charts-tooltip {\n\t\tpointer-events: all;\n\t\tcursor: pointer;\n\t}\n\t.react-financial-charts-default-cursor {\n\t\tcursor: default;\n\t}\n\t.react-financial-charts-move-cursor {\n\t\tcursor: move;\n\t}\n\t.react-financial-charts-pointer-cursor {\n\t\tcursor: pointer;\n\t}\n\t.react-financial-charts-ns-resize-cursor {\n\t\tcursor: ns-resize;\n\t}\n\t.react-financial-charts-ew-resize-cursor {\n\t\tcursor: ew-resize;\n\t}`;\n    return <style type=\"text/css\">{tooltipStyle}</style>;\n};\n\nexport interface ChartCanvasContextType<TXAxis extends number | Date> {\n    width: number;\n    height: number;\n    margin: { top: number; right: number; bottom: number; left: number };\n    chartId: number | string;\n    getCanvasContexts?: () => ICanvasContexts | undefined;\n    xScale: Function;\n    ratio: number;\n    // Not sure if it should be optional\n    xAccessor: (data: any) => TXAxis;\n    displayXAccessor: (data: any) => TXAxis;\n    xAxisZoom?: (newDomain: any) => void;\n    yAxisZoom?: (chartId: string, newDomain: any) => void;\n    redraw: () => void;\n    plotData: any[];\n    fullData: any[];\n    chartConfigs: ChartConfig[];\n    morePropsDecorator?: () => void;\n    generateSubscriptionId?: () => number;\n    getMutableState: () => {};\n    amIOnTop: (id: string | number) => boolean;\n    subscribe: (id: string | number, rest: any) => void;\n    unsubscribe: (id: string | number) => void;\n    setCursorClass: (className: string | null | undefined) => void;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {};\nexport const chartCanvasContextDefaultValue: ChartCanvasContextType<number | Date> = {\n    amIOnTop: () => false,\n    chartConfigs: [],\n    chartId: 0,\n    ratio: 0,\n    displayXAccessor: () => 0,\n    fullData: [],\n    getMutableState: () => ({}),\n    height: 0,\n    margin: { top: 0, right: 0, bottom: 0, left: 0 },\n    plotData: [],\n    setCursorClass: noop,\n    subscribe: noop,\n    unsubscribe: noop,\n    redraw: noop,\n    width: 0,\n    xAccessor: () => 0,\n    xScale: noop,\n};\nexport const ChartCanvasContext =\n    React.createContext<ChartCanvasContextType<number | Date>>(chartCanvasContextDefaultValue);\n\nconst getDimensions = <TXAxis extends number | Date>(props: ChartCanvasProps<TXAxis>) => {\n    const { margin, height, width } = props;\n    return {\n        height: height - margin.top - margin.bottom,\n        width: width - margin.left - margin.right,\n    };\n};\n\nconst getXScaleDirection = (flipXScale?: boolean) => {\n    return flipXScale ? -1 : 1;\n};\n\nconst calculateFullData = <TXAxis extends number | Date>(props: ChartCanvasProps<TXAxis>) => {\n    const {\n        data: fullData,\n        plotFull,\n        xScale,\n        clamp,\n        pointsPerPxThreshold,\n        flipXScale,\n        xAccessor,\n        displayXAccessor,\n        minPointsPerPxThreshold,\n    } = props;\n\n    const useWholeData = plotFull !== undefined ? plotFull : xAccessor === identity;\n\n    const { filterData } = evaluator({\n        xScale,\n        useWholeData,\n        clamp,\n        pointsPerPxThreshold,\n        minPointsPerPxThreshold,\n        flipXScale,\n    });\n\n    return {\n        xAccessor,\n        displayXAccessor: displayXAccessor ?? xAccessor,\n        xScale: xScale.copy(),\n        fullData,\n        filterData,\n    };\n};\n\nconst resetChart = <TXAxis extends number | Date>(props: ChartCanvasProps<TXAxis>) => {\n    const state = calculateState(props);\n\n    const { xAccessor, displayXAccessor, fullData, plotData: initialPlotData, xScale } = state;\n\n    const { postCalculator, children } = props;\n\n    const plotData = postCalculator !== undefined ? postCalculator(initialPlotData) : initialPlotData;\n\n    const dimensions = getDimensions(props);\n\n    const chartConfigs = getChartConfigWithUpdatedYScales(\n        getNewChartConfig(dimensions, children),\n        { plotData, xAccessor, displayXAccessor, fullData },\n        xScale.domain(),\n    );\n\n    return {\n        ...state,\n        xScale,\n        plotData,\n        chartConfigs,\n    };\n};\n\nconst updateChart = (\n    newState: any,\n    initialXScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>,\n    props: any,\n    lastItemWasVisible: boolean,\n    initialChartConfig: any,\n) => {\n    const { fullData, xScale, xAccessor, displayXAccessor, filterData } = newState;\n\n    const lastItem = last(fullData);\n    const lastXItem = xAccessor(lastItem);\n    const [start, end] = initialXScale.domain();\n\n    const { postCalculator, children, padding, flipXScale, maintainPointsPerPixelOnResize } = props;\n\n    const direction = getXScaleDirection(flipXScale);\n    const dimensions = getDimensions(props);\n    const updatedXScale = setXRange(xScale, dimensions, padding, direction);\n\n    let initialPlotData;\n    if (!lastItemWasVisible || end >= lastXItem) {\n        // resize comes here...\n        // get plotData between [start, end] and do not change the domain\n        const [rangeStart, rangeEnd] = initialXScale.range();\n        const [newRangeStart, newRangeEnd] = updatedXScale.range();\n        const newDomainExtent =\n            ((newRangeEnd - newRangeStart) / (rangeEnd - rangeStart)) * (end.valueOf() - start.valueOf());\n        const newStart = maintainPointsPerPixelOnResize ? end.valueOf() - newDomainExtent : start;\n\n        const lastItemX = initialXScale(lastXItem);\n\n        const response = filterData(fullData, [newStart, end], xAccessor, updatedXScale, {\n            fallbackStart: start,\n            fallbackEnd: { lastItem, lastItemX },\n        });\n        initialPlotData = response.plotData;\n        updatedXScale.domain(response.domain);\n    } else if (lastItemWasVisible && end < lastXItem) {\n        // this is when a new item is added and last item was visible\n        // so slide over and show the new item also\n\n        // get plotData between [xAccessor(l) - (end - start), xAccessor(l)] and DO change the domain\n        const dx = initialXScale(lastXItem) - initialXScale.range()[1];\n        const [newStart, newEnd] = initialXScale\n            .range()\n            .map((x) => x + dx)\n            .map((x) => initialXScale.invert(x));\n\n        const response = filterData(fullData, [newStart, newEnd], xAccessor, updatedXScale);\n        initialPlotData = response.plotData;\n        updatedXScale.domain(response.domain); // if last item was visible, then shift\n    }\n\n    const plotData = postCalculator(initialPlotData);\n\n    const chartConfigs = getChartConfigWithUpdatedYScales(\n        getNewChartConfig(dimensions, children, initialChartConfig),\n        { plotData, xAccessor, displayXAccessor, fullData },\n        updatedXScale.domain(),\n    );\n\n    return {\n        xScale: updatedXScale,\n        xAccessor,\n        chartConfigs,\n        plotData,\n        fullData,\n        filterData,\n    };\n};\n\nconst calculateState = <TXAxis extends number | Date>(props: ChartCanvasProps<TXAxis>) => {\n    const { xAccessor: inputXAccessor, xExtents: xExtentsProp, data, padding, flipXScale } = props;\n\n    const direction = getXScaleDirection(flipXScale);\n\n    const dimensions = getDimensions(props);\n\n    const extent =\n        typeof xExtentsProp === \"function\"\n            ? xExtentsProp(data)\n            : (d3Extent<number | Date>(\n                  xExtentsProp.map((d: any) => functor(d)).map((each: any) => each(data, inputXAccessor)),\n              ) as [TXAxis, TXAxis]);\n\n    const { xAccessor, displayXAccessor, xScale, fullData, filterData } = calculateFullData(props);\n\n    const updatedXScale = setXRange(xScale, dimensions, padding, direction);\n\n    const { plotData, domain } = filterData(fullData, extent, inputXAccessor, updatedXScale);\n\n    return {\n        plotData,\n        xScale: updatedXScale.domain(domain),\n        xAccessor,\n        displayXAccessor,\n        fullData,\n        filterData,\n    };\n};\n\nconst setXRange = (xScale: any, dimensions: any, padding: any, direction = 1) => {\n    if (xScale.rangeRoundPoints) {\n        if (isNaN(padding)) {\n            throw new Error(\"padding has to be a number for ordinal scale\");\n        }\n        xScale.rangeRoundPoints([0, dimensions.width], padding);\n    } else if (xScale.padding) {\n        if (isNaN(padding)) {\n            throw new Error(\"padding has to be a number for ordinal scale\");\n        }\n        xScale.range([0, dimensions.width]);\n        xScale.padding(padding / 2);\n    } else {\n        const { left, right } = isNaN(padding) ? padding : { left: padding, right: padding };\n        if (direction > 0) {\n            xScale.range([left, dimensions.width - right]);\n        } else {\n            xScale.range([dimensions.width - right, left]);\n        }\n    }\n    return xScale;\n};\n\nconst pinchCoordinates = (pinch: any) => {\n    const { touch1Pos, touch2Pos } = pinch;\n\n    return {\n        topLeft: [Math.min(touch1Pos[0], touch2Pos[0]), Math.min(touch1Pos[1], touch2Pos[1])],\n        bottomRight: [Math.max(touch1Pos[0], touch2Pos[0]), Math.max(touch1Pos[1], touch2Pos[1])],\n    };\n};\n\nconst isInteractionEnabled = (\n    xScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>,\n    xAccessor: any,\n    data: any,\n) => {\n    const interaction = !isNaN(xScale(xAccessor(head(data)))) && isDefined(xScale.invert);\n    return interaction;\n};\n\nexport interface ChartCanvasProps<TXAxis extends number | Date> {\n    readonly clamp?:\n        | boolean\n        | (\"left\" | \"right\" | \"both\")\n        | ((domain: [number, number], items: [number, number]) => [number, number]);\n    readonly className?: string;\n    readonly children?: React.ReactNode;\n    readonly data: any[];\n    readonly defaultFocus?: boolean;\n    readonly disableInteraction?: boolean;\n    readonly disablePan?: boolean;\n    readonly disableZoom?: boolean;\n    readonly displayXAccessor?: (data: any) => TXAxis;\n    readonly flipXScale?: boolean;\n    readonly height: number;\n    readonly margin: {\n        bottom: number;\n        left: number;\n        right: number;\n        top: number;\n    };\n    readonly maintainPointsPerPixelOnResize?: boolean;\n    readonly minPointsPerPxThreshold?: number;\n    readonly mouseMoveEvent?: boolean;\n    /**\n     * Called when panning left past the first data point.\n     */\n    readonly onLoadAfter?: (start: TXAxis, end: TXAxis) => void;\n    /**\n     * Called when panning right past the last data point.\n     */\n    readonly onLoadBefore?: (start: TXAxis, end: TXAxis) => void;\n    /**\n     * Click event handler.\n     */\n    readonly onClick?: React.MouseEventHandler<HTMLDivElement>;\n    /**\n     * Double click event handler.\n     */\n    readonly onDoubleClick?: React.MouseEventHandler<HTMLDivElement>;\n    readonly padding?:\n        | number\n        | {\n              bottom: number;\n              left: number;\n              right: number;\n              top: number;\n          };\n    readonly plotFull?: boolean;\n    readonly pointsPerPxThreshold?: number;\n    readonly postCalculator?: (plotData: any[]) => any[];\n    readonly ratio: number;\n    readonly seriesName: string;\n    readonly useCrossHairStyleCursor?: boolean;\n    readonly width: number;\n    readonly xAccessor: (data: any) => TXAxis;\n    readonly xExtents: ((data: any[]) => [TXAxis, TXAxis]) | (((data: any[]) => TXAxis) | TXAxis)[];\n    readonly xScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>;\n    readonly zIndex?: number;\n    readonly zoomAnchor?: (options: IZoomAnchorOptions<any, TXAxis>) => TXAxis;\n    readonly zoomMultiplier?: number;\n}\n\ninterface ChartCanvasState<TXAxis extends number | Date> {\n    lastProps?: ChartCanvasProps<TXAxis>;\n    propIteration?: number;\n    xAccessor: (data: any) => TXAxis;\n    displayXAccessor?: any;\n    filterData?: any;\n    chartConfigs: ChartConfig[];\n    plotData: any[];\n    xScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>;\n    fullData: any[];\n}\n\ninterface Subscription {\n    id: string;\n    getPanConditions: () => {\n        draggable: boolean;\n        panEnabled: boolean;\n    };\n    draw: (props: { trigger: string } | { force: boolean }) => void;\n    listener: (type: string, newMoreProps: MoreProps | undefined, state: any, e: any) => void;\n}\n\ninterface MutableState {\n    mouseXY: [number, number];\n    currentItem: any;\n    currentCharts: string[];\n}\n\nexport class ChartCanvas<TXAxis extends number | Date> extends React.Component<\n    ChartCanvasProps<TXAxis>,\n    ChartCanvasState<TXAxis>\n> {\n    public static defaultProps = {\n        clamp: false,\n        className: \"react-financial-charts\",\n        defaultFocus: true,\n        disablePan: false,\n        disableInteraction: false,\n        disableZoom: false,\n        flipXScale: false,\n        maintainPointsPerPixelOnResize: true,\n        margin: { top: 0, right: 40, bottom: 40, left: 0 },\n        minPointsPerPxThreshold: 1 / 100,\n        mouseMoveEvent: true,\n        postCalculator: identity,\n        padding: 0,\n        pointsPerPxThreshold: 2,\n        useCrossHairStyleCursor: true,\n        xAccessor: identity as (data: any) => any,\n        xExtents: [min, max] as any[],\n        zIndex: 1,\n        zoomAnchor: mouseBasedZoomAnchor,\n        zoomMultiplier: 1.1,\n    };\n\n    private readonly canvasContainerRef = React.createRef<CanvasContainer>();\n    private readonly eventCaptureRef = React.createRef<EventCapture>();\n    private finalPinch?: boolean;\n    private lastSubscriptionId = 0;\n    private mutableState: MutableState = { mouseXY: [0, 0], currentCharts: [], currentItem: null };\n    private panInProgress = false;\n    private prevMouseXY?: number[];\n    private subscriptions: Subscription[] = [];\n    private waitingForPinchZoomAnimationFrame?: boolean;\n    private waitingForPanAnimationFrame?: boolean;\n    private waitingForMouseMoveAnimationFrame?: boolean;\n\n    // tslint:disable-next-line: variable-name\n    private hackyWayToStopPanBeyondBounds__plotData?: any[] | null;\n    // tslint:disable-next-line: variable-name\n    private hackyWayToStopPanBeyondBounds__domain?: any[] | null;\n\n    public constructor(props: ChartCanvasProps<TXAxis>) {\n        super(props);\n        this.state = resetChart(props);\n    }\n\n    public static getDerivedStateFromProps<TXAxis extends number | Date>(\n        props: ChartCanvasProps<TXAxis>,\n        state: ChartCanvasState<TXAxis>,\n    ): ChartCanvasState<TXAxis> {\n        const { chartConfigs: initialChartConfig, plotData, xAccessor, xScale } = state;\n        const interaction = isInteractionEnabled(xScale, xAccessor, plotData);\n        const shouldReset = shouldResetChart(state.lastProps || {}, props);\n        let newState: ChartCanvasState<TXAxis>;\n        if (!interaction || shouldReset || !shallowEqual(state.lastProps?.xExtents, props.xExtents)) {\n            // do reset\n            newState = resetChart(props);\n        } else {\n            const [start, end] = xScale.domain();\n            const prevLastItem = last(state.fullData);\n\n            const calculatedState = calculateFullData(props);\n            const { xAccessor } = calculatedState;\n            const previousX = xAccessor(prevLastItem);\n            const lastItemWasVisible = previousX <= end && previousX >= start;\n\n            newState = updateChart(calculatedState, xScale, props, lastItemWasVisible, initialChartConfig);\n        }\n        return {\n            ...newState,\n            lastProps: props,\n            propIteration: (state.propIteration || 0) + 1,\n        };\n    }\n\n    public getSnapshotBeforeUpdate(\n        prevProps: Readonly<ChartCanvasProps<TXAxis>>,\n        prevState: Readonly<ChartCanvasState<TXAxis>>,\n    ) {\n        // propIteration is incremented when the props change to differentiate between state updates\n        // and prop updates\n        if (prevState.propIteration !== this.state.propIteration && !this.panInProgress) {\n            this.clearThreeCanvas();\n        }\n        return null;\n    }\n\n    public componentDidUpdate(prevProps: ChartCanvasProps<TXAxis>) {\n        if (prevProps.data !== this.props.data) {\n            this.triggerEvent(\"dataupdated\", {\n                chartConfigs: this.state.chartConfigs,\n                xScale: this.state.xScale,\n                plotData: this.state.plotData,\n            });\n        }\n    }\n\n    public getMutableState = () => {\n        return this.mutableState;\n    };\n\n    public getCanvasContexts = () => {\n        return this.canvasContainerRef.current?.getCanvasContexts();\n    };\n\n    public generateSubscriptionId = () => {\n        this.lastSubscriptionId++;\n\n        return this.lastSubscriptionId;\n    };\n\n    public clearBothCanvas() {\n        const canvases = this.getCanvasContexts();\n        if (canvases && canvases.axes && canvases.mouseCoord) {\n            clearCanvas([canvases.axes, canvases.mouseCoord], this.props.ratio);\n        }\n    }\n\n    public clearMouseCanvas() {\n        const canvases = this.getCanvasContexts();\n        if (canvases && canvases.mouseCoord) {\n            clearCanvas([canvases.mouseCoord], this.props.ratio);\n        }\n    }\n\n    public clearThreeCanvas() {\n        const canvases = this.getCanvasContexts();\n        if (canvases && canvases.axes && canvases.mouseCoord && canvases.bg) {\n            clearCanvas([canvases.axes, canvases.mouseCoord, canvases.bg], this.props.ratio);\n        }\n    }\n\n    public subscribe = (id: string | number, rest: any) => {\n        const {\n            getPanConditions = functor({\n                draggable: false,\n                panEnabled: true,\n            }),\n        } = rest;\n\n        this.subscriptions = this.subscriptions.concat({\n            id,\n            ...rest,\n            getPanConditions,\n        });\n    };\n\n    public unsubscribe = (id: string | number) => {\n        this.subscriptions = this.subscriptions.filter((each) => each.id !== id);\n    };\n\n    public getAllPanConditions = () => {\n        return this.subscriptions.map((each) => each.getPanConditions());\n    };\n\n    public setCursorClass = (className: string | null | undefined) => {\n        this.eventCaptureRef.current?.setCursorClass(className);\n    };\n\n    public amIOnTop = (id: string | number) => {\n        const dragableComponents = this.subscriptions.filter((each) => each.getPanConditions().draggable);\n\n        return dragableComponents.length > 0 && last(dragableComponents).id === id;\n    };\n\n    public handleContextMenu = (mouseXY: number[], e: React.MouseEvent) => {\n        const { xAccessor, chartConfigs, plotData, xScale } = this.state;\n\n        const currentCharts = getCurrentCharts(chartConfigs, mouseXY);\n\n        const currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n\n        this.triggerEvent(\n            \"contextmenu\",\n            {\n                mouseXY,\n                currentItem,\n                currentCharts,\n            },\n            e,\n        );\n    };\n\n    public calculateStateForDomain = (newDomain: any) => {\n        const {\n            xAccessor,\n            displayXAccessor,\n            xScale: initialXScale,\n            chartConfigs: initialChartConfig,\n            plotData: initialPlotData,\n        } = this.state;\n\n        const { filterData, fullData } = this.state;\n        const { postCalculator = ChartCanvas.defaultProps.postCalculator } = this.props;\n\n        const { plotData: beforePlotData, domain } = filterData(fullData, newDomain, xAccessor, initialXScale, {\n            currentPlotData: initialPlotData,\n            currentDomain: initialXScale!.domain(),\n        });\n\n        const plotData = postCalculator(beforePlotData);\n\n        const updatedScale = initialXScale.copy().domain(domain) as\n            | ScaleContinuousNumeric<number, number>\n            | ScaleTime<number, number>;\n\n        const chartConfigs = getChartConfigWithUpdatedYScales(\n            initialChartConfig,\n            { plotData, xAccessor, displayXAccessor, fullData },\n            updatedScale.domain(),\n        );\n\n        return {\n            xScale: updatedScale,\n            plotData,\n            chartConfigs,\n        };\n    };\n\n    public pinchZoomHelper = (initialPinch: any, finalPinch: any) => {\n        const { xScale: initialPinchXScale } = initialPinch;\n\n        const {\n            xScale: initialXScale,\n            chartConfigs: initialChartConfig,\n            plotData: initialPlotData,\n            xAccessor,\n            displayXAccessor,\n            filterData,\n            fullData,\n        } = this.state;\n        const { postCalculator = ChartCanvas.defaultProps.postCalculator } = this.props;\n\n        const { topLeft: iTL, bottomRight: iBR } = pinchCoordinates(initialPinch);\n        const { topLeft: fTL, bottomRight: fBR } = pinchCoordinates(finalPinch);\n\n        const e = initialPinchXScale.range()[1];\n\n        const xDash = Math.round(-(iBR[0] * fTL[0] - iTL[0] * fBR[0]) / (iTL[0] - iBR[0]));\n        const yDash = Math.round(\n            e + ((e - iBR[0]) * (e - fTL[0]) - (e - iTL[0]) * (e - fBR[0])) / (e - iTL[0] - (e - iBR[0])),\n        );\n\n        const x = Math.round((-xDash * iTL[0]) / (-xDash + fTL[0]));\n        const y = Math.round(e - ((yDash - e) * (e - iTL[0])) / (yDash + (e - fTL[0])));\n\n        const newDomain = [x, y].map(initialPinchXScale.invert);\n\n        const { plotData: beforePlotData, domain } = filterData(fullData, newDomain, xAccessor, initialPinchXScale, {\n            currentPlotData: initialPlotData,\n            currentDomain: initialXScale!.domain(),\n        });\n\n        const plotData = postCalculator(beforePlotData);\n\n        const updatedScale = initialXScale!.copy().domain(domain) as\n            | ScaleContinuousNumeric<number, number>\n            | ScaleTime<number, number>;\n\n        const mouseXY = finalPinch.touch1Pos;\n\n        const chartConfigs = getChartConfigWithUpdatedYScales(\n            initialChartConfig,\n            { plotData, xAccessor, displayXAccessor, fullData },\n            updatedScale.domain(),\n        );\n\n        const currentItem = getCurrentItem(updatedScale, xAccessor, mouseXY, plotData);\n\n        return {\n            chartConfigs,\n            xScale: updatedScale,\n            plotData,\n            mouseXY,\n            currentItem,\n            xAccessor,\n            fullData,\n        };\n    };\n\n    public cancelDrag() {\n        this.eventCaptureRef.current?.cancelDrag();\n        this.triggerEvent(\"dragcancel\");\n    }\n\n    public handlePinchZoom = (initialPinch: any, finalPinch: any, e: any) => {\n        if (!this.waitingForPinchZoomAnimationFrame) {\n            this.waitingForPinchZoomAnimationFrame = true;\n            const state = this.pinchZoomHelper(initialPinch, finalPinch);\n\n            this.triggerEvent(\"pinchzoom\", state, e);\n\n            this.finalPinch = finalPinch;\n\n            requestAnimationFrame(() => {\n                this.clearBothCanvas();\n                this.draw({ trigger: \"pinchzoom\" });\n                this.waitingForPinchZoomAnimationFrame = false;\n            });\n        }\n    };\n\n    public handlePinchZoomEnd = (initialPinch: any, e: any) => {\n        const { xAccessor = ChartCanvas.defaultProps.xAccessor } = this.state;\n\n        if (this.finalPinch) {\n            const state = this.pinchZoomHelper(initialPinch, this.finalPinch);\n            const { xScale, fullData } = state;\n            this.triggerEvent(\"pinchzoom\", state, e);\n\n            this.finalPinch = undefined;\n\n            this.clearThreeCanvas();\n            const firstItem = head(fullData);\n            const scale_start = head(xScale.domain());\n            const data_start = xAccessor(firstItem);\n\n            const lastItem = last(fullData);\n            const scale_end = last(xScale.domain());\n            const data_end = xAccessor(lastItem);\n\n            const { onLoadAfter, onLoadBefore } = this.props;\n\n            this.setState(state, () => {\n                if (scale_start < data_start) {\n                    if (onLoadBefore !== undefined) {\n                        onLoadBefore(scale_start, data_start);\n                    }\n                }\n                if (data_end < scale_end) {\n                    if (onLoadAfter !== undefined) {\n                        onLoadAfter(data_end, scale_end);\n                    }\n                }\n            });\n        }\n    };\n\n    public handleZoom = (zoomDirection: any, mouseXY: any, e: any) => {\n        if (this.panInProgress) {\n            return;\n        }\n\n        const { xAccessor, xScale: initialXScale, plotData: initialPlotData, fullData } = this.state;\n        const {\n            zoomMultiplier = ChartCanvas.defaultProps.zoomMultiplier,\n            zoomAnchor = ChartCanvas.defaultProps.zoomAnchor,\n        } = this.props;\n\n        const item = zoomAnchor({\n            xScale: initialXScale!,\n            xAccessor: xAccessor!,\n            mouseXY,\n            plotData: initialPlotData,\n        });\n\n        const cx = initialXScale(item);\n        const c = zoomDirection > 0 ? 1 * zoomMultiplier : 1 / zoomMultiplier;\n        const newDomain = initialXScale!\n            .range()\n            .map((x) => cx + (x - cx) * c)\n            .map((x) => initialXScale.invert(x));\n\n        const { xScale, plotData, chartConfigs } = this.calculateStateForDomain(newDomain);\n\n        const currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n        const currentCharts = getCurrentCharts(chartConfigs, mouseXY);\n\n        this.clearThreeCanvas();\n\n        const firstItem = head(fullData);\n        const scale_start = head(xScale.domain());\n        const data_start = xAccessor!(firstItem);\n\n        const lastItem = last(fullData);\n        const scale_end = last(xScale.domain());\n        const data_end = xAccessor!(lastItem);\n\n        this.mutableState = {\n            mouseXY,\n            currentItem,\n            currentCharts,\n        };\n\n        this.triggerEvent(\n            \"zoom\",\n            {\n                xScale,\n                plotData,\n                chartConfigs,\n                mouseXY,\n                currentCharts,\n                currentItem,\n                show: true,\n            },\n            e,\n        );\n\n        const { onLoadAfter, onLoadBefore } = this.props;\n\n        this.setState(\n            {\n                xScale,\n                plotData,\n                chartConfigs,\n            },\n            () => {\n                if (scale_start < data_start) {\n                    if (onLoadBefore !== undefined) {\n                        onLoadBefore(scale_start, data_start);\n                    }\n                }\n                if (data_end < scale_end) {\n                    if (onLoadAfter !== undefined) {\n                        onLoadAfter(data_end, scale_end);\n                    }\n                }\n            },\n        );\n    };\n\n    public xAxisZoom = (newDomain: any) => {\n        const { xScale, plotData, chartConfigs } = this.calculateStateForDomain(newDomain);\n        this.clearThreeCanvas();\n\n        const { xAccessor, fullData } = this.state;\n        const firstItem = head(fullData);\n        const scale_start = head(xScale.domain());\n        const data_start = xAccessor!(firstItem);\n\n        const lastItem = last(fullData);\n        const scale_end = last(xScale.domain());\n        const data_end = xAccessor!(lastItem);\n\n        const { onLoadAfter, onLoadBefore } = this.props;\n\n        this.setState(\n            {\n                xScale,\n                plotData,\n                chartConfigs,\n            },\n            () => {\n                if (scale_start < data_start) {\n                    if (onLoadBefore !== undefined) {\n                        onLoadBefore(scale_start, data_start);\n                    }\n                }\n                if (data_end < scale_end) {\n                    if (onLoadAfter !== undefined) {\n                        onLoadAfter(data_end, scale_end);\n                    }\n                }\n            },\n        );\n    };\n\n    public yAxisZoom = (chartId: string, newDomain: any) => {\n        this.clearThreeCanvas();\n        const { chartConfigs: initialChartConfig } = this.state;\n        const chartConfigs = initialChartConfig.map((each: any) => {\n            if (each.id === chartId) {\n                const { yScale } = each;\n                return {\n                    ...each,\n                    yScale: yScale.copy().domain(newDomain),\n                    yPanEnabled: true,\n                };\n            } else {\n                return each;\n            }\n        });\n\n        this.setState({\n            chartConfigs,\n        });\n    };\n\n    public triggerEvent(type: any, props?: any, e?: any) {\n        this.subscriptions.forEach((each) => {\n            const state = {\n                ...this.state,\n                subscriptions: this.subscriptions,\n            };\n            each.listener(type, props, state, e);\n        });\n    }\n\n    public draw = (props: { trigger: string } | { force: boolean }) => {\n        this.subscriptions.forEach((each) => {\n            if (isDefined(each.draw)) {\n                each.draw(props);\n            }\n        });\n    };\n\n    public redraw = () => {\n        this.clearThreeCanvas();\n        this.draw({ force: true });\n    };\n\n    public panHelper = (\n        mouseXY: [number, number],\n        initialXScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>,\n        { dx, dy }: { dx: number; dy: number },\n        chartsToPan: string[],\n    ) => {\n        const { xAccessor, displayXAccessor, chartConfigs: initialChartConfig, filterData, fullData } = this.state;\n        const { postCalculator = ChartCanvas.defaultProps.postCalculator } = this.props;\n\n        const newDomain = initialXScale\n            .range()\n            .map((x) => x - dx)\n            .map((x) => initialXScale.invert(x));\n\n        const { plotData: beforePlotData, domain } = filterData(fullData, newDomain, xAccessor, initialXScale, {\n            currentPlotData: this.hackyWayToStopPanBeyondBounds__plotData,\n            currentDomain: this.hackyWayToStopPanBeyondBounds__domain,\n            ignoreThresholds: true,\n        });\n\n        const updatedScale = initialXScale.copy().domain(domain) as\n            | ScaleContinuousNumeric<number, number>\n            | ScaleTime<number, number>;\n\n        const plotData = postCalculator(beforePlotData);\n\n        const currentItem = getCurrentItem(updatedScale, xAccessor, mouseXY, plotData);\n\n        const chartConfigs = getChartConfigWithUpdatedYScales(\n            initialChartConfig,\n            { plotData, xAccessor, displayXAccessor, fullData },\n            updatedScale.domain(),\n            dy,\n            chartsToPan,\n        );\n\n        const currentCharts = getCurrentCharts(chartConfigs, mouseXY);\n\n        return {\n            xScale: updatedScale,\n            plotData,\n            chartConfigs,\n            mouseXY,\n            currentCharts,\n            currentItem,\n        };\n    };\n\n    public handlePan = (\n        mousePosition: [number, number],\n        panStartXScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>,\n        dxdy: { dx: number; dy: number },\n        chartsToPan: string[],\n        e: React.MouseEvent,\n    ) => {\n        if (this.waitingForPanAnimationFrame) {\n            return;\n        }\n        this.waitingForPanAnimationFrame = true;\n\n        this.hackyWayToStopPanBeyondBounds__plotData =\n            this.hackyWayToStopPanBeyondBounds__plotData ?? this.state.plotData;\n        this.hackyWayToStopPanBeyondBounds__domain =\n            this.hackyWayToStopPanBeyondBounds__domain ?? this.state.xScale!.domain();\n\n        const newState = this.panHelper(mousePosition, panStartXScale, dxdy, chartsToPan);\n\n        this.hackyWayToStopPanBeyondBounds__plotData = newState.plotData;\n        this.hackyWayToStopPanBeyondBounds__domain = newState.xScale.domain();\n\n        this.panInProgress = true;\n\n        this.triggerEvent(\"pan\", newState, e);\n\n        this.mutableState = {\n            mouseXY: newState.mouseXY,\n            currentItem: newState.currentItem,\n            currentCharts: newState.currentCharts,\n        };\n        requestAnimationFrame(() => {\n            this.waitingForPanAnimationFrame = false;\n            this.clearBothCanvas();\n            this.draw({ trigger: \"pan\" });\n        });\n    };\n\n    public handlePanEnd = (\n        mousePosition: [number, number],\n        panStartXScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>,\n        dxdy: { dx: number; dy: number },\n        chartsToPan: string[],\n        e: React.MouseEvent | React.TouchEvent,\n    ) => {\n        const state = this.panHelper(mousePosition, panStartXScale, dxdy, chartsToPan);\n        this.hackyWayToStopPanBeyondBounds__plotData = null;\n        this.hackyWayToStopPanBeyondBounds__domain = null;\n\n        this.panInProgress = false;\n\n        const { xScale, plotData, chartConfigs } = state;\n\n        this.triggerEvent(\"panend\", state, e);\n\n        requestAnimationFrame(() => {\n            const { xAccessor, fullData } = this.state;\n\n            const firstItem = head(fullData);\n            const scale_start = head(xScale.domain());\n            const data_start = xAccessor!(firstItem);\n\n            const lastItem = last(fullData);\n            const scale_end = last(xScale.domain());\n            const data_end = xAccessor!(lastItem);\n\n            const { onLoadAfter, onLoadBefore } = this.props;\n\n            this.clearThreeCanvas();\n\n            this.setState(\n                {\n                    xScale,\n                    plotData,\n                    chartConfigs,\n                },\n                () => {\n                    if (scale_start < data_start) {\n                        if (onLoadBefore !== undefined) {\n                            onLoadBefore(scale_start, data_start);\n                        }\n                    }\n                    if (data_end < scale_end) {\n                        if (onLoadAfter !== undefined) {\n                            onLoadAfter(data_end, scale_end);\n                        }\n                    }\n                },\n            );\n        });\n    };\n\n    public handleMouseDown = (_: number[], __: string[], e: React.MouseEvent) => {\n        this.triggerEvent(\"mousedown\", this.mutableState, e);\n    };\n\n    public handleMouseEnter = (e: React.MouseEvent) => {\n        this.triggerEvent(\n            \"mouseenter\",\n            {\n                show: true,\n            },\n            e,\n        );\n    };\n\n    public handleMouseMove = (mouseXY: [number, number], _: string, e: any) => {\n        if (this.waitingForMouseMoveAnimationFrame) {\n            return;\n        }\n        this.waitingForMouseMoveAnimationFrame = true;\n        const { chartConfigs, plotData, xScale, xAccessor } = this.state;\n        const currentCharts = getCurrentCharts(chartConfigs, mouseXY);\n        const currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n        this.triggerEvent(\n            \"mousemove\",\n            {\n                show: true,\n                mouseXY,\n                // prevMouseXY is used in interactive components\n                prevMouseXY: this.prevMouseXY,\n                currentItem,\n                currentCharts,\n            },\n            e,\n        );\n        this.prevMouseXY = mouseXY;\n        this.mutableState = {\n            mouseXY,\n            currentItem,\n            currentCharts,\n        };\n        requestAnimationFrame(() => {\n            this.clearMouseCanvas();\n            this.draw({ trigger: \"mousemove\" });\n            this.waitingForMouseMoveAnimationFrame = false;\n        });\n    };\n\n    public handleMouseLeave = (e: any) => {\n        this.triggerEvent(\"mouseleave\", { show: false }, e);\n        this.clearMouseCanvas();\n        this.draw({ trigger: \"mouseleave\" });\n    };\n\n    public handleDragStart = ({ startPos }: any, e: any) => {\n        this.triggerEvent(\"dragstart\", { startPos }, e);\n    };\n\n    public handleDrag = (\n        { startPos, mouseXY }: { startPos: [number, number]; mouseXY: [number, number] },\n        e: React.MouseEvent,\n    ) => {\n        const { chartConfigs, plotData, xScale, xAccessor } = this.state;\n\n        const currentCharts = getCurrentCharts(chartConfigs, mouseXY);\n        const currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n\n        this.triggerEvent(\n            \"drag\",\n            {\n                startPos,\n                mouseXY,\n                currentItem,\n                currentCharts,\n            },\n            e,\n        );\n\n        this.mutableState = {\n            mouseXY,\n            currentItem,\n            currentCharts,\n        };\n\n        requestAnimationFrame(() => {\n            this.clearMouseCanvas();\n            this.draw({ trigger: \"drag\" });\n        });\n    };\n\n    public handleDragEnd = ({ mouseXY }: { mouseXY: number[] }, e: React.MouseEvent) => {\n        this.triggerEvent(\"dragend\", { mouseXY }, e);\n\n        requestAnimationFrame(() => {\n            this.clearMouseCanvas();\n            this.draw({ trigger: \"dragend\" });\n        });\n    };\n\n    public handleClick = (_: number[], e: React.MouseEvent) => {\n        this.triggerEvent(\"click\", this.mutableState, e);\n\n        requestAnimationFrame(() => {\n            this.clearMouseCanvas();\n            this.draw({ trigger: \"click\" });\n        });\n    };\n\n    public handleDoubleClick = (_: number[], e: React.MouseEvent) => {\n        this.triggerEvent(\"dblclick\", {}, e);\n    };\n\n    // TODO: Memoize this\n    public getContextValues(): ChartCanvasContextType<TXAxis> {\n        const dimensions = getDimensions(this.props);\n        return {\n            chartId: -1,\n            fullData: this.state.fullData,\n            plotData: this.state.plotData,\n            width: dimensions.width,\n            height: dimensions.height,\n            chartConfigs: this.state.chartConfigs,\n            xScale: this.state.xScale,\n            xAccessor: this.state.xAccessor,\n            displayXAccessor: this.state.displayXAccessor,\n            margin: this.props.margin,\n            ratio: this.props.ratio,\n            xAxisZoom: this.xAxisZoom,\n            yAxisZoom: this.yAxisZoom,\n            getCanvasContexts: this.getCanvasContexts,\n            redraw: this.redraw,\n            subscribe: this.subscribe,\n            unsubscribe: this.unsubscribe,\n            generateSubscriptionId: this.generateSubscriptionId,\n            getMutableState: this.getMutableState,\n            amIOnTop: this.amIOnTop,\n            setCursorClass: this.setCursorClass,\n        };\n    }\n\n    public resetYDomain = (chartId?: string) => {\n        const { chartConfigs } = this.state;\n        let changed = false;\n        const newChartConfig = chartConfigs.map((each: any) => {\n            if (\n                (isNotDefined(chartId) || each.id === chartId) &&\n                !shallowEqual(each.yScale.domain(), each.realYDomain)\n            ) {\n                changed = true;\n                return {\n                    ...each,\n                    yScale: each.yScale.domain(each.realYDomain),\n                    yPanEnabled: false,\n                };\n            }\n            return each;\n        });\n\n        if (changed) {\n            this.clearThreeCanvas();\n            this.setState({\n                chartConfigs: newChartConfig,\n            });\n        }\n    };\n\n    public shouldComponentUpdate() {\n        return !this.panInProgress;\n    }\n\n    public render() {\n        const {\n            disableInteraction,\n            disablePan,\n            disableZoom,\n            useCrossHairStyleCursor,\n            onClick,\n            onDoubleClick,\n            height,\n            width,\n            margin = ChartCanvas.defaultProps.margin,\n            className,\n            zIndex = ChartCanvas.defaultProps.zIndex,\n            defaultFocus,\n            ratio,\n            mouseMoveEvent,\n        } = this.props;\n\n        const { plotData, xScale, xAccessor, chartConfigs } = this.state;\n\n        const dimensions = getDimensions(this.props);\n\n        const interaction = isInteractionEnabled(xScale, xAccessor, plotData);\n\n        const cursorStyle = useCrossHairStyleCursor && interaction;\n\n        const cursor = getCursorStyle();\n\n        return (\n            <ChartCanvasContext.Provider value={this.getContextValues()}>\n                <div\n                    style={{ position: \"relative\", width, height }}\n                    className={className}\n                    onClick={onClick}\n                    onDoubleClick={onDoubleClick}\n                >\n                    <CanvasContainer\n                        ref={this.canvasContainerRef}\n                        ratio={ratio}\n                        width={width}\n                        height={height}\n                        style={{ height, zIndex, width }}\n                    />\n                    <svg\n                        className={className}\n                        width={width}\n                        height={height}\n                        style={{ position: \"absolute\", zIndex: zIndex + 5 }}\n                    >\n                        {cursor}\n                        <defs>\n                            <clipPath id=\"chart-area-clip\">\n                                <rect x=\"0\" y=\"0\" width={dimensions.width} height={dimensions.height} />\n                            </clipPath>\n                            {chartConfigs.map((each: any, idx: number) => (\n                                <clipPath key={idx} id={`chart-area-clip-${each.id}`}>\n                                    <rect x=\"0\" y=\"0\" width={each.width} height={each.height} />\n                                </clipPath>\n                            ))}\n                        </defs>\n                        <g transform={`translate(${margin.left + 0.5}, ${margin.top + 0.5})`}>\n                            <EventCapture\n                                ref={this.eventCaptureRef}\n                                useCrossHairStyleCursor={cursorStyle}\n                                mouseMove={mouseMoveEvent && interaction}\n                                zoom={!disableZoom && interaction}\n                                pan={!disablePan && interaction}\n                                width={dimensions.width}\n                                height={dimensions.height}\n                                chartConfig={chartConfigs}\n                                xScale={xScale!}\n                                xAccessor={xAccessor}\n                                focus={defaultFocus}\n                                disableInteraction={disableInteraction}\n                                getAllPanConditions={this.getAllPanConditions}\n                                onContextMenu={this.handleContextMenu}\n                                onClick={this.handleClick}\n                                onDoubleClick={this.handleDoubleClick}\n                                onMouseDown={this.handleMouseDown}\n                                onMouseMove={this.handleMouseMove}\n                                onMouseEnter={this.handleMouseEnter}\n                                onMouseLeave={this.handleMouseLeave}\n                                onDragStart={this.handleDragStart}\n                                onDrag={this.handleDrag}\n                                onDragComplete={this.handleDragEnd}\n                                onZoom={this.handleZoom}\n                                onPinchZoom={this.handlePinchZoom}\n                                onPinchZoomEnd={this.handlePinchZoomEnd}\n                                onPan={this.handlePan}\n                                onPanEnd={this.handlePanEnd}\n                            />\n\n                            <g className=\"react-financial-charts-avoid-interaction\">{this.props.children}</g>\n                        </g>\n                    </svg>\n                </div>\n            </ChartCanvasContext.Provider>\n        );\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}