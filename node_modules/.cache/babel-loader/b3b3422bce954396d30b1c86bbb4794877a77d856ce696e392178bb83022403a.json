{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nexports.plotDataLengthBarWidth = plotDataLengthBarWidth;\nexports.timeIntervalBarWidth = timeIntervalBarWidth;\nvar _utils = require(\"../utils\");\n\n/**\n * Bar width is based on the amount of items in the plot data and the distance between the first and last of those\n * items.\n * @param props the props passed to the series.\n * @param moreProps an object holding the xScale, xAccessor and plotData.\n * @return {number} the bar width.\n */\nfunction plotDataLengthBarWidth(props, moreProps) {\n  var widthRatio = props.widthRatio;\n  var xScale = moreProps.xScale;\n  var _xScale$range = xScale.range(),\n    _xScale$range2 = _slicedToArray(_xScale$range, 2),\n    l = _xScale$range2[0],\n    r = _xScale$range2[1];\n  var totalWidth = Math.abs(r - l);\n  if (xScale.invert != null) {\n    var _xScale$domain = xScale.domain(),\n      _xScale$domain2 = _slicedToArray(_xScale$domain, 2),\n      dl = _xScale$domain2[0],\n      dr = _xScale$domain2[1];\n    var width = totalWidth / Math.abs(dl - dr);\n    return width * widthRatio;\n  } else {\n    var _width = totalWidth / xScale.domain().length;\n    return _width * widthRatio;\n  }\n}\n\n/**\n * Generates a width function that calculates the bar width based on the given time interval.\n * @param interval a d3-time time interval.\n * @return {Function} the width function.\n */\nfunction timeIntervalBarWidth(interval) {\n  return function (props, moreProps) {\n    var widthRatio = props.widthRatio;\n    var xScale = moreProps.xScale,\n      xAccessor = moreProps.xAccessor,\n      plotData = moreProps.plotData;\n    var first = xAccessor((0, _utils.head)(plotData));\n    return Math.abs(xScale(interval.offset(first, 1)) - xScale(first)) * widthRatio;\n  };\n}","map":{"version":3,"names":["plotDataLengthBarWidth","timeIntervalBarWidth","_utils","require","props","moreProps","widthRatio","xScale","_xScale$range","range","_xScale$range2","_slicedToArray","l","r","totalWidth","Math","abs","invert","_xScale$domain","domain","_xScale$domain2","dl","dr","width","_width","length","interval","xAccessor","plotData","first","head","offset"],"sources":["C:\\Users\\gabby\\trax-x\\node_modules\\src\\lib\\utils\\barWidth.js"],"sourcesContent":["\n\nimport { head } from \"../utils\";\n\n/**\n * Bar width is based on the amount of items in the plot data and the distance between the first and last of those\n * items.\n * @param props the props passed to the series.\n * @param moreProps an object holding the xScale, xAccessor and plotData.\n * @return {number} the bar width.\n */\nexport function plotDataLengthBarWidth(props, moreProps) {\n\tconst { widthRatio } = props;\n\tconst { xScale } = moreProps;\n\n\tconst [l, r] = xScale.range();\n\n\tconst totalWidth = Math.abs(r - l);\n\tif (xScale.invert != null) {\n\t\tconst [dl, dr] = xScale.domain();\n\t\tconst width = totalWidth / Math.abs(dl - dr);\n\t\treturn width * widthRatio;\n\t} else {\n\t\tconst width = totalWidth / xScale.domain().length;\n\t\treturn width * widthRatio;\n\t}\n}\n\n/**\n * Generates a width function that calculates the bar width based on the given time interval.\n * @param interval a d3-time time interval.\n * @return {Function} the width function.\n */\nexport function timeIntervalBarWidth(interval) {\n\treturn function(props, moreProps) {\n\t\tconst { widthRatio } = props;\n\t\tconst { xScale, xAccessor, plotData } = moreProps;\n\n\t\tconst first = xAccessor(head(plotData));\n\t\treturn Math.abs(xScale(interval.offset(first, 1)) - xScale(first)) * widthRatio;\n\t};\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAWgBA,sB,GAAAA,sB;QAsBAC,oB,GAAAA,oB;AA/BhB,IAAAC,MAAA,GAAAC,OAAA;;AAEA;;;;;;;AAOO,SAASH,sBAATA,CAAgCI,KAAhC,EAAuCC,SAAvC,EAAkD;EAAA,IAChDC,UADgD,GACjCF,KADiC,CAChDE,UADgD;EAAA,IAEhDC,MAFgD,GAErCF,SAFqC,CAEhDE,MAFgD;EAAA,IAAAC,aAAA,GAIzCD,MAAA,CAAOE,KAAP,EAJyC;IAAAC,cAAA,GAAAC,cAAA,CAAAH,aAAA;IAIjDI,CAJiD,GAAAF,cAAA;IAI9CG,CAJ8C,GAAAH,cAAA;EAMxD,IAAMI,UAAA,GAAaC,IAAA,CAAKC,GAAL,CAASH,CAAA,GAAID,CAAb,CAAnB;EACA,IAAIL,MAAA,CAAOU,MAAP,IAAiB,IAArB,EAA2B;IAAA,IAAAC,cAAA,GACTX,MAAA,CAAOY,MAAP,EADS;MAAAC,eAAA,GAAAT,cAAA,CAAAO,cAAA;MACnBG,EADmB,GAAAD,eAAA;MACfE,EADe,GAAAF,eAAA;IAE1B,IAAMG,KAAA,GAAQT,UAAA,GAAaC,IAAA,CAAKC,GAAL,CAASK,EAAA,GAAKC,EAAd,CAA3B;IACA,OAAOC,KAAA,GAAQjB,UAAf;EACA,CAJD,MAIO;IACN,IAAMkB,MAAA,GAAQV,UAAA,GAAaP,MAAA,CAAOY,MAAP,GAAgBM,MAA3C;IACA,OAAOD,MAAA,GAAQlB,UAAf;EACA;AACD;;AAED;;;;;AAKO,SAASL,oBAATA,CAA8ByB,QAA9B,EAAwC;EAC9C,OAAO,UAAStB,KAAT,EAAgBC,SAAhB,EAA2B;IAAA,IACzBC,UADyB,GACVF,KADU,CACzBE,UADyB;IAAA,IAEzBC,MAFyB,GAEOF,SAFP,CAEzBE,MAFyB;MAEjBoB,SAFiB,GAEOtB,SAFP,CAEjBsB,SAFiB;MAENC,QAFM,GAEOvB,SAFP,CAENuB,QAFM;IAIjC,IAAMC,KAAA,GAAQF,SAAA,CAAU,IAAAzB,MAAA,CAAA4B,IAAA,EAAKF,QAAL,CAAV,CAAd;IACA,OAAOb,IAAA,CAAKC,GAAL,CAAST,MAAA,CAAOmB,QAAA,CAASK,MAAT,CAAgBF,KAAhB,EAAuB,CAAvB,CAAP,IAAoCtB,MAAA,CAAOsB,KAAP,CAA7C,IAA8DvB,UAArE;EACA,CAND;AAOA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}