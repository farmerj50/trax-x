{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { first, GenericChartComponent, getAxisCanvas, getStrokeDasharrayCanvas, last } from \"@react-financial-charts/core\";\nimport { range as d3Range, zip } from \"d3-array\";\nimport { forceCollide, forceSimulation, forceX } from \"d3-force\";\nimport * as React from \"react\";\nimport { AxisZoomCapture } from \"./AxisZoomCapture\";\nexport class Axis extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.chartRef = React.createRef();\n    this.getMoreProps = () => {\n      return this.chartRef.current.getMoreProps();\n    };\n    this.drawOnCanvas = (ctx, moreProps) => {\n      const {\n        showDomain,\n        showGridLines,\n        showTickLabel,\n        showTicks,\n        transform,\n        range,\n        getScale,\n        tickLabelFill\n      } = this.props;\n      ctx.save();\n      ctx.translate(transform[0], transform[1]);\n      const scale = getScale(moreProps);\n      const tickProps = tickHelper(this.props, scale);\n      if (showTicks) {\n        drawTicks(ctx, tickProps);\n      }\n      if (showGridLines) {\n        tickProps.ticks.forEach(tick => {\n          drawGridLine(ctx, tick, tickProps, moreProps);\n        });\n      }\n      if (showTickLabel) {\n        const {\n          fontFamily,\n          fontSize,\n          fontWeight,\n          textAnchor\n        } = tickProps;\n        ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n        if (tickLabelFill !== undefined) {\n          ctx.fillStyle = tickLabelFill;\n        }\n        ctx.textAlign = textAnchor === \"middle\" ? \"center\" : textAnchor;\n        tickProps.ticks.forEach(tick => {\n          drawEachTickLabel(ctx, tick, tickProps);\n        });\n      }\n      if (showDomain) {\n        drawAxisLine(ctx, this.props, range);\n      }\n      ctx.restore();\n    };\n  }\n  render() {\n    const {\n      bg,\n      axisZoomCallback,\n      className,\n      zoomCursorClassName,\n      zoomEnabled,\n      getScale,\n      inverted,\n      transform,\n      getMouseDelta,\n      edgeClip,\n      onContextMenu,\n      onDoubleClick\n    } = this.props;\n    const zoomCapture = zoomEnabled ? React.createElement(AxisZoomCapture, {\n      bg: bg,\n      getScale: getScale,\n      getMoreProps: this.getMoreProps,\n      getMouseDelta: getMouseDelta,\n      axisZoomCallback: axisZoomCallback,\n      className: className,\n      zoomCursorClassName: zoomCursorClassName,\n      inverted: inverted,\n      onContextMenu: onContextMenu,\n      onDoubleClick: onDoubleClick\n    }) : null;\n    return React.createElement(\"g\", {\n      transform: `translate(${transform[0]}, ${transform[1]})`\n    }, zoomCapture, React.createElement(GenericChartComponent, {\n      ref: this.chartRef,\n      canvasToDraw: getAxisCanvas,\n      clip: false,\n      edgeClip: edgeClip,\n      canvasDraw: this.drawOnCanvas,\n      drawOn: [\"pan\"]\n    }));\n  }\n}\nAxis.defaultProps = {\n  edgeClip: false,\n  zoomEnabled: false,\n  zoomCursorClassName: \"\"\n};\nconst tickHelper = (props, scale) => {\n  const {\n      orient,\n      innerTickSize = 4,\n      tickFormat,\n      tickPadding = 4,\n      tickLabelFill,\n      tickStrokeWidth,\n      tickStrokeDasharray,\n      fontSize = 12,\n      fontFamily,\n      fontWeight,\n      showTicks,\n      showTickLabel,\n      ticks: tickArguments,\n      tickValues: tickValuesProp,\n      tickStrokeStyle,\n      tickInterval,\n      tickIntervalFunction\n    } = props,\n    rest = __rest(props, [\"orient\", \"innerTickSize\", \"tickFormat\", \"tickPadding\", \"tickLabelFill\", \"tickStrokeWidth\", \"tickStrokeDasharray\", \"fontSize\", \"fontFamily\", \"fontWeight\", \"showTicks\", \"showTickLabel\", \"ticks\", \"tickValues\", \"tickStrokeStyle\", \"tickInterval\", \"tickIntervalFunction\"]);\n  let tickValues;\n  if (tickValuesProp !== undefined) {\n    if (typeof tickValuesProp === \"function\") {\n      tickValues = tickValuesProp(scale.domain());\n    } else {\n      tickValues = tickValuesProp;\n    }\n  } else if (tickInterval !== undefined) {\n    const [min, max] = scale.domain();\n    const baseTickValues = d3Range(min, max, (max - min) / tickInterval);\n    tickValues = tickIntervalFunction ? tickIntervalFunction(min, max, tickInterval) : baseTickValues;\n  } else if (scale.ticks !== undefined) {\n    tickValues = scale.ticks(tickArguments);\n  } else {\n    tickValues = scale.domain();\n  }\n  const format = tickFormat === undefined ? scale.tickFormat(tickArguments) : d => tickFormat(d) || \"\";\n  const sign = orient === \"top\" || orient === \"left\" ? -1 : 1;\n  const tickSpacing = Math.max(innerTickSize, 0) + tickPadding;\n  let ticks;\n  let dy;\n  // tslint:disable-next-line: variable-name\n  let canvas_dy;\n  let textAnchor;\n  if (orient === \"bottom\" || orient === \"top\") {\n    dy = sign < 0 ? \"0em\" : \".71em\";\n    canvas_dy = sign < 0 ? 0 : fontSize * 0.71;\n    textAnchor = \"middle\";\n    const y2 = sign * innerTickSize;\n    const labelY = sign * tickSpacing;\n    ticks = tickValues.map(d => {\n      const x = Math.round(scale(d));\n      return {\n        value: d,\n        x1: x,\n        y1: 0,\n        x2: x,\n        y2,\n        labelX: x,\n        labelY\n      };\n    });\n    if (showTicks) {\n      const nodes = ticks.map(d => ({\n        id: d.value,\n        value: d.value,\n        fy: d.y2,\n        origX: d.x1\n      }));\n      const simulation = forceSimulation(nodes).force(\"x\", forceX(d => d.origX).strength(1)).force(\"collide\", forceCollide(22)).stop();\n      for (let i = 0; i < 100; ++i) {\n        simulation.tick();\n      }\n      // @ts-ignore\n      ticks = zip(ticks, nodes).map(d => {\n        const a = d[0];\n        const b = d[1];\n        if (Math.abs(b.x - b.origX) > 0.01) {\n          return Object.assign(Object.assign({}, a), {\n            x2: b.x,\n            labelX: b.x\n          });\n        }\n        return a;\n      });\n    }\n  } else {\n    ticks = tickValues.map(d => {\n      const y = Math.round(scale(d));\n      const x2 = sign * innerTickSize;\n      const labelX = sign * tickSpacing;\n      return {\n        value: d,\n        x1: 0,\n        y1: y,\n        x2,\n        y2: y,\n        labelX,\n        labelY: y\n      };\n    });\n    dy = \".32em\";\n    canvas_dy = fontSize * 0.32;\n    textAnchor = sign < 0 ? \"end\" : \"start\";\n  }\n  return Object.assign({\n    orient,\n    ticks,\n    scale,\n    tickStrokeStyle,\n    tickLabelFill: tickLabelFill || tickStrokeStyle,\n    tickStrokeWidth,\n    tickStrokeDasharray,\n    dy,\n    canvas_dy,\n    textAnchor,\n    fontSize,\n    fontFamily,\n    fontWeight,\n    format,\n    showTickLabel\n  }, rest);\n};\nconst drawAxisLine = (ctx, props, range) => {\n  const {\n    orient,\n    outerTickSize,\n    strokeStyle,\n    strokeWidth\n  } = props;\n  const sign = orient === \"top\" || orient === \"left\" ? -1 : 1;\n  const xAxis = orient === \"bottom\" || orient === \"top\";\n  ctx.lineWidth = strokeWidth;\n  ctx.strokeStyle = strokeStyle;\n  ctx.beginPath();\n  const firstPoint = first(range);\n  const lastPoint = last(range);\n  const tickSize = sign * outerTickSize;\n  if (xAxis) {\n    ctx.moveTo(firstPoint, tickSize);\n    ctx.lineTo(firstPoint, 0);\n    ctx.lineTo(lastPoint, 0);\n    ctx.lineTo(lastPoint, tickSize);\n  } else {\n    ctx.moveTo(tickSize, firstPoint);\n    ctx.lineTo(0, firstPoint);\n    ctx.lineTo(0, lastPoint);\n    ctx.lineTo(tickSize, lastPoint);\n  }\n  ctx.stroke();\n};\nconst drawTicks = (ctx, result) => {\n  const {\n    ticks,\n    tickStrokeStyle\n  } = result;\n  if (tickStrokeStyle !== undefined) {\n    ctx.strokeStyle = tickStrokeStyle;\n    ctx.fillStyle = tickStrokeStyle;\n  }\n  ticks.forEach(tick => {\n    drawEachTick(ctx, tick, result);\n  });\n};\nconst drawGridLine = (ctx, tick, result, moreProps) => {\n  const {\n    orient,\n    gridLinesStrokeWidth,\n    gridLinesStrokeStyle,\n    gridLinesStrokeDasharray\n  } = result;\n  const {\n    chartConfig\n  } = moreProps;\n  const {\n    height,\n    width\n  } = chartConfig;\n  if (gridLinesStrokeStyle !== undefined) {\n    ctx.strokeStyle = gridLinesStrokeStyle;\n  }\n  ctx.beginPath();\n  const sign = orient === \"top\" || orient === \"left\" ? 1 : -1;\n  switch (orient) {\n    case \"top\":\n    case \"bottom\":\n      ctx.moveTo(tick.x1, 0);\n      ctx.lineTo(tick.x2, sign * height);\n      break;\n    default:\n      ctx.moveTo(0, tick.y1);\n      ctx.lineTo(sign * width, tick.y2);\n      break;\n  }\n  ctx.lineWidth = gridLinesStrokeWidth;\n  const lineDash = getStrokeDasharrayCanvas(gridLinesStrokeDasharray);\n  ctx.setLineDash(lineDash);\n  ctx.stroke();\n};\nconst drawEachTick = (ctx, tick, result) => {\n  const {\n    tickStrokeWidth,\n    tickStrokeDasharray\n  } = result;\n  ctx.beginPath();\n  ctx.moveTo(tick.x1, tick.y1);\n  ctx.lineTo(tick.x2, tick.y2);\n  ctx.lineWidth = tickStrokeWidth;\n  const lineDash = getStrokeDasharrayCanvas(tickStrokeDasharray);\n  ctx.setLineDash(lineDash);\n  ctx.stroke();\n};\nconst drawEachTickLabel = (ctx, tick, result) => {\n  const {\n    canvas_dy,\n    format\n  } = result;\n  const text = format(tick.value);\n  ctx.beginPath();\n  ctx.fillText(text, tick.labelX, tick.labelY + canvas_dy);\n};","map":{"version":3,"names":["first","GenericChartComponent","getAxisCanvas","getStrokeDasharrayCanvas","last","range","d3Range","zip","forceCollide","forceSimulation","forceX","React","AxisZoomCapture","Axis","Component","constructor","chartRef","createRef","getMoreProps","current","drawOnCanvas","ctx","moreProps","showDomain","showGridLines","showTickLabel","showTicks","transform","getScale","tickLabelFill","props","save","translate","scale","tickProps","tickHelper","drawTicks","ticks","forEach","tick","drawGridLine","fontFamily","fontSize","fontWeight","textAnchor","font","undefined","fillStyle","textAlign","drawEachTickLabel","drawAxisLine","restore","render","bg","axisZoomCallback","className","zoomCursorClassName","zoomEnabled","inverted","getMouseDelta","edgeClip","onContextMenu","onDoubleClick","zoomCapture","createElement","ref","canvasToDraw","clip","canvasDraw","drawOn","defaultProps","orient","innerTickSize","tickFormat","tickPadding","tickStrokeWidth","tickStrokeDasharray","tickArguments","tickValues","tickValuesProp","tickStrokeStyle","tickInterval","tickIntervalFunction","rest","__rest","domain","min","max","baseTickValues","format","d","sign","tickSpacing","Math","dy","canvas_dy","y2","labelY","map","x","round","value","x1","y1","x2","labelX","nodes","id","fy","origX","simulation","force","strength","stop","i","a","b","abs","Object","assign","y","outerTickSize","strokeStyle","strokeWidth","xAxis","lineWidth","beginPath","firstPoint","lastPoint","tickSize","moveTo","lineTo","stroke","result","drawEachTick","gridLinesStrokeWidth","gridLinesStrokeStyle","gridLinesStrokeDasharray","chartConfig","height","width","lineDash","setLineDash","text","fillText"],"sources":["C:\\Users\\gabby\\trax-x\\node_modules\\@react-financial-charts\\axes\\src\\Axis.tsx"],"sourcesContent":["import {\n    first,\n    GenericChartComponent,\n    getAxisCanvas,\n    getStrokeDasharrayCanvas,\n    last,\n    strokeDashTypes,\n} from \"@react-financial-charts/core\";\nimport { range as d3Range, zip } from \"d3-array\";\nimport { forceCollide, forceSimulation, forceX } from \"d3-force\";\nimport { ScaleContinuousNumeric } from \"d3-scale\";\nimport * as React from \"react\";\nimport { AxisZoomCapture } from \"./AxisZoomCapture\";\n\ninterface AxisProps {\n    readonly axisZoomCallback?: (domain: number[]) => void;\n    readonly bg: {\n        h: number;\n        x: number;\n        w: number;\n        y: number;\n    };\n    readonly className?: string;\n    readonly domainClassName?: string;\n    readonly edgeClip: boolean;\n    readonly fontFamily?: string;\n    readonly fontSize?: number;\n    readonly fontWeight?: number;\n    readonly getMouseDelta: (startXY: [number, number], mouseXY: [number, number]) => number;\n    readonly getScale: (moreProps: any) => ScaleContinuousNumeric<number, number>;\n    readonly innerTickSize?: number;\n    readonly inverted?: boolean;\n    readonly onContextMenu?: (e: React.MouseEvent, mousePosition: [number, number]) => void;\n    readonly onDoubleClick?: (e: React.MouseEvent, mousePosition: [number, number]) => void;\n    readonly orient?: \"top\" | \"left\" | \"right\" | \"bottom\";\n    readonly outerTickSize: number;\n    readonly range: number[];\n    readonly showDomain?: boolean;\n    readonly showGridLines?: boolean;\n    readonly showTicks?: boolean;\n    readonly showTickLabel?: boolean;\n    readonly strokeStyle: string;\n    readonly strokeWidth: number;\n    readonly tickFormat?: (data: any) => string;\n    readonly tickPadding?: number;\n    readonly tickSize?: number;\n    readonly ticks?: number;\n    readonly tickLabelFill?: string;\n    readonly tickStrokeStyle?: string;\n    readonly tickStrokeWidth?: number;\n    readonly tickStrokeDasharray?: strokeDashTypes;\n    readonly tickValues?: number[] | ((domain: number[]) => number[]);\n    readonly tickInterval?: number;\n    readonly tickIntervalFunction?: (min: number, max: number, tickInterval: number) => number[];\n    readonly transform: number[];\n    readonly zoomEnabled?: boolean;\n    readonly zoomCursorClassName?: string;\n}\n\ninterface Tick {\n    value: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    labelX: number;\n    labelY: number;\n}\n\nexport class Axis extends React.Component<AxisProps> {\n    public static defaultProps = {\n        edgeClip: false,\n        zoomEnabled: false,\n        zoomCursorClassName: \"\",\n    };\n\n    private readonly chartRef = React.createRef<GenericChartComponent>();\n\n    public render() {\n        const {\n            bg,\n            axisZoomCallback,\n            className,\n            zoomCursorClassName,\n            zoomEnabled,\n            getScale,\n            inverted,\n            transform,\n            getMouseDelta,\n            edgeClip,\n            onContextMenu,\n            onDoubleClick,\n        } = this.props;\n\n        const zoomCapture = zoomEnabled ? (\n            <AxisZoomCapture\n                bg={bg}\n                getScale={getScale}\n                getMoreProps={this.getMoreProps}\n                getMouseDelta={getMouseDelta}\n                axisZoomCallback={axisZoomCallback}\n                className={className}\n                zoomCursorClassName={zoomCursorClassName}\n                inverted={inverted}\n                onContextMenu={onContextMenu}\n                onDoubleClick={onDoubleClick}\n            />\n        ) : null;\n\n        return (\n            <g transform={`translate(${transform[0]}, ${transform[1]})`}>\n                {zoomCapture}\n                <GenericChartComponent\n                    ref={this.chartRef}\n                    canvasToDraw={getAxisCanvas}\n                    clip={false}\n                    edgeClip={edgeClip}\n                    canvasDraw={this.drawOnCanvas}\n                    drawOn={[\"pan\"]}\n                />\n            </g>\n        );\n    }\n\n    private readonly getMoreProps = () => {\n        return this.chartRef.current!.getMoreProps();\n    };\n\n    private readonly drawOnCanvas = (ctx: CanvasRenderingContext2D, moreProps: any) => {\n        const { showDomain, showGridLines, showTickLabel, showTicks, transform, range, getScale, tickLabelFill } =\n            this.props;\n\n        ctx.save();\n        ctx.translate(transform[0], transform[1]);\n\n        const scale = getScale(moreProps);\n        const tickProps = tickHelper(this.props, scale);\n        if (showTicks) {\n            drawTicks(ctx, tickProps);\n        }\n\n        if (showGridLines) {\n            tickProps.ticks.forEach((tick) => {\n                drawGridLine(ctx, tick, tickProps, moreProps);\n            });\n        }\n\n        if (showTickLabel) {\n            const { fontFamily, fontSize, fontWeight, textAnchor } = tickProps;\n\n            ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n            if (tickLabelFill !== undefined) {\n                ctx.fillStyle = tickLabelFill;\n            }\n            ctx.textAlign = textAnchor === \"middle\" ? \"center\" : (textAnchor as CanvasTextAlign);\n            tickProps.ticks.forEach((tick: any) => {\n                drawEachTickLabel(ctx, tick, tickProps);\n            });\n        }\n\n        if (showDomain) {\n            drawAxisLine(ctx, this.props, range);\n        }\n\n        ctx.restore();\n    };\n}\n\nconst tickHelper = (props: AxisProps, scale: ScaleContinuousNumeric<number, number>) => {\n    const {\n        orient,\n        innerTickSize = 4,\n        tickFormat,\n        tickPadding = 4,\n        tickLabelFill,\n        tickStrokeWidth,\n        tickStrokeDasharray,\n        fontSize = 12,\n        fontFamily,\n        fontWeight,\n        showTicks,\n        showTickLabel,\n        ticks: tickArguments,\n        tickValues: tickValuesProp,\n        tickStrokeStyle,\n        tickInterval,\n        tickIntervalFunction,\n        ...rest\n    } = props;\n\n    let tickValues: number[];\n    if (tickValuesProp !== undefined) {\n        if (typeof tickValuesProp === \"function\") {\n            tickValues = tickValuesProp(scale.domain());\n        } else {\n            tickValues = tickValuesProp;\n        }\n    } else if (tickInterval !== undefined) {\n        const [min, max] = scale.domain();\n        const baseTickValues = d3Range(min, max, (max - min) / tickInterval);\n\n        tickValues = tickIntervalFunction ? tickIntervalFunction(min, max, tickInterval) : baseTickValues;\n    } else if (scale.ticks !== undefined) {\n        tickValues = scale.ticks(tickArguments);\n    } else {\n        tickValues = scale.domain();\n    }\n\n    const format = tickFormat === undefined ? scale.tickFormat(tickArguments) : (d: any) => tickFormat(d) || \"\";\n\n    const sign = orient === \"top\" || orient === \"left\" ? -1 : 1;\n    const tickSpacing = Math.max(innerTickSize, 0) + tickPadding;\n\n    let ticks: Tick[];\n    let dy;\n    // tslint:disable-next-line: variable-name\n    let canvas_dy;\n    let textAnchor;\n\n    if (orient === \"bottom\" || orient === \"top\") {\n        dy = sign < 0 ? \"0em\" : \".71em\";\n        canvas_dy = sign < 0 ? 0 : fontSize * 0.71;\n        textAnchor = \"middle\";\n\n        const y2 = sign * innerTickSize;\n        const labelY = sign * tickSpacing;\n\n        ticks = tickValues.map((d) => {\n            const x = Math.round(scale(d));\n            return {\n                value: d,\n                x1: x,\n                y1: 0,\n                x2: x,\n                y2,\n                labelX: x,\n                labelY,\n            };\n        });\n\n        if (showTicks) {\n            const nodes = ticks.map((d) => ({ id: d.value, value: d.value, fy: d.y2, origX: d.x1 }));\n\n            const simulation = forceSimulation(nodes)\n                .force(\"x\", forceX<any>((d) => d.origX).strength(1))\n                .force(\"collide\", forceCollide(22))\n                .stop();\n\n            for (let i = 0; i < 100; ++i) {\n                simulation.tick();\n            }\n\n            // @ts-ignore\n            ticks = zip(ticks, nodes).map((d) => {\n                const a: any = d[0];\n                const b: any = d[1];\n\n                if (Math.abs(b.x - b.origX) > 0.01) {\n                    return {\n                        ...a,\n                        x2: b.x,\n                        labelX: b.x,\n                    };\n                }\n                return a;\n            });\n        }\n    } else {\n        ticks = tickValues.map((d) => {\n            const y = Math.round(scale(d));\n            const x2 = sign * innerTickSize;\n            const labelX = sign * tickSpacing;\n            return {\n                value: d,\n                x1: 0,\n                y1: y,\n                x2,\n                y2: y,\n                labelX,\n                labelY: y,\n            };\n        });\n\n        dy = \".32em\";\n        canvas_dy = fontSize * 0.32;\n        textAnchor = sign < 0 ? \"end\" : \"start\";\n    }\n\n    return {\n        orient,\n        ticks,\n        scale,\n        tickStrokeStyle,\n        tickLabelFill: tickLabelFill || tickStrokeStyle,\n        tickStrokeWidth,\n        tickStrokeDasharray,\n        dy,\n        canvas_dy,\n        textAnchor,\n        fontSize,\n        fontFamily,\n        fontWeight,\n        format,\n        showTickLabel,\n        ...rest,\n    };\n};\n\nconst drawAxisLine = (ctx: CanvasRenderingContext2D, props: AxisProps, range: any) => {\n    const { orient, outerTickSize, strokeStyle, strokeWidth } = props;\n\n    const sign = orient === \"top\" || orient === \"left\" ? -1 : 1;\n    const xAxis = orient === \"bottom\" || orient === \"top\";\n\n    ctx.lineWidth = strokeWidth;\n    ctx.strokeStyle = strokeStyle;\n\n    ctx.beginPath();\n\n    const firstPoint = first(range);\n    const lastPoint = last(range);\n    const tickSize = sign * outerTickSize;\n    if (xAxis) {\n        ctx.moveTo(firstPoint, tickSize);\n        ctx.lineTo(firstPoint, 0);\n        ctx.lineTo(lastPoint, 0);\n        ctx.lineTo(lastPoint, tickSize);\n    } else {\n        ctx.moveTo(tickSize, firstPoint);\n        ctx.lineTo(0, firstPoint);\n        ctx.lineTo(0, lastPoint);\n        ctx.lineTo(tickSize, lastPoint);\n    }\n\n    ctx.stroke();\n};\n\nconst drawTicks = (ctx: CanvasRenderingContext2D, result: any) => {\n    const { ticks, tickStrokeStyle } = result;\n\n    if (tickStrokeStyle !== undefined) {\n        ctx.strokeStyle = tickStrokeStyle;\n        ctx.fillStyle = tickStrokeStyle;\n    }\n\n    ticks.forEach((tick: any) => {\n        drawEachTick(ctx, tick, result);\n    });\n};\n\nconst drawGridLine = (ctx: CanvasRenderingContext2D, tick: Tick, result: any, moreProps: any) => {\n    const { orient, gridLinesStrokeWidth, gridLinesStrokeStyle, gridLinesStrokeDasharray } = result;\n\n    const { chartConfig } = moreProps;\n\n    const { height, width } = chartConfig;\n\n    if (gridLinesStrokeStyle !== undefined) {\n        ctx.strokeStyle = gridLinesStrokeStyle;\n    }\n    ctx.beginPath();\n\n    const sign = orient === \"top\" || orient === \"left\" ? 1 : -1;\n\n    switch (orient) {\n        case \"top\":\n        case \"bottom\":\n            ctx.moveTo(tick.x1, 0);\n            ctx.lineTo(tick.x2, sign * height);\n            break;\n        default:\n            ctx.moveTo(0, tick.y1);\n            ctx.lineTo(sign * width, tick.y2);\n            break;\n    }\n    ctx.lineWidth = gridLinesStrokeWidth;\n\n    const lineDash = getStrokeDasharrayCanvas(gridLinesStrokeDasharray);\n\n    ctx.setLineDash(lineDash);\n    ctx.stroke();\n};\n\nconst drawEachTick = (ctx: CanvasRenderingContext2D, tick: any, result: any) => {\n    const { tickStrokeWidth, tickStrokeDasharray } = result;\n\n    ctx.beginPath();\n\n    ctx.moveTo(tick.x1, tick.y1);\n    ctx.lineTo(tick.x2, tick.y2);\n    ctx.lineWidth = tickStrokeWidth;\n\n    const lineDash = getStrokeDasharrayCanvas(tickStrokeDasharray);\n\n    ctx.setLineDash(lineDash);\n    ctx.stroke();\n};\n\nconst drawEachTickLabel = (ctx: CanvasRenderingContext2D, tick: any, result: any) => {\n    const { canvas_dy, format } = result;\n\n    const text = format(tick.value);\n\n    ctx.beginPath();\n\n    ctx.fillText(text, tick.labelX, tick.labelY + canvas_dy);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}