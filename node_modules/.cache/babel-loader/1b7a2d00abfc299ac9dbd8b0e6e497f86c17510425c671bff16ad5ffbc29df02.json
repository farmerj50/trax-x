{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport { ChartLocation, ControlPoints } from '../../common/utils/helper';\nimport { extend, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { LineBase } from './line-base';\n/**\n * Base class for spline-type series.\n *\n * @private\n */\nvar SplineBase = /** @class */function (_super) {\n  __extends(SplineBase, _super);\n  /**\n   * Initializes the spline rendering module.\n   *\n   * @param {Chart} [chartModule] - Specifies the chart instance.\n   */\n  function SplineBase(chartModule) {\n    var _this = _super.call(this, chartModule) || this;\n    _this.splinePoints = [];\n    _this.lowSplinePoints = [];\n    return _this;\n  }\n  /**\n   * Finds the spline points for the series.\n   *\n   * @param {Series} series - The series for which spline points need to be found.\n   * @returns {void}\n   * @private\n   */\n  SplineBase.prototype.findSplinePoint = function (series) {\n    var value;\n    var lowPoints;\n    var realPoints = [];\n    var points = [];\n    var point;\n    var pointIndex = 0;\n    var negativePoint = false;\n    realPoints = this.filterEmptyPoints(series);\n    for (var i = 0; i < realPoints.length; i++) {\n      point = realPoints[i];\n      if (point.x === null || point.x === '') {\n        continue;\n      } else {\n        point.index = pointIndex;\n        pointIndex++;\n        points.push(point);\n      }\n    }\n    var isLow = false;\n    this.splinePoints = this.findSplineCoefficients(points, series, isLow);\n    if (series.type === 'SplineRangeArea') {\n      isLow = !isLow;\n      this.lowSplinePoints = this.findSplineCoefficients(points, series, isLow);\n    }\n    if (points.length > 1) {\n      series.drawPoints = [];\n      series.lowDrawPoints = [];\n      for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n        var point_1 = points_1[_i];\n        negativePoint = negativePoint ? negativePoint : point_1.yValue < 0;\n        if (point_1.index !== 0) {\n          var previous = this.getPreviousIndex(points, point_1.index - 1, series);\n          if (series.type === 'SplineRangeArea') {\n            points[previous].yValue = points[previous].high > points[previous].low ? points[previous].high : points[previous].low;\n            point_1.yValue = point_1.high > point_1.low ? point_1.high : point_1.low;\n          }\n          value = this.getControlPoints(points[previous], point_1, this.splinePoints[previous], this.splinePoints[point_1.index], series);\n          series.drawPoints.push(value);\n          if (series.type === 'SplineRangeArea') {\n            points[previous].yValue = points[previous].low < points[previous].high ? points[previous].low : points[previous].high;\n            point_1.yValue = point_1.low < point_1.high ? point_1.low : point_1.high;\n            lowPoints = this.getControlPoints(points[previous], point_1, this.lowSplinePoints[previous], this.lowSplinePoints[point_1.index], series);\n            series.lowDrawPoints.push(lowPoints);\n          }\n          // fix for Y-Axis of Spline chart not adjusting scale to suit dataSource issue\n          var delta = series.yMax - series.yMin;\n          if (point_1.yValue && value.controlPoint1.y && value.controlPoint2.y && delta > 1) {\n            series.yMin = Math.min(series.yMin, point_1.yValue, value.controlPoint1.y, value.controlPoint2.y);\n            series.yMax = Math.ceil(Math.max(series.yMax, point_1.yValue, value.controlPoint1.y, value.controlPoint2.y));\n            series.yMin = series.yAxis.valueType !== 'Logarithmic' ? Math.floor(series.yMin) : series.yMin;\n          }\n        }\n      }\n      if (!negativePoint && series.yMin < 0) {\n        series.yMin = 0;\n      }\n      if (series.chart.chartAreaType === 'PolarRadar' && series.isClosed) {\n        value = this.getControlPoints({\n          xValue: points[points.length - 1].xValue,\n          yValue: points[points.length - 1].yValue\n        }, {\n          xValue: points[points.length - 1].xValue + 1,\n          yValue: points[0].yValue\n        }, this.splinePoints[0], this.splinePoints[points[points.length - 1].index], series);\n        series.drawPoints.push(value);\n      }\n    }\n  };\n  SplineBase.prototype.getPreviousIndex = function (points, i, series) {\n    if (series.emptyPointSettings.mode !== 'Drop') {\n      return i;\n    }\n    while (isNullOrUndefined(points[i]) && i > -1) {\n      i = i - 1;\n    }\n    return i;\n  };\n  SplineBase.prototype.getNextIndex = function (points, i, series) {\n    if (series.emptyPointSettings.mode !== 'Drop') {\n      return i;\n    }\n    while (isNullOrUndefined(points[i]) && i < points.length) {\n      i = i + 1;\n    }\n    return i;\n  };\n  SplineBase.prototype.filterEmptyPoints = function (series, seriesPoints) {\n    if (series.emptyPointSettings.mode !== 'Drop' && this.isPointInRange(series.points)) {\n      return seriesPoints ? seriesPoints : series.points;\n    }\n    var points = seriesPoints ? seriesPoints : extend([], series.points, null, true);\n    for (var i = 0; i < points.length; i++) {\n      points[i].index = i;\n      if (points[i].isEmpty) {\n        points[i].symbolLocations = [];\n        points[i].regions = [];\n        points.splice(i, 1);\n        i--;\n      }\n    }\n    return points;\n  };\n  /**\n   * Checks if the data points are within the range.\n   *\n   * @param {Points[]} points - The data points to check.\n   * @returns {boolean} True if the data points are within the range, false otherwise.\n   * @private\n   */\n  SplineBase.prototype.isPointInRange = function (points) {\n    for (var _i = 0, points_2 = points; _i < points_2.length; _i++) {\n      var point = points_2[_i];\n      if (!point.isPointInRange) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * Finds the spline coefficients based on the type of spline interpolation.\n   *\n   * @param {Points[]} points - The data points for spline interpolation.\n   * @param {Series} series - The series associated with the data points.\n   * @param {boolean} [isLow] - Indicates whether to calculate the lower bound. Default is false.\n   * @returns {number[]} The calculated coefficients.\n   * @private\n   */\n  SplineBase.prototype.findSplineCoefficients = function (points, series, isLow) {\n    var ySpline = [];\n    var ySplineDuplicate = [];\n    var cardinalSplineTension = series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;\n    // cardinalSplineTension = cardinalSplineTension < 0 ? 0 : cardinalSplineTension > 1 ? 1 : cardinalSplineTension;\n    if (cardinalSplineTension < 0) {\n      cardinalSplineTension = 0;\n    } else if (cardinalSplineTension > 1) {\n      cardinalSplineTension = 1;\n    }\n    switch (series.splineType) {\n      case 'Monotonic':\n        ySpline = this.monotonicSplineCoefficients(points, series, isLow);\n        break;\n      case 'Cardinal':\n        ySpline = this.cardinalSplineCofficients(points, series);\n        break;\n      default:\n        if (series.splineType === 'Clamped') {\n          ySpline = this.clampedSplineCofficients(points, series, isLow);\n        } else {\n          // assigning the first and last value as zero\n          ySpline[0] = ySplineDuplicate[0] = 0;\n          ySpline[points.length - 1] = 0;\n        }\n        ySpline = this.naturalSplineCoefficients(points, series, isLow);\n        break;\n    }\n    return ySpline;\n  };\n  /**\n   * Calculates the coefficients for a monotonic spline interpolation.\n   *\n   * @param {Points[]} points - The data points for spline interpolation.\n   * @param {Series} series - The series associated with the data points.\n   * @param {boolean} isLow - Indicates whether to calculate the lower bound.\n   * @returns {number[]} The calculated coefficients.\n   * @private\n   */\n  SplineBase.prototype.monotonicSplineCoefficients = function (points, series, isLow) {\n    var count = points.length;\n    var ySpline = [];\n    var dx = [];\n    var dy = [];\n    var slope = [];\n    var interPoint;\n    for (var i = 0; i < count - 1; i++) {\n      if (series.type === 'SplineRangeArea') {\n        if (!isLow) {\n          points[i + 1].yValue = points[i + 1].high > points[i + 1].low ? points[i + 1].high : points[i + 1].low;\n          points[i].yValue = points[i].high > points[i].low ? points[i].high : points[i].low;\n        }\n        if (isLow) {\n          points[i + 1].yValue = points[i + 1].low < points[i + 1].high ? points[i + 1].low : points[i + 1].high;\n          points[i].yValue = points[i].low < points[i].high ? points[i].low : points[i].high;\n        }\n      }\n      dx[i] = points[i + 1].xValue - points[i].xValue;\n      dy[i] = points[i + 1].yValue - points[i].yValue;\n      slope[i] = dy[i] / dx[i];\n    }\n    //interpolant points\n    var slopeLength = slope.length;\n    // to find the first and last co-efficient value\n    ySpline[0] = slope[0];\n    ySpline[count - 1] = slope[slopeLength - 1];\n    //to find the other co-efficient values\n    for (var j = 0; j < dx.length; j++) {\n      if (slopeLength > j + 1) {\n        if (slope[j] * slope[j + 1] <= 0) {\n          ySpline[j + 1] = 0;\n        } else {\n          interPoint = dx[j] + dx[j + 1];\n          ySpline[j + 1] = 3 * interPoint / ((interPoint + dx[j + 1]) / slope[j] + (interPoint + dx[j]) / slope[j + 1]);\n        }\n      }\n    }\n    return ySpline;\n  };\n  /**\n   * Calculates the coefficients for a cardinal spline interpolation.\n   *\n   * @param {Points[]} points - The data points for spline interpolation.\n   * @param {Series} series - The series associated with the data points.\n   * @returns {number[]} The calculated coefficients.\n   * @private\n   */\n  SplineBase.prototype.cardinalSplineCofficients = function (points, series) {\n    var count = points.length;\n    var ySpline = [];\n    var cardinalSplineTension = series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;\n    cardinalSplineTension = cardinalSplineTension < 0 ? 0 : cardinalSplineTension > 1 ? 1 : cardinalSplineTension;\n    for (var i = 0; i < count; i++) {\n      if (i === 0) {\n        ySpline[i] = count > 2 ? cardinalSplineTension * (points[i + 2].xValue - points[i].xValue) : 0;\n      } else if (i === count - 1) {\n        ySpline[i] = count > 2 ? cardinalSplineTension * (points[count - 1].xValue - points[count - 3].xValue) : 0;\n      } else {\n        ySpline[i] = cardinalSplineTension * (points[i + 1].xValue - points[i - 1].xValue);\n      }\n    }\n    return ySpline;\n  };\n  /**\n   * Calculates the coefficients for a clamped spline interpolation.\n   *\n   * @param {Points[]} points - The data points for spline interpolation.\n   * @param {Series} series - The series associated with the data points.\n   * @param {boolean} isLow - Indicates whether to calculate the lower bound.\n   * @returns {number[]} The calculated coefficients.\n   * @private\n   */\n  SplineBase.prototype.clampedSplineCofficients = function (points, series, isLow) {\n    var count = points.length;\n    var ySpline = [];\n    var ySplineDuplicate = [];\n    for (var i = 0; i < count - 1; i++) {\n      if (series.type === 'SplineRangeArea') {\n        if (!isLow) {\n          points[1].yValue = points[1].high > points[1].low ? points[1].high : points[1].low;\n          points[0].yValue = points[0].high > points[0].low ? points[0].high : points[0].low;\n          points[points.length - 1].yValue = points[points.length - 1].high > points[points.length - 1].low ? points[points.length - 1].high : points[points.length - 1].low;\n          points[points.length - 2].yValue = points[points.length - 2].high > points[points.length - 2].low ? points[points.length - 2].high : points[points.length - 2].low;\n        }\n        if (isLow) {\n          points[1].yValue = points[1].low < points[1].high ? points[1].low : points[1].high;\n          points[0].yValue = points[0].low < points[0].high ? points[0].low : points[0].high;\n          points[points.length - 1].yValue = points[points.length - 1].low < points[points.length - 1].high ? points[points.length - 1].low : points[points.length - 1].high;\n          points[points.length - 2].yValue = points[points.length - 2].low < points[points.length - 2].high ? points[points.length - 2].low : points[points.length - 2].high;\n        }\n      }\n      ySpline[0] = 3 * (points[1].yValue - points[0].yValue) / (points[1].xValue - points[0].xValue) - 3;\n      ySplineDuplicate[0] = 0.5;\n      ySpline[points.length - 1] = 3 * (points[points.length - 1].yValue - points[points.length - 2].yValue) / (points[points.length - 1].xValue - points[points.length - 2].xValue);\n      ySpline[0] = ySplineDuplicate[0] = Math.abs(ySpline[0]) === Infinity ? 0 : ySpline[0];\n      ySpline[points.length - 1] = ySplineDuplicate[points.length - 1] = Math.abs(ySpline[points.length - 1]) === Infinity ? 0 : ySpline[points.length - 1];\n    }\n    return ySpline;\n  };\n  /**\n   * Calculates the coefficients for a natural spline interpolation.\n   *\n   * @param {Points[]} points - The data points for spline interpolation.\n   * @param {Series} series - The series associated with the data points.\n   * @param {boolean} isLow - Indicates whether to calculate the lower bound.\n   * @returns {number[]} The calculated coefficients.\n   * @private\n   */\n  SplineBase.prototype.naturalSplineCoefficients = function (points, series, isLow) {\n    var count = points.length;\n    var ySpline = [];\n    var ySplineDuplicate = [];\n    var dy1;\n    var dy2;\n    var coefficient1;\n    var coefficient2;\n    var coefficient3;\n    ySpline[0] = ySplineDuplicate[0] = 0;\n    ySpline[points.length - 1] = 0;\n    for (var i = 1; i < count - 1; i++) {\n      if (series.type === 'SplineRangeArea') {\n        if (!isLow) {\n          points[i + 1].yValue = points[i + 1].low > points[i + 1].high ? points[i + 1].low : points[i + 1].high;\n          points[i].yValue = points[i].low > points[i].high ? points[i].low : points[i].high;\n          points[i - 1].yValue = points[i - 1].low > points[i - 1].high ? points[i - 1].low : points[i - 1].high;\n        }\n        if (isLow) {\n          points[i + 1].yValue = points[i + 1].high < points[i + 1].low ? points[i + 1].high : points[i + 1].low;\n          points[i].yValue = points[i].high < points[i].low ? points[i].high : points[i].low;\n          points[i - 1].yValue = points[i - 1].high < points[i - 1].low ? points[i - 1].high : points[i - 1].low;\n        }\n      }\n      coefficient1 = points[i].xValue - points[i - 1].xValue;\n      coefficient2 = points[i + 1].xValue - points[i - 1].xValue;\n      coefficient3 = points[i + 1].xValue - points[i].xValue;\n      dy1 = points[i + 1].yValue - points[i].yValue || null;\n      dy2 = points[i].yValue - points[i - 1].yValue || null;\n      if (coefficient1 === 0 || coefficient2 === 0 || coefficient3 === 0) {\n        ySpline[i] = 0;\n        ySplineDuplicate[i] = 0;\n      } else {\n        var p = 1 / (coefficient1 * ySpline[i - 1] + 2 * coefficient2);\n        ySpline[i] = -p * coefficient3;\n        ySplineDuplicate[i] = p * (6 * (dy1 / coefficient3 - dy2 / coefficient1) - coefficient1 * ySplineDuplicate[i - 1]);\n      }\n    }\n    for (var k = count - 2; k >= 0; k--) {\n      ySpline[k] = ySpline[k] * ySpline[k + 1] + ySplineDuplicate[k];\n    }\n    return ySpline;\n  };\n  /**\n   * Calculates the control points for a spline segment.\n   *\n   * @param {Points} point1 - The first data point.\n   * @param {Points} point2 - The second data point.\n   * @param {number} ySpline1 - The Y-value of the first spline point.\n   * @param {number} ySpline2 - The Y-value of the second spline point.\n   * @param {Series} series - The series associated with the data points.\n   * @returns {ControlPoints} The calculated control points.\n   * @private\n   */\n  SplineBase.prototype.getControlPoints = function (point1, point2, ySpline1, ySpline2, series) {\n    var controlPoint1;\n    var controlPoint2;\n    var point;\n    var ySplineDuplicate1 = ySpline1;\n    var ySplineDuplicate2 = ySpline2;\n    var xValue1 = point1.xValue;\n    var yValue1 = point1.yValue;\n    var xValue2 = point2.xValue;\n    var yValue2 = point2.yValue;\n    switch (series.splineType) {\n      case 'Cardinal':\n        if (series.xAxis.valueType === 'DateTime') {\n          ySplineDuplicate1 = ySpline1 / this.dateTimeInterval(series);\n          ySplineDuplicate2 = ySpline2 / this.dateTimeInterval(series);\n        }\n        controlPoint1 = new ChartLocation(xValue1 + ySpline1 / 3, yValue1 + ySplineDuplicate1 / 3);\n        controlPoint2 = new ChartLocation(xValue2 - ySpline2 / 3, yValue2 - ySplineDuplicate2 / 3);\n        point = new ControlPoints(controlPoint1, controlPoint2);\n        break;\n      case 'Monotonic':\n        {\n          var value = (xValue2 - xValue1) / 3;\n          controlPoint1 = new ChartLocation(xValue1 + value, yValue1 + ySpline1 * value);\n          controlPoint2 = new ChartLocation(xValue2 - value, yValue2 - ySpline2 * value);\n          point = new ControlPoints(controlPoint1, controlPoint2);\n          break;\n        }\n      default:\n        {\n          var one3 = 1 / 3.0;\n          var deltaX2 = xValue2 - xValue1;\n          deltaX2 = deltaX2 * deltaX2;\n          var y1 = one3 * (2 * yValue1 + yValue2 - one3 * deltaX2 * (ySpline1 + 0.5 * ySpline2));\n          var y2 = one3 * (yValue1 + 2 * yValue2 - one3 * deltaX2 * (0.5 * ySpline1 + ySpline2));\n          controlPoint1 = new ChartLocation((2 * xValue1 + xValue2) * one3, y1);\n          controlPoint2 = new ChartLocation((xValue1 + 2 * xValue2) * one3, y2);\n          point = new ControlPoints(controlPoint1, controlPoint2);\n          break;\n        }\n    }\n    return point;\n  };\n  /**\n   * Calculates the date-time interval.\n   *\n   * @param {Series} series - The series for which the date-time interval needs to be calculated.\n   * @returns {number} The calculated date-time interval.\n   * @protected\n   */\n  SplineBase.prototype.dateTimeInterval = function (series) {\n    var interval = series.xAxis.actualIntervalType;\n    var intervalInMilliseconds;\n    if (interval === 'Years') {\n      intervalInMilliseconds = 365 * 24 * 60 * 60 * 1000;\n    } else if (interval === 'Months') {\n      intervalInMilliseconds = 30 * 24 * 60 * 60 * 1000;\n    } else if (interval === 'Days') {\n      intervalInMilliseconds = 24 * 60 * 60 * 1000;\n    } else if (interval === 'Hours') {\n      intervalInMilliseconds = 60 * 60 * 1000;\n    } else if (interval === 'Minutes') {\n      intervalInMilliseconds = 60 * 1000;\n    } else if (interval === 'Seconds') {\n      intervalInMilliseconds = 1000;\n    } else {\n      intervalInMilliseconds = 30 * 24 * 60 * 60 * 1000;\n    }\n    return intervalInMilliseconds;\n  };\n  /**\n   * Animates the series.\n   *\n   * @param  {Series} series - Defines the series to animate.\n   * @returns {void}\n   * @private\n   */\n  SplineBase.prototype.doAnimation = function (series) {\n    var option = series.animation;\n    this.doLinearAnimation(series, option);\n  };\n  return SplineBase;\n}(LineBase);\nexport { SplineBase };","map":{"version":3,"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","ChartLocation","ControlPoints","extend","isNullOrUndefined","LineBase","SplineBase","_super","chartModule","_this","call","splinePoints","lowSplinePoints","findSplinePoint","series","value","lowPoints","realPoints","points","point","pointIndex","negativePoint","filterEmptyPoints","i","length","x","index","push","isLow","findSplineCoefficients","type","drawPoints","lowDrawPoints","_i","points_1","point_1","yValue","previous","getPreviousIndex","high","low","getControlPoints","delta","yMax","yMin","controlPoint1","y","controlPoint2","Math","min","ceil","max","yAxis","valueType","floor","chart","chartAreaType","isClosed","xValue","emptyPointSettings","mode","getNextIndex","seriesPoints","isPointInRange","isEmpty","symbolLocations","regions","splice","points_2","ySpline","ySplineDuplicate","cardinalSplineTension","splineType","monotonicSplineCoefficients","cardinalSplineCofficients","clampedSplineCofficients","naturalSplineCoefficients","count","dx","dy","slope","interPoint","slopeLength","j","abs","Infinity","dy1","dy2","coefficient1","coefficient2","coefficient3","k","point1","point2","ySpline1","ySpline2","ySplineDuplicate1","ySplineDuplicate2","xValue1","yValue1","xValue2","yValue2","xAxis","dateTimeInterval","one3","deltaX2","y1","y2","interval","actualIntervalType","intervalInMilliseconds","doAnimation","option","animation","doLinearAnimation"],"sources":["C:/Users/gabby/trax-x/node_modules/@syncfusion/ej2-charts/src/chart/series/spline-base.js"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ChartLocation, ControlPoints } from '../../common/utils/helper';\nimport { extend, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { LineBase } from './line-base';\n/**\n * Base class for spline-type series.\n *\n * @private\n */\nvar SplineBase = /** @class */ (function (_super) {\n    __extends(SplineBase, _super);\n    /**\n     * Initializes the spline rendering module.\n     *\n     * @param {Chart} [chartModule] - Specifies the chart instance.\n     */\n    function SplineBase(chartModule) {\n        var _this = _super.call(this, chartModule) || this;\n        _this.splinePoints = [];\n        _this.lowSplinePoints = [];\n        return _this;\n    }\n    /**\n     * Finds the spline points for the series.\n     *\n     * @param {Series} series - The series for which spline points need to be found.\n     * @returns {void}\n     * @private\n     */\n    SplineBase.prototype.findSplinePoint = function (series) {\n        var value;\n        var lowPoints;\n        var realPoints = [];\n        var points = [];\n        var point;\n        var pointIndex = 0;\n        var negativePoint = false;\n        realPoints = this.filterEmptyPoints(series);\n        for (var i = 0; i < realPoints.length; i++) {\n            point = realPoints[i];\n            if (point.x === null || point.x === '') {\n                continue;\n            }\n            else {\n                point.index = pointIndex;\n                pointIndex++;\n                points.push(point);\n            }\n        }\n        var isLow = false;\n        this.splinePoints = this.findSplineCoefficients(points, series, isLow);\n        if (series.type === 'SplineRangeArea') {\n            isLow = !isLow;\n            this.lowSplinePoints = this.findSplineCoefficients(points, series, isLow);\n        }\n        if (points.length > 1) {\n            series.drawPoints = [];\n            series.lowDrawPoints = [];\n            for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n                var point_1 = points_1[_i];\n                negativePoint = negativePoint ? negativePoint : point_1.yValue < 0;\n                if (point_1.index !== 0) {\n                    var previous = this.getPreviousIndex(points, point_1.index - 1, series);\n                    if (series.type === 'SplineRangeArea') {\n                        points[previous].yValue = points[previous].high > points[previous].low ?\n                            points[previous].high : points[previous].low;\n                        point_1.yValue = point_1.high > point_1.low ? point_1.high : point_1.low;\n                    }\n                    value = this.getControlPoints(points[previous], point_1, this.splinePoints[previous], this.splinePoints[point_1.index], series);\n                    series.drawPoints.push(value);\n                    if (series.type === 'SplineRangeArea') {\n                        points[previous].yValue = points[previous].low < points[previous].high ?\n                            points[previous].low : points[previous].high;\n                        point_1.yValue = point_1.low < point_1.high ? point_1.low : point_1.high;\n                        lowPoints = this.getControlPoints(points[previous], point_1, this.lowSplinePoints[previous], this.lowSplinePoints[point_1.index], series);\n                        series.lowDrawPoints.push(lowPoints);\n                    }\n                    // fix for Y-Axis of Spline chart not adjusting scale to suit dataSource issue\n                    var delta = series.yMax - series.yMin;\n                    if (point_1.yValue && value.controlPoint1.y && value.controlPoint2.y && delta > 1) {\n                        series.yMin = Math.min(series.yMin, point_1.yValue, value.controlPoint1.y, value.controlPoint2.y);\n                        series.yMax = Math.ceil(Math.max(series.yMax, point_1.yValue, value.controlPoint1.y, value.controlPoint2.y));\n                        series.yMin = series.yAxis.valueType !== 'Logarithmic' ? Math.floor(series.yMin) : series.yMin;\n                    }\n                }\n            }\n            if (!negativePoint && series.yMin < 0) {\n                series.yMin = 0;\n            }\n            if (series.chart.chartAreaType === 'PolarRadar' && series.isClosed) {\n                value = this.getControlPoints({ xValue: points[points.length - 1].xValue, yValue: points[points.length - 1].yValue }, { xValue: points[points.length - 1].xValue + 1, yValue: points[0].yValue }, this.splinePoints[0], this.splinePoints[points[points.length - 1].index], series);\n                series.drawPoints.push(value);\n            }\n        }\n    };\n    SplineBase.prototype.getPreviousIndex = function (points, i, series) {\n        if (series.emptyPointSettings.mode !== 'Drop') {\n            return i;\n        }\n        while (isNullOrUndefined(points[i]) && i > -1) {\n            i = i - 1;\n        }\n        return i;\n    };\n    SplineBase.prototype.getNextIndex = function (points, i, series) {\n        if (series.emptyPointSettings.mode !== 'Drop') {\n            return i;\n        }\n        while (isNullOrUndefined(points[i]) && i < points.length) {\n            i = i + 1;\n        }\n        return i;\n    };\n    SplineBase.prototype.filterEmptyPoints = function (series, seriesPoints) {\n        if (series.emptyPointSettings.mode !== 'Drop' && this.isPointInRange(series.points)) {\n            return seriesPoints ? seriesPoints : series.points;\n        }\n        var points = seriesPoints ? seriesPoints : extend([], series.points, null, true);\n        for (var i = 0; i < points.length; i++) {\n            points[i].index = i;\n            if (points[i].isEmpty) {\n                points[i].symbolLocations = [];\n                points[i].regions = [];\n                points.splice(i, 1);\n                i--;\n            }\n        }\n        return points;\n    };\n    /**\n     * Checks if the data points are within the range.\n     *\n     * @param {Points[]} points - The data points to check.\n     * @returns {boolean} True if the data points are within the range, false otherwise.\n     * @private\n     */\n    SplineBase.prototype.isPointInRange = function (points) {\n        for (var _i = 0, points_2 = points; _i < points_2.length; _i++) {\n            var point = points_2[_i];\n            if (!point.isPointInRange) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Finds the spline coefficients based on the type of spline interpolation.\n     *\n     * @param {Points[]} points - The data points for spline interpolation.\n     * @param {Series} series - The series associated with the data points.\n     * @param {boolean} [isLow] - Indicates whether to calculate the lower bound. Default is false.\n     * @returns {number[]} The calculated coefficients.\n     * @private\n     */\n    SplineBase.prototype.findSplineCoefficients = function (points, series, isLow) {\n        var ySpline = [];\n        var ySplineDuplicate = [];\n        var cardinalSplineTension = series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;\n        // cardinalSplineTension = cardinalSplineTension < 0 ? 0 : cardinalSplineTension > 1 ? 1 : cardinalSplineTension;\n        if (cardinalSplineTension < 0) {\n            cardinalSplineTension = 0;\n        }\n        else if (cardinalSplineTension > 1) {\n            cardinalSplineTension = 1;\n        }\n        switch (series.splineType) {\n            case 'Monotonic':\n                ySpline = this.monotonicSplineCoefficients(points, series, isLow);\n                break;\n            case 'Cardinal':\n                ySpline = this.cardinalSplineCofficients(points, series);\n                break;\n            default:\n                if (series.splineType === 'Clamped') {\n                    ySpline = this.clampedSplineCofficients(points, series, isLow);\n                }\n                else {\n                    // assigning the first and last value as zero\n                    ySpline[0] = ySplineDuplicate[0] = 0;\n                    ySpline[points.length - 1] = 0;\n                }\n                ySpline = this.naturalSplineCoefficients(points, series, isLow);\n                break;\n        }\n        return ySpline;\n    };\n    /**\n     * Calculates the coefficients for a monotonic spline interpolation.\n     *\n     * @param {Points[]} points - The data points for spline interpolation.\n     * @param {Series} series - The series associated with the data points.\n     * @param {boolean} isLow - Indicates whether to calculate the lower bound.\n     * @returns {number[]} The calculated coefficients.\n     * @private\n     */\n    SplineBase.prototype.monotonicSplineCoefficients = function (points, series, isLow) {\n        var count = points.length;\n        var ySpline = [];\n        var dx = [];\n        var dy = [];\n        var slope = [];\n        var interPoint;\n        for (var i = 0; i < count - 1; i++) {\n            if (series.type === 'SplineRangeArea') {\n                if (!isLow) {\n                    points[i + 1].yValue = points[i + 1].high > points[i + 1].low ?\n                        points[i + 1].high : points[i + 1].low;\n                    points[i].yValue = points[i].high > points[i].low ?\n                        points[i].high : points[i].low;\n                }\n                if (isLow) {\n                    points[i + 1].yValue = points[i + 1].low < points[i + 1].high ? points[i + 1].low :\n                        points[i + 1].high;\n                    points[i].yValue = points[i].low < points[i].high ? points[i].low :\n                        points[i].high;\n                }\n            }\n            dx[i] = points[i + 1].xValue - points[i].xValue;\n            dy[i] = points[i + 1].yValue - points[i].yValue;\n            slope[i] = dy[i] / dx[i];\n        }\n        //interpolant points\n        var slopeLength = slope.length;\n        // to find the first and last co-efficient value\n        ySpline[0] = slope[0];\n        ySpline[count - 1] = slope[slopeLength - 1];\n        //to find the other co-efficient values\n        for (var j = 0; j < dx.length; j++) {\n            if (slopeLength > j + 1) {\n                if (slope[j] * slope[j + 1] <= 0) {\n                    ySpline[j + 1] = 0;\n                }\n                else {\n                    interPoint = dx[j] + dx[j + 1];\n                    ySpline[j + 1] = 3 * interPoint / ((interPoint + dx[j + 1]) / slope[j] +\n                        (interPoint + dx[j]) / slope[j + 1]);\n                }\n            }\n        }\n        return ySpline;\n    };\n    /**\n     * Calculates the coefficients for a cardinal spline interpolation.\n     *\n     * @param {Points[]} points - The data points for spline interpolation.\n     * @param {Series} series - The series associated with the data points.\n     * @returns {number[]} The calculated coefficients.\n     * @private\n     */\n    SplineBase.prototype.cardinalSplineCofficients = function (points, series) {\n        var count = points.length;\n        var ySpline = [];\n        var cardinalSplineTension = series.cardinalSplineTension ? series.cardinalSplineTension : 0.5;\n        cardinalSplineTension = cardinalSplineTension < 0 ? 0 : cardinalSplineTension > 1 ? 1 : cardinalSplineTension;\n        for (var i = 0; i < count; i++) {\n            if (i === 0) {\n                ySpline[i] = (count > 2) ? (cardinalSplineTension * (points[i + 2].xValue - points[i].xValue)) : 0;\n            }\n            else if (i === (count - 1)) {\n                ySpline[i] = (count > 2) ? (cardinalSplineTension * (points[count - 1].xValue - points[count - 3].xValue)) : 0;\n            }\n            else {\n                ySpline[i] = (cardinalSplineTension * (points[i + 1].xValue - points[i - 1].xValue));\n            }\n        }\n        return ySpline;\n    };\n    /**\n     * Calculates the coefficients for a clamped spline interpolation.\n     *\n     * @param {Points[]} points - The data points for spline interpolation.\n     * @param {Series} series - The series associated with the data points.\n     * @param {boolean} isLow - Indicates whether to calculate the lower bound.\n     * @returns {number[]} The calculated coefficients.\n     * @private\n     */\n    SplineBase.prototype.clampedSplineCofficients = function (points, series, isLow) {\n        var count = points.length;\n        var ySpline = [];\n        var ySplineDuplicate = [];\n        for (var i = 0; i < count - 1; i++) {\n            if (series.type === 'SplineRangeArea') {\n                if (!isLow) {\n                    points[1].yValue = points[1].high > points[1].low ? points[1].high : points[1].low;\n                    points[0].yValue = points[0].high > points[0].low ? points[0].high : points[0].low;\n                    points[points.length - 1].yValue = points[points.length - 1].high > points[points.length - 1].low ?\n                        points[points.length - 1].high : points[points.length - 1].low;\n                    points[points.length - 2].yValue = points[points.length - 2].high > points[points.length - 2].low ?\n                        points[points.length - 2].high : points[points.length - 2].low;\n                }\n                if (isLow) {\n                    points[1].yValue = points[1].low < points[1].high ? points[1].low : points[1].high;\n                    points[0].yValue = points[0].low < points[0].high ? points[0].low : points[0].high;\n                    points[points.length - 1].yValue = points[points.length - 1].low < points[points.length - 1].high ?\n                        points[points.length - 1].low : points[points.length - 1].high;\n                    points[points.length - 2].yValue = points[points.length - 2].low < points[points.length - 2].high ?\n                        points[points.length - 2].low : points[points.length - 2].high;\n                }\n            }\n            ySpline[0] = (3 * (points[1].yValue - points[0].yValue)) / (points[1].xValue - points[0].xValue) - 3;\n            ySplineDuplicate[0] = 0.5;\n            ySpline[points.length - 1] = (3 * (points[points.length - 1].yValue - points[points.length - 2].yValue)) /\n                (points[points.length - 1].xValue - points[points.length - 2].xValue);\n            ySpline[0] = ySplineDuplicate[0] = Math.abs(ySpline[0]) === Infinity ? 0 : ySpline[0];\n            ySpline[points.length - 1] = ySplineDuplicate[points.length - 1] = Math.abs(ySpline[points.length - 1]) === Infinity ?\n                0 : ySpline[points.length - 1];\n        }\n        return ySpline;\n    };\n    /**\n     * Calculates the coefficients for a natural spline interpolation.\n     *\n     * @param {Points[]} points - The data points for spline interpolation.\n     * @param {Series} series - The series associated with the data points.\n     * @param {boolean} isLow - Indicates whether to calculate the lower bound.\n     * @returns {number[]} The calculated coefficients.\n     * @private\n     */\n    SplineBase.prototype.naturalSplineCoefficients = function (points, series, isLow) {\n        var count = points.length;\n        var ySpline = [];\n        var ySplineDuplicate = [];\n        var dy1;\n        var dy2;\n        var coefficient1;\n        var coefficient2;\n        var coefficient3;\n        ySpline[0] = ySplineDuplicate[0] = 0;\n        ySpline[points.length - 1] = 0;\n        for (var i = 1; i < count - 1; i++) {\n            if (series.type === 'SplineRangeArea') {\n                if (!isLow) {\n                    points[i + 1].yValue = points[i + 1].low > points[i + 1].high ? points[i + 1].low :\n                        points[i + 1].high;\n                    points[i].yValue = points[i].low > points[i].high ? points[i].low :\n                        points[i].high;\n                    points[i - 1].yValue = points[i - 1].low > points[i - 1].high ? points[i - 1].low :\n                        points[i - 1].high;\n                }\n                if (isLow) {\n                    points[i + 1].yValue = points[i + 1].high < points[i + 1].low ? points[i + 1].high :\n                        points[i + 1].low;\n                    points[i].yValue = points[i].high < points[i].low ? points[i].high :\n                        points[i].low;\n                    points[i - 1].yValue = points[i - 1].high < points[i - 1].low ? points[i - 1].high :\n                        points[i - 1].low;\n                }\n            }\n            coefficient1 = points[i].xValue - points[i - 1].xValue;\n            coefficient2 = points[i + 1].xValue - points[i - 1].xValue;\n            coefficient3 = points[i + 1].xValue - points[i].xValue;\n            dy1 = points[i + 1].yValue - points[i].yValue || null;\n            dy2 = points[i].yValue - points[i - 1].yValue || null;\n            if (coefficient1 === 0 || coefficient2 === 0 || coefficient3 === 0) {\n                ySpline[i] = 0;\n                ySplineDuplicate[i] = 0;\n            }\n            else {\n                var p = 1 / (coefficient1 * ySpline[i - 1] + 2 * coefficient2);\n                ySpline[i] = -p * coefficient3;\n                ySplineDuplicate[i] = p * (6 * (dy1 / coefficient3 - dy2 / coefficient1) - coefficient1 *\n                    ySplineDuplicate[i - 1]);\n            }\n        }\n        for (var k = count - 2; k >= 0; k--) {\n            ySpline[k] = ySpline[k] * ySpline[k + 1] + ySplineDuplicate[k];\n        }\n        return ySpline;\n    };\n    /**\n     * Calculates the control points for a spline segment.\n     *\n     * @param {Points} point1 - The first data point.\n     * @param {Points} point2 - The second data point.\n     * @param {number} ySpline1 - The Y-value of the first spline point.\n     * @param {number} ySpline2 - The Y-value of the second spline point.\n     * @param {Series} series - The series associated with the data points.\n     * @returns {ControlPoints} The calculated control points.\n     * @private\n     */\n    SplineBase.prototype.getControlPoints = function (point1, point2, ySpline1, ySpline2, series) {\n        var controlPoint1;\n        var controlPoint2;\n        var point;\n        var ySplineDuplicate1 = ySpline1;\n        var ySplineDuplicate2 = ySpline2;\n        var xValue1 = point1.xValue;\n        var yValue1 = point1.yValue;\n        var xValue2 = point2.xValue;\n        var yValue2 = point2.yValue;\n        switch (series.splineType) {\n            case 'Cardinal':\n                if (series.xAxis.valueType === 'DateTime') {\n                    ySplineDuplicate1 = ySpline1 / this.dateTimeInterval(series);\n                    ySplineDuplicate2 = ySpline2 / this.dateTimeInterval(series);\n                }\n                controlPoint1 = new ChartLocation(xValue1 + ySpline1 / 3, yValue1 + ySplineDuplicate1 / 3);\n                controlPoint2 = new ChartLocation(xValue2 - ySpline2 / 3, yValue2 - ySplineDuplicate2 / 3);\n                point = new ControlPoints(controlPoint1, controlPoint2);\n                break;\n            case 'Monotonic': {\n                var value = (xValue2 - xValue1) / 3;\n                controlPoint1 = new ChartLocation(xValue1 + value, yValue1 + ySpline1 * value);\n                controlPoint2 = new ChartLocation(xValue2 - value, yValue2 - ySpline2 * value);\n                point = new ControlPoints(controlPoint1, controlPoint2);\n                break;\n            }\n            default: {\n                var one3 = 1 / 3.0;\n                var deltaX2 = (xValue2 - xValue1);\n                deltaX2 = deltaX2 * deltaX2;\n                var y1 = one3 * (((2 * yValue1) + yValue2) - one3 * deltaX2 * (ySpline1 + 0.5 * ySpline2));\n                var y2 = one3 * ((yValue1 + (2 * yValue2)) - one3 * deltaX2 * (0.5 * ySpline1 + ySpline2));\n                controlPoint1 = new ChartLocation((2 * (xValue1) + (xValue2)) * one3, y1);\n                controlPoint2 = new ChartLocation(((xValue1) + 2 * (xValue2)) * one3, y2);\n                point = new ControlPoints(controlPoint1, controlPoint2);\n                break;\n            }\n        }\n        return point;\n    };\n    /**\n     * Calculates the date-time interval.\n     *\n     * @param {Series} series - The series for which the date-time interval needs to be calculated.\n     * @returns {number} The calculated date-time interval.\n     * @protected\n     */\n    SplineBase.prototype.dateTimeInterval = function (series) {\n        var interval = series.xAxis.actualIntervalType;\n        var intervalInMilliseconds;\n        if (interval === 'Years') {\n            intervalInMilliseconds = 365 * 24 * 60 * 60 * 1000;\n        }\n        else if (interval === 'Months') {\n            intervalInMilliseconds = 30 * 24 * 60 * 60 * 1000;\n        }\n        else if (interval === 'Days') {\n            intervalInMilliseconds = 24 * 60 * 60 * 1000;\n        }\n        else if (interval === 'Hours') {\n            intervalInMilliseconds = 60 * 60 * 1000;\n        }\n        else if (interval === 'Minutes') {\n            intervalInMilliseconds = 60 * 1000;\n        }\n        else if (interval === 'Seconds') {\n            intervalInMilliseconds = 1000;\n        }\n        else {\n            intervalInMilliseconds = 30 * 24 * 60 * 60 * 1000;\n        }\n        return intervalInMilliseconds;\n    };\n    /**\n     * Animates the series.\n     *\n     * @param  {Series} series - Defines the series to animate.\n     * @returns {void}\n     * @private\n     */\n    SplineBase.prototype.doAnimation = function (series) {\n        var option = series.animation;\n        this.doLinearAnimation(series, option);\n    };\n    return SplineBase;\n}(LineBase));\nexport { SplineBase };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}